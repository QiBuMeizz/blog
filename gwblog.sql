/*
SQLyog Ultimate v12.5.0 (64 bit)
MySQL - 5.5.54 : Database - gwblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`gwblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `gwblog`;

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论的id',
  `name` varchar(255) DEFAULT NULL COMMENT '评论者的名字',
  `email` varchar(255) DEFAULT NULL COMMENT '评论者的邮箱',
  `text` text COMMENT '内容',
  `pic` varchar(255) DEFAULT NULL COMMENT '头像的路径',
  `is_parent` tinyint(1) DEFAULT '0' COMMENT '是否有回复，0-false，1-true',
  `parent_id` bigint(20) DEFAULT NULL COMMENT '父评论的id',
  `content_id` bigint(20) DEFAULT NULL COMMENT '所属文章的id',
  `status` int(4) DEFAULT NULL COMMENT '评论的状态值:1(已审核),0(待审核)',
  `created` datetime DEFAULT NULL COMMENT '创建时间',
  `updated` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8;

/*Data for the table `comment` */

insert  into `comment`(`id`,`name`,`email`,`text`,`pic`,`is_parent`,`parent_id`,`content_id`,`status`,`created`,`updated`) values 
(1,'游客1','123@163.com','测试评论1',NULL,1,0,1,1,'2018-12-17 19:20:52','2018-12-17 19:20:55'),
(2,'张三','123@163.com','测试评论2',NULL,1,1,1,1,'2018-12-17 19:22:05','2018-12-17 19:22:09'),
(3,'游客2','123@163.com','测试评论3',NULL,1,2,1,1,'2018-12-17 19:22:54','2018-12-17 19:22:57'),
(4,'游客3','1123@163.com','测试评论4',NULL,0,1,1,1,'2018-12-17 19:23:50','2018-12-17 19:23:53'),
(5,'游客4','123@163.com','测试评论5',NULL,0,1,1,1,'2018-12-17 19:24:42','2018-12-17 19:24:45'),
(6,'游客5','123@126.com','说的不错',NULL,0,3,1,1,'2018-12-20 12:03:27','2018-12-20 12:03:29'),
(7,'游客6','1223@126.com','sadasdasd',NULL,1,0,1,1,'2018-12-20 14:08:32','2018-12-20 14:08:35'),
(8,'游客7','qqq@163.com','666s',NULL,0,0,1,1,'2018-12-20 14:13:42','2018-12-20 14:13:44'),
(9,'游客8','aaa@163.com','666s',NULL,0,0,1,1,'2018-12-20 14:13:49','2018-12-20 14:13:51'),
(10,'游客9','ascs@163.com','666s',NULL,0,0,1,1,'2018-12-20 14:13:54','2018-12-20 14:13:56'),
(11,'游客10','ascwq@163.com','666s',NULL,0,0,1,1,'2018-12-20 14:13:58','2018-12-20 14:13:59'),
(12,'游客11','sssa@163.com','666s',NULL,0,0,1,1,'2018-12-20 14:14:01','2018-12-20 14:14:03'),
(13,'游客12','ada@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:15:59','2018-12-20 14:16:12'),
(14,'游客13','aad@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:16:01','2018-12-20 14:16:14'),
(15,'游客14','aaaaad@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:16:03','2018-12-20 14:16:15'),
(16,'游客15','qqqqww@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:16:05','2018-12-20 14:16:16'),
(17,'游客16','ffaa@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:16:07','2018-12-20 14:16:18'),
(18,'游客17','ffwwaa@163.com','666s',NULL,0,2,1,1,'2018-12-20 14:16:09','2018-12-20 14:16:20'),
(19,'游客18','ffwwdaa@163.com','666s',NULL,0,7,1,1,'2018-12-20 14:16:10','2018-12-20 14:16:21');

/*Table structure for table `content` */

DROP TABLE IF EXISTS `content`;

CREATE TABLE `content` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章的id',
  `type_id` bigint(20) DEFAULT NULL COMMENT '文章所属类目的id',
  `title` varchar(255) DEFAULT NULL COMMENT '文章标题',
  `author_id` bigint(20) DEFAULT NULL COMMENT '作者的id',
  `pic` varchar(255) DEFAULT NULL COMMENT '封面图片路径',
  `status` int(4) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)',
  `content` text COMMENT '文章内容',
  `title_desc` varchar(500) DEFAULT NULL COMMENT '标题描述',
  `reads` bigint(20) DEFAULT NULL COMMENT '阅读量',
  `created` datetime DEFAULT NULL COMMENT '创建时间',
  `updated` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=352 DEFAULT CHARSET=utf8;

/*Data for the table `content` */

insert  into `content`(`id`,`type_id`,`title`,`author_id`,`pic`,`status`,`content`,`title_desc`,`reads`,`created`,`updated`) values 
(1,1,'测试文章1',1,NULL,1,'测试文章1','文章1标题',10,'2018-12-17 19:06:02','2018-12-17 19:06:05'),
(2,2,'测试文章2',1,NULL,1,'测试文章2','文章2标题',10,'2018-12-17 19:07:04','2018-12-17 19:07:08'),
(3,3,'测试文章3',1,NULL,1,'测试文章3','文章3标题',10,'2018-12-17 19:07:53','2018-12-17 19:07:56'),
(4,4,'测试文章4',1,NULL,1,'测试文章4\r\n','文章标题4',10,'2018-12-17 19:10:06','2018-12-17 19:10:09'),
(5,5,'测试文章5',1,NULL,1,'测试文章5','文章标题5',10,'2018-12-17 19:10:41','2018-12-17 19:10:44'),
(6,6,'测试文章6',1,NULL,1,'测试文章6','测试文章6',10,'2018-12-17 19:11:14','2018-12-17 19:11:17'),
(7,7,'测试文章7',1,NULL,1,'测试文章7','测试文章7',10,'2018-12-17 19:11:46','2018-12-17 19:11:49'),
(8,8,'测试文章8',1,NULL,1,'测试文章8','测试文章8',10,'2018-12-17 19:12:20','2018-12-17 19:12:24'),
(9,9,'测试文章9',1,NULL,1,'测试文章9','测试文章9',10,'2018-12-17 19:13:03','2018-12-17 19:13:06'),
(10,10,'测试文章10',1,NULL,1,'测试文章10','测试文章10',10,'2018-12-17 19:13:31','2018-12-17 19:13:34'),
(11,3,'Java 单体应用',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24437270/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-上</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437288/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-中</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437300/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-下</a></li> \n </ul> \n <h3 id=\"第-01-章-使用-Intellij-IDEA\"><a href=\"#第-01-章-使用-Intellij-IDEA\" class=\"headerlink\" title=\"第 01 章 使用 Intellij IDEA\"></a>第 01 章 使用 Intellij IDEA</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24437425/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/IDEA-简介/\">IDEA 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437719/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/第一个-IDEA-应用程序/\">第一个 IDEA 应用程序</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437746/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-使用 Markdown 记笔记</a></li> \n </ul> \n <h3 id=\"第-02-章-使用-Maven-构建应用\"><a href=\"#第-02-章-使用-Maven-构建应用\" class=\"headerlink\" title=\"第 02 章 使用 Maven 构建应用\"></a>第 02 章 使用 Maven 构建应用</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24451433/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-简介/\">Maven 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24451908/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-安装配置/\">Maven 安装配置</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24451974/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-本地仓库/\">Maven 本地仓库</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24454166/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-中央仓库/\">Maven 中央仓库</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455290/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-依赖机制/\">Maven 依赖机制</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455333/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-POM/\">Maven POM</a></li> \n  <li><a href=\"/2018/06/03/monolithic/Maven-插件/\">Maven 插件</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455373/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-快照/\">Maven 快照</a></li> \n  <li><a href=\"/2018/06/03/monolithic/Maven-常用命令/\">Maven 常用命令</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455466/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/第一个-Maven-应用程序/\">第一个 Maven 应用程序</a></li> \n </ul> \n <h3 id=\"第-03-章-三层架构-MVC\"><a href=\"#第-03-章-三层架构-MVC\" class=\"headerlink\" title=\"第 03 章 三层架构 + MVC\"></a>第 03 章 三层架构 + MVC</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24480245/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/04/monolithic/什么是三层架构/\">什么是三层架构</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480269/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/04/monolithic/什么是-MVC-模式/\">什么是 MVC 模式</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480283/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-高内聚，低耦合</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480296/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-三层架构-1</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480336/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-三层架构-2</a></li> \n </ul> \n <h3 id=\"第-04-章-使用-Bootstrap\"><a href=\"#第-04-章-使用-Bootstrap\" class=\"headerlink\" title=\"第 04 章 使用 Bootstrap\"></a>第 04 章 使用 Bootstrap</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24480397/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-关于如何自学的一些心得</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24481998/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-简介/\">Bootstrap 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482476/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-环境安装/\">Bootstrap 环境安装</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482487/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-网格系统/\">Bootstrap 网格系统</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482488/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/媒体查询的用法/\">媒体查询的用法</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482490/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-表格/\">Bootstrap 表格</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482495/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-字体图标/\">Bootstrap 字体图标</a></li> \n </ul> \n <h3 id=\"第-05-章-基础框架入门\"><a href=\"#第-05-章-基础框架入门\" class=\"headerlink\" title=\"第 05 章 基础框架入门\"></a>第 05 章 基础框架入门</h3>\n <ul> \n  <li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509363/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-简介/\">Spring 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509385/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-体系结构/\">Spring 体系结构</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509422/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-的特点/\">Spring 的特点</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509478/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-与-IoC/\">Spring 与 IoC</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509521/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-Spring-应用程序/\">第一个 Spring 应用程序</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"JUnit-单元测试\"><a href=\"#JUnit-单元测试\" class=\"headerlink\" title=\"JUnit 单元测试\"></a>JUnit 单元测试</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509803/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-什么是 TDD 及常见的测试方式</a> </li> \n    <li><a href=\"https://www.bilibili.com/video/av24509763/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/JUnit-简介/\">JUnit 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509731/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-JUnit-单元测试/\">第一个 JUnit 单元测试</a></li> \n    <li><a href=\"/2018/06/07/monolithic/JUnit-注解/\">JUnit 注解</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509691/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/JUnit-断言/\">JUnit 断言</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Log4j-日志框架\"><a href=\"#Log4j-日志框架\" class=\"headerlink\" title=\"Log4j 日志框架\"></a>Log4j 日志框架</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509656/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-简介/\">Log4j 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509628/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-日志级别/\">Log4j 日志级别</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509595/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-日志输出控制文件/\">Log4j 日志输出控制文件</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509552/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-Log4j-日志文件/\">第一个 Log4j 日志文件（使用 Slf4j 输出）</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"综合复习\"><a href=\"#综合复习\" class=\"headerlink\" title=\"综合复习\"></a>综合复习</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24556086/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-本周知识总结</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556138/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-创建项目</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556250/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-Bootstrap 管理模板-AdminLTE</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556294/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-Bootstrap 管理模板-创建登录页</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556338/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-实现登录功能-完成后台编码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556196/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-实现登录功能-增强用户体验</a></li> \n </ul> \n <h3 id=\"第-06-章-Spring-Web-与-Bean-装配\"><a href=\"#第-06-章-Spring-Web-与-Bean-装配\" class=\"headerlink\" title=\"第 06 章 Spring Web 与 Bean 装配\"></a>第 06 章 Spring Web 与 Bean 装配</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24698265/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/Spring-整合-Web/\">Spring 整合 Web</a></li> \n  <li><a href=\"/2018/06/11/monolithic/ApplicationContextAware/\">ApplicationContextAware</a></li> \n  <li><a href=\"/2018/06/11/monolithic/Bean-的装配方式/\">Bean 的装配方式</a>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24698287/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/容器中-Bean-的作用域/\">容器中 Bean 的作用域</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24698302/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/基于注解的装配方式/\">基于注解的装配方式</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av24698335/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/浏览器端存储技术简介/\">浏览器端存储技术简介（课后作业：记住我）</a></li> \n </ul> \n <h3 id=\"第-07-章-Spring-MVC-与-Maven-模块化开发\"><a href=\"#第-07-章-Spring-MVC-与-Maven-模块化开发\" class=\"headerlink\" title=\"第 07 章 Spring MVC 与 Maven 模块化开发\"></a>第 07 章 Spring MVC 与 Maven 模块化开发</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24741954/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-MVC-简介/\">Spring MVC 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24741988/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-整合-Spring-MVC/\">Spring 整合 Spring MVC</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742021/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/第一个-Controller-控制器/\">第一个 Controller 控制器</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742046/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-MVC-拦截器的使用/\">Spring MVC 拦截器的使用</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742070/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Maven-模块化开发/\">Maven 模块化开发</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742106/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-重新完善功能代码</a></li> \n </ul> \n <h3 id=\"第-08-章-MyBatis-数据持久化\"><a href=\"#第-08-章-MyBatis-数据持久化\" class=\"headerlink\" title=\"第 08 章 MyBatis 数据持久化\"></a>第 08 章 MyBatis 数据持久化</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24818342/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/MyBatis-简介/\">MyBatis 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818369/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Druid-简介/\">Druid 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818402/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Spring-整合-Druid/\">Spring 整合 Druid</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818423/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Spring-整合-MyBatis/\">Spring 整合 MyBatis</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818453/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-utf8 与 utf8mb4 字符集</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818481/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/第一个-MyBatis-对象关系映射/\">第一个 MyBatis 对象关系映射</a></li> \n </ul> \n <h3 id=\"第-09-章-MyBatis-表操作\"><a href=\"#第-09-章-MyBatis-表操作\" class=\"headerlink\" title=\"第 09 章 MyBatis 表操作\"></a>第 09 章 MyBatis 表操作</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24883965\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/MyBatis-单表-CRUD-操作/\">MyBatis 单表 CRUD 操作</a>\n   <ul> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-INSERT-新增/\">INSERT 新增</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-DELETE-删除/\">DELETE 删除</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-查询单个对象/\">查询单个对象</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-UPDATE-更新/\">UPDATE 更新</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-使用模糊查询/\">使用模糊查询</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av24884003\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现用户登录功能</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24884030\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现首页布局</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24884062\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-用户列表展示</a></li> \n </ul> \n <h3 id=\"第-10-章-项目实战相关知识点补充\"><a href=\"#第-10-章-项目实战相关知识点补充\" class=\"headerlink\" title=\"第 10 章 项目实战相关知识点补充\"></a>第 10 章 项目实战相关知识点补充</h3>\n <ul> \n  <li><a href=\"/2018/06/16/monolithic/Spring-MVC-表单标签库/\">Spring MVC 表单标签库</a></li> \n  <li><a href=\"/2018/06/16/monolithic/Spring-MVC-ModelAttribute-注解/\">Spring MVC @ModelAttribute 注解</a></li> \n  <li><a href=\"/2018/06/18/monolithic/Spring-MVC-ResponseBody-注解/\">Spring MVC @ResponseBody 注解</a></li> \n  <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL/\">MyBatis 动态 SQL</a>\n   <ul> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-if-标签/\">if 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-where-标签/\">where 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-choose-标签/\">choose 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-foreach-标签-遍历数组/\">foreach 标签-遍历数组</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-foreach-标签-遍历集合/\">foreach 标签-遍历集合</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-sql-标签/\">sql 标签</a></li> \n   </ul> </li> \n  <li><a href=\"/2018/06/26/monolithic/Spring-Validation-简化服务端验证/\">Spring Validation 简化服务端验证</a></li> \n </ul> \n <h3 id=\"项目实战视频集合（上）\"><a href=\"#项目实战视频集合（上）\" class=\"headerlink\" title=\"项目实战视频集合（上）\"></a>项目实战视频集合（上）</h3>\n <ul> \n  <li><h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24884003\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现用户登录功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24884030\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现首页布局</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24884062\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-用户列表展示</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236054\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现新增用户功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236061\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 Spring MVC 表单标签简化表单开发</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236065\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 jQuery Validation 实现表单验证</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25259516\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用动态 SQL 实现搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25259997\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-优化搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25260018\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 jQuery iCheck 插件实现全选反选功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340288\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现批量删除功能1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340326\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现批量删除功能2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340368\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 DataTables 插件实现分页功能1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340407\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 DataTables 插件实现分页功能2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25405331\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现编辑和查看功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25426189\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-重新实现搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25426237\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-最后的收尾工作</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"内容管理\"><a href=\"#内容管理\" class=\"headerlink\" title=\"内容管理\"></a>内容管理</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av25555223\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-内容分类功能准备</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25555266\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 TreeTable 展示树形表格</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25584822\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-内容列表功能准备</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25584906\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 zTree 展示内容分类数据</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693473\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Lombok 插件简化 Bean 代码</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693494\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Spring Validation 简化服务端验证</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693524\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-Spring MVC + Dropzone 实现图片上传</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693551\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-封装 Dropzone 插件</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740747\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 wangEditor 富文本编辑器</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740776\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现 wangEditor 文件上传功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740833\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现关联关系查询</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740876\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-提取统一的数据访问和业务接口</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827541\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现内容分类的新增功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827584\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-深度封装业务逻辑层1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827617\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-深度封装业务逻辑层2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827661\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-封装控制器层</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"第-11-章-Spring-的事务管理\"><a href=\"#第-11-章-Spring-的事务管理\" class=\"headerlink\" title=\"第 11 章 Spring 的事务管理\"></a>第 11 章 Spring 的事务管理</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av25827750\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/28/monolithic/Spring-事务管理简介/\">Spring 事务管理简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25827857\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/29/monolithic/使用-AspectJ-的-AOP-配置管理事务/\">使用 AspectJ 的 AOP 配置管理事务</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25827802\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/29/monolithic/使用-Spring-注解管理事务/\">使用 Spring 注解管理事务</a></li> \n </ul> \n <h3 id=\"第-12-章-解决模块间的通信问题\"><a href=\"#第-12-章-解决模块间的通信问题\" class=\"headerlink\" title=\"第 12 章 解决模块间的通信问题\"></a>第 12 章 解决模块间的通信问题</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av25992351\" target=\"_blank\" rel=\"noopener\">【视频】项目改动说明</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25992450\" target=\"_blank\" rel=\"noopener\">【视频】后台管理与门户数据展示说明</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25992502\" target=\"_blank\" rel=\"noopener\">【视频】为什么存在通信问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109195\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/07/03/monolithic/使用-Apache-HttpClient-解决通信问题/\">使用 Apache HttpClient 解决通信问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109207\" target=\"_blank\" rel=\"noopener\">【视频】Apache HttpClient 使用实例</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109218/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/07/03/monolithic/使用-Jackson-处理-JSON-数据/\">使用 Jackson 处理 JSON 数据</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109230/\" target=\"_blank\" rel=\"noopener\">【视频】创建 API 接口模块</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109239/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-POJO、VO、DTO、Entity、Domain 的区别</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109248/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RESTful/\">使用 RESTFul 风格设计 API</a>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说如何设计一个良好的-API/\">如何设计一个良好的 API</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何理解-RESTful-API-的幂等性/\">如何理解 RESTful API 的幂等性</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av26109258/\" target=\"_blank\" rel=\"noopener\">【视频】使用 Spirng MVC 实现 RESTful 风格的 API</a></li> \n </ul> \n <h3 id=\"项目实战视频集合（下）\"><a href=\"#项目实战视频集合（下）\" class=\"headerlink\" title=\"项目实战视频集合（下）\"></a>项目实战视频集合（下）</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av26166835\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-创建 Web UI 门户模块</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26166862\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现 UI 模块与 API 模块的通信</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26166882\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户首页的幻灯片展示</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298091\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-实现 API</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298138\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-对接 API</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298192\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-使用拦截器禁止重复登录</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298238\" target=\"_blank\" rel=\"noopener\">【视频】小知识-验证码的作用与如何打码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298288\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-解决 Maven 无法下载依赖的问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298347\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-增加 Kaptcha 验证码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298426\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Apache Commons Email 发送邮件</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298518\" target=\"_blank\" rel=\"noopener\">【视频】课程完结-阶段总结，撒花，撒花，可喜可贺，可喜可贺</a></li> \n </ul> \n <h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3>\n <ul> \n  <li><h4 id=\"常用工具类（Java）\"><a href=\"#常用工具类（Java）\" class=\"headerlink\" title=\"常用工具类（Java）\"></a>常用工具类（Java）</h4>\n   <ul> \n    <li><a href=\"/2018/06/17/appose/CookieUtils/\">CookieUtils Cookie 工具类</a></li> \n    <li><a href=\"/2018/06/17/appose/RegexpUtils/\">RegexpUtils 正则表达式工具类</a></li> \n    <li><a href=\"/2018/07/03/appose/MapperUtils-Jackson-工具类/\">MapperUtils Jackson 工具类</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用工具类（JS）\"><a href=\"#常用工具类（JS）\" class=\"headerlink\" title=\"常用工具类（JS）\"></a>常用工具类（JS）</h4>\n   <ul> \n    <li><a href=\"/2018/06/25/appose/DateTimeJS/\">DateTime 日期工具类</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用-JS-插件\"><a href=\"#常用-JS-插件\" class=\"headerlink\" title=\"常用 JS 插件\"></a>常用 JS 插件</h4>\n   <ul> \n    <li><a href=\"/2018/06/17/appose/jQuery-Validation/\">jQuery Validation 表单验证插件</a></li> \n    <li><a href=\"/2018/06/18/appose/jQuery-iCheck/\">jQuery iCheck 复选/单选美化插件</a></li> \n    <li><a href=\"/2018/06/21/appose/jQuery-Datatables/\">jQuery Datatables 表格插件</a></li> \n    <li><a href=\"/2018/06/25/appose/jQuery-TreeTable/\">jQuery TreeTable 树表格插件</a></li> \n    <li><a href=\"/2018/06/25/appose/jQuery-zTree/\">jQuery zTree 树形结构插件</a></li> \n    <li><a href=\"/2018/06/27/appose/Dropzone-图片上传插件/\">Dropzone 图片上传插件</a></li> \n    <li><a href=\"/2018/06/28/appose/wangEditor-富文本编辑器/\">wangEditor 富文本编辑器</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用-IDEA-插件\"><a href=\"#常用-IDEA-插件\" class=\"headerlink\" title=\"常用 IDEA 插件\"></a>常用 IDEA 插件</h4>\n   <ul> \n    <li><a href=\"/2018/06/26/appose/JRebel-热部署插件/\">JRebel 热部署插件</a></li> \n    <li><a href=\"/2018/06/26/appose/Lombok-简化臃肿代码/\">Lombok 简化臃肿代码</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"其它知识点补充\"><a href=\"#其它知识点补充\" class=\"headerlink\" title=\"其它知识点补充\"></a>其它知识点补充</h4>\n   <ul> \n    <li><a href=\"/2018/07/05/appose/使用-Google-Kaptcha-生成验证码/\">使用 Kaptcha 生成验证码</a></li> \n    <li><a href=\"/2018/07/06/appose/解决-Maven-无法自动下载依赖的问题/\">解决 Maven 无法自动下载依赖的问题</a></li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(12,3,'Maven 本地仓库',1,'www.funtl.com/assets/Lusifer1511452605.png',1,'<div class=\"col-sm-12\"> \n <p>Maven 的本地资源库是用来存储所有项目的依赖关系(插件 Jar 和其他文件，这些文件被 Maven 下载)到本地文件夹。很简单，当你建立一个 Maven 项目，所有相关文件将被存储在你的 Maven 本地仓库。</p> \n <p>默认情况下，Maven 的本地资源库默认为 <code>.m2</code> 目录文件夹：</p> \n <ul> \n  <li>Unix/Mac OS X：<code>~/.m2</code></li> \n  <li>Windows：<code>C:\\Documents and Settings\\{your-username}\\.m2</code></li> \n </ul> \n <h3 id=\"配置-Maven-的本地库\"><a href=\"#配置-Maven-的本地库\" class=\"headerlink\" title=\"配置 Maven 的本地库\"></a>配置 Maven 的本地库</h3>\n <p>通常情况下，可改变默认的 <code>.m2</code> 目录下的默认本地存储库文件夹到其他更有意义的名称，例如， maven-repo 找到 <code>{M2_HOME}\\conf\\setting.xml</code>, 更新 <code>localRepository</code> 到其它名称。</p> \n <p><img src=\"/assets/Lusifer1511452605.png\" alt=\"\"></p> \n <p>执行之后，新的 Maven 本地存储库现在改为 <code>D:/apache-maven-3.5.2/repo</code></p> \n <p><img src=\"/assets/Lusifer1511452727.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(13,3,'Maven 安装配置',1,'www.funtl.com/assets/Lusifer1511451715.png',1,'<div class=\"col-sm-12\"> \n <p>想要安装 Apache Maven 在 Windows 系统上, 需要下载 Maven 的 zip 文件，并将其解压到你想安装的目录，并配置 Windows 环境变量。</p> \n <p>注意：请尽量使用 JDK 1.8 及以上版本</p> \n <h3 id=\"JDK-和-JAVA-HOME\"><a href=\"#JDK-和-JAVA-HOME\" class=\"headerlink\" title=\"JDK 和 JAVA_HOME\"></a>JDK 和 JAVA_HOME</h3>\n <p>确保已安装 JDK，并设置 <code>JAVA_HOME</code> 环境变量到 Windows 环境变量。</p> \n <p><img src=\"/assets/Lusifer1511451715.png\" alt=\"\"></p> \n <h3 id=\"下载-Apache-Maven\"><a href=\"#下载-Apache-Maven\" class=\"headerlink\" title=\"下载 Apache Maven\"></a>下载 Apache Maven</h3>\n <p>下载地址：<a href=\"http://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/download.cgi</a></p> \n <p><img src=\"/assets/Lusifer1511451890.png\" alt=\"\"></p> \n <p>下载 Maven 的 zip 文件，例如： apache-maven-3.5.2-bin.zip，将它解压到你要安装 Maven 的文件夹。假设你解压缩到文件夹 – D:\\apache-maven-3.5.2</p> \n <p><img src=\"/assets/Lusifer1511452022.png\" alt=\"\"></p> \n <p>注意：在这一步，只是文件夹和文件，安装不是必需的。</p> \n <h3 id=\"添加-MAVEN-HOME\"><a href=\"#添加-MAVEN-HOME\" class=\"headerlink\" title=\"添加 MAVEN_HOME\"></a>添加 MAVEN_HOME</h3>\n <p>添加 <code>MAVEN_HOME</code> 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。</p> \n <p><img src=\"/assets/Lusifer1511452135.png\" alt=\"\"></p> \n <h3 id=\"添加到环境变量-PATH\"><a href=\"#添加到环境变量-PATH\" class=\"headerlink\" title=\"添加到环境变量 - PATH\"></a>添加到环境变量 - PATH</h3>\n <p><img src=\"/assets/Lusifer1511452190.png\" alt=\"\"></p> \n <h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3>\n <p>使用命令：<code>mvn -version</code></p> \n <p>输出：</p> \n <pre><code>C:\\Users\\Lusifer&gt;mvn -version\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)\nMaven home: D:\\apache-maven-3.5.2\\bin\\..\nJava version: 1.8.0_152, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_152\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(14,3,'Maven 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。</p> \n <p>在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。</p> \n <p>Maven 提供了开发人员的方式来管理：</p> \n <ul> \n  <li>Builds</li> \n  <li>Documentation</li> \n  <li>Reporting</li> \n  <li>Dependencies</li> \n  <li>SCMs</li> \n  <li>Releases</li> \n  <li>Distribution</li> \n  <li>mailing list</li> \n </ul> \n <p>概括地说，Maven 简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven 增加可重用性并负责建立相关的任务。</p> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(15,3,'IDEA 简介',1,'www.funtl.com/assets/4afbfbedab64034f72b616b4a5c379310a551d0c.jpg',1,'<div class=\"col-sm-12\"> \n <p><img src=\"/assets/4afbfbedab64034f72b616b4a5c379310a551d0c.jpg\" alt=\"\"></p> \n <p>IDEA 全称 IntelliJ IDEA，是 Java 语言开发的集成环境，IntelliJ 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具(<code>git</code>、<code>svn</code>、<code>github</code> 等)、JUnit、CVS 整合、代码分析、 创新的 GUI 设计等方面的功能可以说是超常的。IDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持 HTML，CSS，PHP，MySQL，Python 等。免费版只支持 Java 等少数语言。</p> \n <h3 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h3>\n <ul> \n  <li>智能的选取：在很多时候我们要选取某个方法，或某个循环或想一步一步从一个变量到整个类慢慢扩充着选取，IDEA就提供这种基于语法的选择，在默认设置中 <code>Ctrl + W</code>，可以实现选取范围的不断扩充，这种方式在重构的时候尤其显得方便。</li> \n  <li>丰富的导航模式：IDEA 提供了丰富的导航查看模式，例如 <code>Ctrl + E</code> 显示最近打开过的文件，<code>Ctrl + N</code> 显示你希望显示的类名查找框（该框同样有智能补充功能，当你输入字母后IDEA将显示所有候选类名）。在最基本的 Project 视图中，你还可以选择多种的视图方式。</li> \n  <li>历史记录功能：不用通过版本管理服务器，单纯的 IDEA 就可以查看任何工程中文件的历史记录，在版本恢复时你可以很容易的将其恢复。</li> \n  <li>JUnit 的完美支持</li> \n  <li>对重构的优越支持：IDEA 是所有 IDE 中最早支持重构的，其优秀的重构能力一直是其主要卖点之一。</li> \n  <li>编码辅助：Java 规范中提倡的 <code>toString()</code>、<code>hashCode()</code>、<code>equals()</code> 以及所有的 <code>get/set</code> 方法，你可以不用进行任何的输入就可以实现代码的自动生成，从而把你从无聊的基本方法编码中解放出来。</li> \n  <li>灵活的排版功能：基本所有的 IDE 都有重排版功能，但仅有 IDEA 的是人性的，因为它支持排版模式的定制，你可以根据不同的项目要求采用不同的排版方式。</li> \n  <li>XML 的完美支持：XML 全提示支持：所有流行框架的 XML 文件都支持全提示，谁用谁知道。</li> \n  <li>动态语法检测：任何不符合 Java 规范、自己预定义的规范、累赘都将在页面中加亮显示。</li> \n  <li>代码检查：对代码进行自动分析，检测不符合规范的，存在风险的代码，并加亮显示。</li> \n  <li>对 JSP 的完全支持：不需要任何的插件，完全支持 JSP。</li> \n  <li>智能编辑：代码输入过程中，自动补充方法或类。</li> \n  <li>EJB 支持：不需要任何插件完全支持 EJB(6.0 支持 EJB 3.0)</li> \n  <li>列编辑模式：用过 UtralEdit 的肯定对其的列编辑模式赞赏不已，因为它减少了很多无聊的重复工作，而 IDEA 完全支持该模式，从而更加提高了编码效率。</li> \n  <li>预置模板：预置模板可以让你把经常用到的方法编辑进模板，使用时你只用输入简单的几个字母就可以完成全部代码的编写。例如使用比较高的 <code>public static void main(String[] args){}</code> 你可以在模板中预设 <code>pm</code> 为该方法，输入时你只要输入 <code>pm</code> 再按代码辅助键，IDEA 将完成代码的自动输入。</li> \n  <li>完美的自动代码完成：智能检查类中的方法，当发现方法名只有一个时自动完成代码输入，从而减少剩下代码的编写工作。</li> \n  <li>版本控制完美支持：集成了目前市面上常见的所有版本控制工具插件，包括 <code>git</code>、<code>svn</code>、<code>github</code>，让开发人员在编程的工程中直接在 Intellij IDEA 里就能完成代码的提交、检出、解决冲突、查看版本控制服务器内容等等。</li> \n  <li>不使用代码的检查：自动检查代码中不使用的代码，并给出提示，从而使代码更高效。</li> \n  <li>智能代码：自动检查代码，发现与预置规范有出入的代码给出提示，若程序员同意修改自动完成修改。例如代码：<code>String str = \"Hello Intellij \" + \"IDEA\";</code> IDEA 将给出优化提示，若程序员同意修改 IDEA 将自动将代码修改为：<code>String str = \"Hello Intellij IDEA\";</code></li> \n  <li>正则表达式的查找和替换功能：查找和替换支持正则表达式，从而提高效率。</li> \n  <li>JavaDoc 预览支持：支持 JavaDoc 的预览功能，在 JavaDoc 代码中 <code>Ctrl + Q</code> 显示 JavaDoc 的结果，从而提高 DOC 文档的质量。</li> \n  <li>程序员意图支持：程序员编码时 IDEA 时时检测你的意图，或提供建议，或直接帮你完成代码。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(16,3,'第一个 IDEA 应用程序',1,'www.funtl.com/assets/Lusifer1528017464.png',1,'<div class=\"col-sm-12\"> \n <p>下面我们来学习如何使用 IDEA 创建一个 Java Web 应用程序</p> \n <h4 id=\"新建-Java-Web-项目\"><a href=\"#新建-Java-Web-项目\" class=\"headerlink\" title=\"新建 Java Web 项目\"></a>新建 Java Web 项目</h4>\n <p>打开 <code>IDEA</code> -&gt; <code>Create New Project</code></p> \n <p><img src=\"/assets/Lusifer1528017464.png\" alt=\"\"></p> \n <p>选择 <code>Java</code> -&gt; <code>Java EE</code> -&gt; <code>Web Application</code></p> \n <p><img src=\"/assets/Lusifer1528017638.png\" alt=\"\"></p> \n <h4 id=\"选择工作空间\"><a href=\"#选择工作空间\" class=\"headerlink\" title=\"选择工作空间\"></a>选择工作空间</h4>\n <p>项目命名后选择存放的工作空间，项目就创建完成了</p> \n <p><img src=\"/assets/Lusifer1528018627.png\" alt=\"\"></p> \n <h4 id=\"配置-JDK\"><a href=\"#配置-JDK\" class=\"headerlink\" title=\"配置 JDK\"></a>配置 JDK</h4>\n <p>选择 <code>File</code> -&gt; <code>Project Structure...</code></p> \n <p><img src=\"/assets/Lusifer1528018777.png\" alt=\"\"></p> \n <p>选择 JDK 的安装路径即可</p> \n <p><img src=\"/assets/Lusifer1528018883.png\" alt=\"\"></p> \n <h4 id=\"配置-Tomcat\"><a href=\"#配置-Tomcat\" class=\"headerlink\" title=\"配置 Tomcat\"></a>配置 Tomcat</h4>\n <p>选择 <code>Run</code> -&gt; <code>Edit Configurations...</code></p> \n <p><img src=\"/assets/Lusifer1528019007.png\" alt=\"\"></p> \n <p>选择 <code>+</code> 号 -&gt; <code>Tomcat Server</code> -&gt; <code>Local</code></p> \n <p><img src=\"/assets/Lusifer1528019058.png\" alt=\"\"></p> \n <p>选择 Tomcat 的安装路径即可</p> \n <p><img src=\"/assets/Lusifer1528019181.png\" alt=\"\"></p> \n <h4 id=\"配置-Tomcat-本地部署\"><a href=\"#配置-Tomcat-本地部署\" class=\"headerlink\" title=\"配置 Tomcat 本地部署\"></a>配置 Tomcat 本地部署</h4>\n <p>继续上一步，选择 <code>Deployment</code> -&gt; <code>+</code> 号 -&gt; <code>Artifact...</code></p> \n <p><img src=\"/assets/Lusifer1528019373.png\" alt=\"\"></p> \n <p><img src=\"/assets/Lusifer1528019572.png\" alt=\"\"></p> \n <p>选择 <code>Server</code> 配置自动更新</p> \n <p><img src=\"/assets/Lusifer1528020264.png\" alt=\"\"></p> \n <h4 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h4>\n <p>选择需要运行的项目，点击 <code>运行</code> 图标</p> \n <p><img src=\"/assets/Lusifer1528020413.png\" alt=\"\"></p> \n <p>浏览器打开：<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 显示如下</p> \n <pre><code>$END$\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(17,3,'Maven 中央仓库',1,'www.funtl.com/assets/Lusifer1511452924.png',1,'<div class=\"col-sm-12\"> \n <p>当你建立一个 Maven 的项目，Maven 会检查你的 <code>pom.xml</code> 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 <a href=\"http://repo1.maven.org/maven2/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/</a> 查找下载。</p> \n <p><img src=\"/assets/Lusifer1511452924.png\" alt=\"\"></p> \n <p>使用 MVNrepository 搜索：<a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/</a></p> \n <p><img src=\"/assets/Lusifer1511453035.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(18,3,'Maven 依赖机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 Maven 依赖机制的帮助下自动下载所有必需的依赖库，并保持版本升级。让我们看一个案例研究，以了解它是如何工作的。假设你想使用 Log4j 作为项目的日志。这里你要做什么？</p> \n <h3 id=\"传统方式\"><a href=\"#传统方式\" class=\"headerlink\" title=\"传统方式\"></a>传统方式</h3>\n <ul> \n  <li><p>访问 <a href=\"http://logging.apache.org/log4j/\" target=\"_blank\" rel=\"noopener\">http://logging.apache.org/log4j/</a></p> </li> \n  <li><p>下载 Log4j 的 jar 库</p> </li> \n  <li><p>复制 jar 到项目类路径</p> </li> \n  <li><p>手动将其包含到项目的依赖</p> </li> \n  <li><p>所有的管理需要一切由自己做</p> </li> \n </ul> \n <p>如果有 Log4j 版本升级，则需要重复上述步骤一次。</p> \n <h3 id=\"Maven-的方式\"><a href=\"#Maven-的方式\" class=\"headerlink\" title=\"Maven 的方式\"></a>Maven 的方式</h3>\n <ul> \n  <li>你需要知道 log4j 的 Maven 坐标，例如：</li> \n </ul> \n <pre><code>&lt;groupId&gt;log4j&lt;/groupId&gt;\n&lt;artifactId&gt;log4j&lt;/artifactId&gt;\n&lt;version&gt;1.2.17&lt;/version&gt;\n</code></pre>\n <ul> \n  <li>它会自动下载 log4j 的 1.2.17 版本库</li> \n  <li>声明 Maven 的坐标转换成 <code>pom.xml</code> 文件</li> \n </ul> \n <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n <ul> \n  <li><p>当 Maven 编译或构建，log4j 的 jar 会自动下载，并把它放到 Maven 本地存储库</p> </li> \n  <li><p>所有由 Maven 管理</p> </li> \n </ul> \n <h3 id=\"解释说明\"><a href=\"#解释说明\" class=\"headerlink\" title=\"解释说明\"></a>解释说明</h3>\n <p>看看有什么不同？那么到底在 Maven 发生了什么？当建立一个 Maven 的项目，pom.xml 文件将被解析，如果看到 log4j 的 Maven 坐标，然后 Maven 按此顺序搜索 log4j 库：</p> \n <ul> \n  <li>在 Maven 的本地仓库搜索 log4j </li> \n  <li>在 Maven 中央存储库搜索 log4j</li> \n  <li>在 Maven 远程仓库搜索 log4j(如果在 pom.xml 中定义)</li> \n </ul> \n <p>Maven 依赖库管理是一个非常好的工具，为您节省了大量的工作</p> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(19,3,'第一个 Maven 应用程序',1,'www.funtl.com/assets/Lusifer1528025821.png',1,'<div class=\"col-sm-12\"> \n <p>下面我们来学习如何使用 Maven 创建一个 Java Web 应用程序</p> \n <h4 id=\"创建-Maven-项目\"><a href=\"#创建-Maven-项目\" class=\"headerlink\" title=\"创建 Maven 项目\"></a>创建 Maven 项目</h4>\n <p>选择 <code>File</code> -&gt; <code>New</code> -&gt; <code>Project...</code></p> \n <p><img src=\"/assets/Lusifer1528025821.png\" alt=\"\"></p> \n <p>选择 <code>Maven</code> 项目</p> \n <p><img src=\"/assets/Lusifer1528025904.png\" alt=\"\"></p> \n <p>填写项目信息</p> \n <p><img src=\"/assets/Lusifer1528025957.png\" alt=\"\"></p> \n <p>选择工作空间</p> \n <p><img src=\"/assets/Lusifer1528026009.png\" alt=\"\"></p> \n <h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4>\n <p>Java Web 的 Maven 基本结构如下：</p> \n <pre><code>├─src\n│  ├─main\n│  │  ├─java\n│  │  ├─resources\n│  │  └─webapp\n│  │      └─WEB-INF\n│  └─test\n│      └─java\n</code></pre>\n <p>结构说明：</p> \n <ul> \n  <li><code>src</code>：源码目录\n   <ul> \n    <li><code>src/main/java</code>：Java 源码目录</li> \n    <li><code>src/main/resources</code>：资源文件目录</li> \n    <li><code>src/main/webapp</code>：Web 相关目录</li> \n    <li><code>src/test</code>：单元测试</li> \n   </ul> </li> \n </ul> \n <h4 id=\"IDEA-Maven-项目管理\"><a href=\"#IDEA-Maven-项目管理\" class=\"headerlink\" title=\"IDEA Maven 项目管理\"></a>IDEA Maven 项目管理</h4>\n <p>在 IDEA 界面的右侧 <code>Maven Projects</code> 选项，可以管理 Maven 项目的整个生命周期、插件、依赖等</p> \n <p><img src=\"/assets/Lusifer1528027638.png\" alt=\"\"></p> \n <h3 id=\"完善-Java-Web-程序\"><a href=\"#完善-Java-Web-程序\" class=\"headerlink\" title=\"完善 Java Web 程序\"></a>完善 Java Web 程序</h3>\n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>修改 <code>pom.xml</code> 配置，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;hello-maven&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n <p>配置说明：</p> \n <ul> \n  <li><code>packaging</code>：打包方式，这里是 <code>war</code> 包，表示为 Java Web 应用程序</li> \n  <li><code>dependencies</code>：项目依赖配置，整个项目生命周期中所需的依赖都在这里配置</li> \n </ul> \n <h4 id=\"创建测试用-Servlet\"><a href=\"#创建测试用-Servlet\" class=\"headerlink\" title=\"创建测试用 Servlet\"></a>创建测试用 Servlet</h4>\n <p>创建一个 <code>Servlet</code> 用于测试请求</p> \n <pre><code>package com.funtl.hello.maven.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class HelloServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.getRequestDispatcher(\"/index.jsp\").forward(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n</code></pre>\n <h4 id=\"创建测试用-JSP\"><a href=\"#创建测试用-JSP\" class=\"headerlink\" title=\"创建测试用 JSP\"></a>创建测试用 JSP</h4>\n <p>创建一个 <code>JSP</code> 页面，用于测试请求</p> \n <pre><code>&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    Hello Maven\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n <h4 id=\"创建-Log4J-的配置文件\"><a href=\"#创建-Log4J-的配置文件\" class=\"headerlink\" title=\"创建 Log4J 的配置文件\"></a>创建 Log4J 的配置文件</h4>\n <p>在 <code>src/main/resources</code> 目录下创建 <code>log4j.properties</code> 配置文件，内容如下：</p> \n <pre><code>log4j.rootLogger=INFO, console, file\n\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n\n\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.File=logs/log.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A3.MaxFileSize=1024KB\nlog4j.appender.A3.MaxBackupIndex=10\nlog4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre>\n <h4 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h4>\n <p><code>web.xml</code> 配置文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\"&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.funtl.hello.maven.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/servlet/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre>\n <h4 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h4>\n <p>按照之前章节 <code>第一个 IDEA 应用程序</code> 配置完 <code>Tomcat</code> 后直接运行，打开浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 显示如下：</p> \n <pre><code>Hello Maven\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(20,3,'Maven POM',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>POM 代表项目对象模型。它是 Maven 中工作的基本单位，这是一个 XML 文件。它始终保存在该项目基本目录中的 pom.xml 文件。</p> \n <p>POM 包含的项目是使用 Maven 来构建的，它用来包含各种配置信息。</p> \n <p>POM 也包含了目标和插件。在执行任务或目标时，Maven 会使用当前目录中的 POM。它读取POM得到所需要的配置信息，然后执行目标。部分的配置可以在 POM 使用如下：</p> \n <ul> \n  <li>project dependencies</li> \n  <li>plugins</li> \n  <li>goals</li> \n  <li>build profiles</li> \n  <li>project version</li> \n  <li>developers</li> \n  <li>mailing list</li> \n </ul> \n <p>创建一个POM之前，应该要先决定项目组(groupId)，它的名字(artifactId)和版本，因为这些属性在项目仓库是唯一标识的。</p> \n <h3 id=\"POM-的例子\"><a href=\"#POM-的例子\" class=\"headerlink\" title=\"POM 的例子\"></a>POM 的例子</h3>\n <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n   http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n   &lt;groupId&gt;com.lusifer&lt;/groupId&gt;\n   &lt;artifactId&gt;project&lt;/artifactId&gt;\n   &lt;version&gt;1.0&lt;/version&gt;\n&lt;project&gt;\n</code></pre>\n <p>要注意的是，每个项目只有一个 POM 文件</p> \n <ul> \n  <li><p>所有的 POM 文件要项目元素必须有三个必填字段: groupId，artifactId，version</p> </li> \n  <li><p>在库中的项目符号是：<code>groupId:artifactId:version</code></p> </li> \n  <li><p><code>pom.xml</code> 的根元素是 project，它有三个主要的子节点。</p> </li> \n </ul> \n <table> \n  <thead> \n   <tr> \n    <th>节点</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>groupId</td> \n    <td>这是项目组的编号，这在组织或项目中通常是独一无二的。 例如，一家银行集团 <code>com.company.bank</code> 拥有所有银行相关项目。</td> \n   </tr> \n   <tr> \n    <td>artifactId</td> \n    <td>这是项目的 ID。这通常是项目的名称。 例如，<code>consumer-banking</code>。 除了 groupId 之外，artifactId 还定义了 artifact 在存储库中的位置。</td> \n   </tr> \n   <tr> \n    <td>version</td> \n    <td>这是项目的版本。与 groupId 一起使用，artifact 在存储库中用于将版本彼此分离。 例如：<code>com.company.bank:consumer-banking:1.0</code>，<code>com.company.bank:consumer-banking:1.1</code></td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(21,3,'Maven 快照',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>大型应用软件一般由多个模块组成，一般它是多个团队开发同一个应用程序的不同模块，这是比较常见的场景。例如，一个团队正在对应用程序的应用程序，用户界面项目(<code>app-ui.jar:1.0</code>) 的前端进行开发，他们使用的是数据服务工程 (<code>data-service.jar:1.0</code>)。</p> \n <p>现在，它可能会有这样的情况发生，工作在数据服务团队开发人员快速地开发 bug 修复或增强功能，他们几乎每隔一天就要释放出库到远程仓库。</p> \n <p>现在，如果数据服务团队上传新版本后，会出现下面的问题：</p> \n <ul> \n  <li>数据服务团队应该发布更新时每次都告诉应用程序 UI 团队，他们已经发布更新了代码。</li> \n  <li>UI 团队需要经常更新自己 <code>pom.xml</code> 以获得更新应用程序的版本。</li> \n </ul> \n <p>为了处理这类情况，引入快照的概念，并发挥作用。</p> \n <h3 id=\"什么是快照？\"><a href=\"#什么是快照？\" class=\"headerlink\" title=\"什么是快照？\"></a>什么是快照？</h3>\n <p>快照（SNAPSHOT）是一个特殊版本，指出目前开发拷贝。不同于常规版本，Maven 每生成一个远程存储库都会检查新的快照版本。</p> \n <p>现在，数据服务团队将在每次发布代码后更新快照存储库为：<code>data-service:1.0-SNAPSHOT</code> 替换旧的 SNAPSHOT jar。</p> \n <h3 id=\"快照与版本\"><a href=\"#快照与版本\" class=\"headerlink\" title=\"快照与版本\"></a>快照与版本</h3>\n <p>在使用版本时，如果 Maven 下载所提到的版本为 <code>data-service:1.0</code>，那么它永远不会尝试在库中下载已经更新的版本 1.0。要下载更新的代码，data-service 的版本必须要升级到 1.1。</p> \n <p>在使用快照（SNAPSHOT）时，Maven 会在每次应用程序 UI 团队建立自己的项目时自动获取最新的快照（<code>data-service:1.0-SNAPSHOT</code>）。</p> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(22,3,'什么是三层架构',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是系统架构\"><a href=\"#什么是系统架构\" class=\"headerlink\" title=\"什么是系统架构\"></a>什么是系统架构</h3>\n <p>所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。</p> \n <h3 id=\"什么是三层架构\"><a href=\"#什么是三层架构\" class=\"headerlink\" title=\"什么是三层架构\"></a>什么是三层架构</h3>\n <p>三层架构是指：视图层 View、服务层 Service，与持久层 DAO。它们分别完成不同的功能。</p> \n <ul> \n  <li><p>View 层：用于接收用户提交请求的代码</p> </li> \n  <li><p>Service 层：系统的业务逻辑主要在这里完成</p> </li> \n  <li><p>DAO 层：直接操作数据库的代码</p> </li> \n </ul> \n <p>为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。</p> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090001.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(23,3,'什么是 MVC 模式',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MVC，即 Model 模型、View 视图，及 Controller 控制器。</p> \n <ul> \n  <li><p>View：视图，为用户提供使用界面，与用户直接进行交互。</p> </li> \n  <li><p>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、User 等。而业务处理 Bean 则是指 Service 或 Dao 对象， 专门用于处理用户提交请求的。</p> </li> \n  <li><p>Controller：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。</p> </li> \n </ul> \n <h3 id=\"MVC-架构程序的工作流程\"><a href=\"#MVC-架构程序的工作流程\" class=\"headerlink\" title=\"MVC 架构程序的工作流程\"></a>MVC 架构程序的工作流程</h3>\n <ul> \n  <li><p>用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等</p> </li> \n  <li><p>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理</p> </li> \n  <li><p>Model 处理后，将处理结果再交给 Controller</p> </li> \n  <li><p>Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。</p> </li> \n </ul> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090002.png\">\n  <br>\n </div> \n <h3 id=\"三层架构-MVC-示意图\"><a href=\"#三层架构-MVC-示意图\" class=\"headerlink\" title=\"三层架构 + MVC 示意图\"></a>三层架构 + MVC 示意图</h3>\n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090003.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-19 15:31:15','2018-12-19 15:31:15'),
(24,3,'Bootstrap 网格系统',1,'www.funtl.com/assets/Lusifer1528226157.png',1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。</p> \n <h3 id=\"什么是网格（Grid）？\"><a href=\"#什么是网格（Grid）？\" class=\"headerlink\" title=\"什么是网格（Grid）？\"></a>什么是网格（Grid）？</h3>\n <blockquote> \n  <p>在平面设计中，网格是一种由一系列用于组织内容的相交的直线（垂直的、水平的）组成的结构（通常是二维的）。它广泛应用于打印设计中的设计布局和内容结构。在网页设计中，它是一种用于快速创建一致的布局和有效地使用 HTML 和 CSS 的方法。</p> \n </blockquote> \n <p>简单地说，网页设计中的网格用于组织内容，让网站易于浏览，并降低用户端的负载。</p> \n <h3 id=\"什么是-Bootstrap-网格系统（Grid-System）？\"><a href=\"#什么是-Bootstrap-网格系统（Grid-System）？\" class=\"headerlink\" title=\"什么是 Bootstrap 网格系统（Grid System）？\"></a>什么是 Bootstrap 网格系统（Grid System）？</h3>\n <p>Bootstrap 官方文档中有关网格系统的描述：</p> \n <blockquote> \n  <p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。</p> \n </blockquote> \n <p>让我们来理解一下上面的语句。Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p> \n <h4 id=\"移动设备优先策略\"><a href=\"#移动设备优先策略\" class=\"headerlink\" title=\"移动设备优先策略\"></a>移动设备优先策略</h4>\n <ul> \n  <li><p>内容</p> \n   <ul> \n    <li><p>决定什么是最重要的</p> </li> \n    <li><p>布局</p> </li> \n   </ul> </li> \n  <li><p>优先设计更小的宽度</p> \n   <ul> \n    <li><p>基础的 CSS 是移动设备优先，<strong>媒体查询</strong> 是针对于平板电脑、台式电脑</p> </li> \n    <li><p>渐进增强</p> </li> \n   </ul> </li> \n  <li><p>随着屏幕大小的增加而添加元素</p> </li> \n </ul> \n <p>响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。</p> \n <p><img src=\"/assets/Lusifer1528226157.png\" alt=\"\"></p> \n <h3 id=\"Bootstrap-网格系统（Grid-System）的工作原理\"><a href=\"#Bootstrap-网格系统（Grid-System）的工作原理\" class=\"headerlink\" title=\"Bootstrap 网格系统（Grid System）的工作原理\"></a>Bootstrap 网格系统（Grid System）的工作原理</h3>\n <p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p> \n <ul> \n  <li><p>行必须放置在 <code>.container</code> class 内，以便获得适当的对齐（alignment）和内边距（padding）</p> </li> \n  <li><p>使用行来创建列的水平组</p> </li> \n  <li><p>内容应该放置在列内，且唯有列可以是行的直接子元素</p> </li> \n  <li><p>预定义的网格类，比如 <code>.row</code> 和 <code>.col-xs-4</code>，可用于快速创建网格布局。LESS 混合类可用于更多语义布局</p> </li> \n  <li><p>列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 <code>.rows</code> 上的外边距（margin）取负，表示第一列和最后一列的行偏移</p> </li> \n  <li><p>网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 <code>.col-xs-4</code></p> </li> \n </ul> \n <h3 id=\"网格选项\"><a href=\"#网格选项\" class=\"headerlink\" title=\"网格选项\"></a>网格选项</h3>\n <p>下表总结了 Bootstrap 网格系统如何跨多个设备工作：</p> \n <table> \n  <thead> \n   <tr> \n    <th>说明</th> \n    <th>超小设备手机（&lt; 768px）</th> \n    <th>小型设备平板电脑（≥ 768px）</th> \n    <th>中型设备台式电脑（≥ 992px）</th> \n    <th>大型设备台式电脑（≥ 1200px）</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>网格行为</td> \n    <td>一直是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n   </tr> \n   <tr> \n    <td>最大容器宽度</td> \n    <td>None (auto)</td> \n    <td>750px</td> \n    <td>970px</td> \n    <td>1170px</td> \n   </tr> \n   <tr> \n    <td>Class 前缀</td> \n    <td><code>.col-xs-</code></td> \n    <td><code>.col-sm-</code></td> \n    <td><code>.col-md-</code></td> \n    <td><code>.col-lg-</code></td> \n   </tr> \n   <tr> \n    <td>列数量和</td> \n    <td>12</td> \n    <td>12</td> \n    <td>12</td> \n    <td>12</td> \n   </tr> \n   <tr> \n    <td>最大列宽</td> \n    <td>Auto</td> \n    <td>60px</td> \n    <td>78px</td> \n    <td>95px</td> \n   </tr> \n   <tr> \n    <td>间隙宽度</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n   </tr> \n   <tr> \n    <td>可嵌套</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n   <tr> \n    <td>偏移量</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n   <tr> \n    <td>列排序</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(25,3,'Bootstrap 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。它是一个 CSS/HTML 框架。Bootstrap 提供了优雅的 HTML 和 CSS 规范。Bootstrap 一经推出后颇受欢迎，一直是 GitHub 上的热门开源项目。</p> \n <h3 id=\"为什么使用-Bootstrap？\"><a href=\"#为什么使用-Bootstrap？\" class=\"headerlink\" title=\"为什么使用 Bootstrap？\"></a>为什么使用 Bootstrap？</h3>\n <ul> \n  <li><p>移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。</p> </li> \n  <li><p>浏览器支持：所有的主流浏览器都支持 Bootstrap。</p> </li> \n  <li><p>容易上手：只要您具备 HTML 和 CSS 的基础知识，您就可以开始学习 Bootstrap。</p> </li> \n  <li><p>响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。</p> </li> \n  <li><p>它为开发人员创建接口提供了一个简洁统一的解决方案。</p> </li> \n  <li><p>它包含了功能强大的内置组件，易于定制。</p> </li> \n  <li><p>它还提供了基于 Web 的定制。</p> </li> \n  <li><p>它是开源的。</p> </li> \n </ul> \n <h3 id=\"Bootstrap-包的内容\"><a href=\"#Bootstrap-包的内容\" class=\"headerlink\" title=\"Bootstrap 包的内容\"></a>Bootstrap 包的内容</h3>\n <ul> \n  <li><p>基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。</p> </li> \n  <li><p>CSS：Bootstrap 自带以下特性，全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。</p> </li> \n  <li><p>组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。</p> </li> \n  <li><p>JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。</p> </li> \n  <li><p>定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(26,3,'Bootstrap 表格',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 提供了一个清晰的创建表格的布局。下表列出了 Bootstrap 支持的一些表格元素：</p> \n <table> \n  <thead> \n   <tr> \n    <th>标签</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>&lt;table&gt;</code></td> \n    <td>为表格添加基础样式</td> \n   </tr> \n   <tr> \n    <td><code>&lt;thead&gt;</code></td> \n    <td>表格标题行的容器元素（<code>&lt;tr&gt;</code>），用来标识表格列</td> \n   </tr> \n   <tr> \n    <td><code>&lt;tbody&gt;</code></td> \n    <td>表格主体中的表格行的容器元素（<code>&lt;tr&gt;</code>）</td> \n   </tr> \n   <tr> \n    <td><code>&lt;tr&gt;</code></td> \n    <td>一组出现在单行上的表格单元格的容器元素（<code>&lt;td&gt;</code> 或 <code>&lt;th&gt;</code>）</td> \n   </tr> \n   <tr> \n    <td><code>&lt;td&gt;</code></td> \n    <td>默认的表格单元格</td> \n   </tr> \n   <tr> \n    <td><code>&lt;th&gt;</code></td> \n    <td>特殊的表格单元格，用来标识列或行（取决于范围和位置）。必须在 <code>&lt;thead&gt;</code> 内使用</td> \n   </tr> \n   <tr> \n    <td><code>&lt;caption&gt;</code></td> \n    <td>关于表格存储内容的描述或总结</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"表格类\"><a href=\"#表格类\" class=\"headerlink\" title=\"表格类\"></a>表格类</h4>\n <p>下表样式可用于表格中：</p> \n <table> \n  <thead> \n   <tr> \n    <th>类</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>.table</code></td> \n    <td>为任意 <code>&lt;table&gt;</code> 添加基本样式 (只有横向分隔线)</td> \n   </tr> \n   <tr> \n    <td><code>.table-striped</code></td> \n    <td>在 <code>&lt;tbody&gt;</code> 内添加斑马线形式的条纹 ( IE8 不支持)</td> \n   </tr> \n   <tr> \n    <td><code>.table-bordered</code></td> \n    <td>为所有表格的单元格添加边框</td> \n   </tr> \n   <tr> \n    <td><code>.table-hover</code></td> \n    <td>在 <code>&lt;tbody&gt;</code> 内的任一行启用鼠标悬停状态</td> \n   </tr> \n   <tr> \n    <td><code>.table-condensed</code></td> \n    <td>让表格更加紧凑</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"lt-tr-gt-lt-th-gt-和-lt-td-gt-类\"><a href=\"#lt-tr-gt-lt-th-gt-和-lt-td-gt-类\" class=\"headerlink\" title=\"<tr>, <th> 和 <td> 类\"></a><code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code> 和 <code>&lt;td&gt;</code> 类</h4>\n <p>下表的类可用于表格的行或者单元格：</p> \n <table> \n  <thead> \n   <tr> \n    <th>类</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>.active</code></td> \n    <td>将悬停的颜色应用在行或者单元格上</td> \n   </tr> \n   <tr> \n    <td><code>.success</code></td> \n    <td>表示成功的操作</td> \n   </tr> \n   <tr> \n    <td><code>.info</code></td> \n    <td>表示信息变化的操作</td> \n   </tr> \n   <tr> \n    <td><code>.warning</code></td> \n    <td>表示一个警告的操作</td> \n   </tr> \n   <tr> \n    <td><code>.danger</code></td> \n    <td>表示一个危险的操作</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"基本的表格\"><a href=\"#基本的表格\" class=\"headerlink\" title=\"基本的表格\"></a>基本的表格</h4>\n <p>如果您想要一个只带有内边距（padding）和水平分割的基本表，请添加 class <code>.table</code>，如下面实例所示：</p> \n <pre><code>&lt;table class=\"table\"&gt;\n  &lt;caption&gt;基本的表格布局&lt;/caption&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;名称&lt;/th&gt;\n      &lt;th&gt;城市&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Tanmay&lt;/td&gt;\n      &lt;td&gt;Bangalore&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Sachin&lt;/td&gt;\n      &lt;td&gt;Mumbai&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(27,3,'Spring 整合 Web',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"容器初始化\"><a href=\"#容器初始化\" class=\"headerlink\" title=\"容器初始化\"></a>容器初始化</h3>\n <p>启动容器时需要自动装载 <code>ApplicationContext</code>，Spring 提供的 <code>ContextLoaderListener</code> 就是为了自动装配 <code>ApplicationContext</code> 的配置信息</p> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>需要在 <code>pom.xml</code> 增加 <code>org.springframework:spring-web</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n    &lt;version&gt;3.1.0&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h4>\n <p><code>web.xml</code> 配置如下</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\"&gt;\n\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:spring-context*.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n&lt;/web-app&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(28,3,'Spring MVC 简介',1,'www.funtl.com/assets/20151003165041682.jpg',1,'<div class=\"col-sm-12\"> \n <p>Spring MVC 也叫 Spring Web MVC ，属于展示层框架。SpringMVC 是 Spring 框架的一部分。</p> \n <p>Spring Web MVC 框架提供了 MVC (模型 - 视图 - 控制器) 架构和用于开发灵活和松散耦合的 Web 应用程序的组件。 MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和 UI 逻辑)分离，同时提供这些元素之间的松散耦合。</p> \n <ul> \n  <li><p>模型 (Model)：封装了应用程序数据，通常它们将由 POJO 类组成。</p> </li> \n  <li><p>视图 (View)：负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。</p> </li> \n  <li><p>控制器 (Controller)：负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</p> </li> \n </ul> \n <h4 id=\"DispatcherServlet-组件类\"><a href=\"#DispatcherServlet-组件类\" class=\"headerlink\" title=\"DispatcherServlet 组件类\"></a>DispatcherServlet 组件类</h4>\n <p>Spring Web MVC 框架是围绕 DispatcherServlet 设计的，它处理所有的 HTTP 请求和响应。 Spring Web MVC DispatcherServlet 的请求处理工作流如下图所示：</p> \n <p><img src=\"/assets/20151003165041682.jpg\" alt=\"\"></p> \n <p>以下是对应于到 DispatcherServlet 的传入 HTTP 请求的事件顺序：</p> \n <ul> \n  <li><p>在接收到 HTTP 请求后，DispatcherServlet 会查询 HandlerMapping 以调用相应的 Controller。</p> </li> \n  <li><p>Controller 接受请求并根据使用的 GET 或 POST 方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给 DispatcherServlet。</p> </li> \n  <li><p>DispatcherServlet 将从 ViewResolver 获取请求的定义视图。</p> </li> \n  <li><p>当视图完成，DispatcherServlet 将模型数据传递到最终的视图，并在浏览器上呈现。</p> </li> \n </ul> \n <p>所有上述组件，即: HandlerMapping，Controller 和 ViewResolver 是 WebApplicationContext 的一部分，它是普通 ApplicationContext 的扩展，带有 Web 应用程序所需的一些额外功能。</p> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(29,3,'浏览器端存储技术简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3>\n <p>Cookie 是指存储在用户本地终端上的数据，同时它是与具体的 Web 页面或者站点相关的。Cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输，也就是说 HTTP 请求发送时，会把保存在该请求域名下的所有 Cookie 值发送给 Web 服务器，因此服务器端脚本是可以读、写存储在客户端的 Cookie 的操作。</p> \n <h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3>\n <p>在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，解决了 Cookie 存储空间不足的问题(Cookie 中每条 Cookie 的存储空间为 4k)，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同。</p> \n <h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3>\n <p>SessionStorage 与 LocalStorage 的唯一一点区别就是 LocalStorage 属于永久性存储，而 SessionStorage 属于当会话结束的时候，SessionStorage 中的键值对就会被清空。</p> \n <h3 id=\"UserData、GlobalStorage、Google-Gear\"><a href=\"#UserData、GlobalStorage、Google-Gear\" class=\"headerlink\" title=\"UserData、GlobalStorage、Google Gear\"></a>UserData、GlobalStorage、Google Gear</h3>\n <p>这三种的使用都有一定的局限性，例如 </p> \n <ul> \n  <li><p>userData 是 IE 浏览器专属，它的容量可以达到 640K，这种方案可靠，不需要安装额外插件，只不过它仅在IE下有效</p> </li> \n  <li><p>globalStorage 适用于 Firefox 2+ 的浏览器，类似于 IE 的 userData</p> </li> \n  <li><p>google gear 是谷歌开发出的一种本地存储技术，需要安装 Gear 组件</p> </li> \n </ul> \n <h3 id=\"Flash-ShareObject（Flash-Cookie）\"><a href=\"#Flash-ShareObject（Flash-Cookie）\" class=\"headerlink\" title=\"Flash ShareObject（Flash Cookie）\"></a>Flash ShareObject（Flash Cookie）</h3>\n <p>这种方式能能解决上面提到的 Cookie 存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个 Flash，当浏览器没有安装 Flash 控件时就不能用了。所幸的是，没有安装 Flash 的用户极少。</p> \n <h3 id=\"附：CookieUtils\"><a href=\"#附：CookieUtils\" class=\"headerlink\" title=\"附：CookieUtils\"></a>附：CookieUtils</h3>\n <pre><code>package com.funtl.leeshop.commons.utils;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\n/**\n * Cookie 工具类\n * &lt;p&gt;Title: CookieUtils&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2017/12/10 22:00\n */\npublic final class CookieUtils {\n\n    /**\n     * 得到Cookie的值, 不编码\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName) {\n        return getCookieValue(request, cookieName, false);\n    }\n\n    /**\n     * 得到Cookie的值,\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {\n        Cookie[] cookieList = request.getCookies();\n        if (cookieList == null || cookieName == null) {\n            return null;\n        }\n        String retValue = null;\n        try {\n            for (int i = 0; i &lt; cookieList.length; i++) {\n                if (cookieList[i].getName().equals(cookieName)) {\n                    if (isDecoder) {\n                        retValue = URLDecoder.decode(cookieList[i].getValue(), \"UTF-8\");\n                    } else {\n                        retValue = cookieList[i].getValue();\n                    }\n                    break;\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return retValue;\n    }\n\n    /**\n     * 得到Cookie的值,\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) {\n        Cookie[] cookieList = request.getCookies();\n        if (cookieList == null || cookieName == null) {\n            return null;\n        }\n        String retValue = null;\n        try {\n            for (int i = 0; i &lt; cookieList.length; i++) {\n                if (cookieList[i].getName().equals(cookieName)) {\n                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);\n                    break;\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return retValue;\n    }\n\n    /**\n     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue) {\n        setCookie(request, response, cookieName, cookieValue, -1);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效,但不编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage) {\n        setCookie(request, response, cookieName, cookieValue, cookieMaxage, false);\n    }\n\n    /**\n     * 设置Cookie的值 不设置生效时间,但编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, boolean isEncode) {\n        setCookie(request, response, cookieName, cookieValue, -1, isEncode);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效, 编码参数\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage, boolean isEncode) {\n        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage, String encodeString) {\n        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);\n    }\n\n    /**\n     * 删除Cookie带cookie域名\n     */\n    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response,\n                                    String cookieName) {\n        doSetCookie(request, response, cookieName, \"\", -1, false);\n    }\n\n    /**\n     * 设置Cookie的值，并使其在指定时间内生效\n     *\n     * @param cookieMaxage cookie生效的最大秒数\n     */\n    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,\n                                          String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {\n        try {\n            if (cookieValue == null) {\n                cookieValue = \"\";\n            } else if (isEncode) {\n                cookieValue = URLEncoder.encode(cookieValue, \"utf-8\");\n            }\n            Cookie cookie = new Cookie(cookieName, cookieValue);\n            if (cookieMaxage &gt; 0)\n                cookie.setMaxAge(cookieMaxage);\n            if (null != request) {// 设置域名的cookie\n                String domainName = getDomainName(request);\n//                System.out.println(domainName);\n                if (!\"localhost\".equals(domainName)) {\n                    cookie.setDomain(domainName);\n                }\n            }\n            cookie.setPath(\"/\");\n            response.addCookie(cookie);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 设置Cookie的值，并使其在指定时间内生效\n     *\n     * @param cookieMaxage cookie生效的最大秒数\n     */\n    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,\n                                          String cookieName, String cookieValue, int cookieMaxage, String encodeString) {\n        try {\n            if (cookieValue == null) {\n                cookieValue = \"\";\n            } else {\n                cookieValue = URLEncoder.encode(cookieValue, encodeString);\n            }\n            Cookie cookie = new Cookie(cookieName, cookieValue);\n            if (cookieMaxage &gt; 0)\n                cookie.setMaxAge(cookieMaxage);\n            if (null != request) {// 设置域名的cookie\n                String domainName = getDomainName(request);\n//                System.out.println(domainName);\n                if (!\"localhost\".equals(domainName)) {\n                    cookie.setDomain(domainName);\n                }\n            }\n            cookie.setPath(\"/\");\n            response.addCookie(cookie);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 得到cookie的域名\n     */\n    private static final String getDomainName(HttpServletRequest request) {\n        String domainName = null;\n\n        String serverName = request.getRequestURL().toString();\n        if (serverName == null || serverName.equals(\"\")) {\n            domainName = \"\";\n        } else {\n            serverName = serverName.toLowerCase();\n            serverName = serverName.substring(7);\n            final int end = serverName.indexOf(\"/\");\n            serverName = serverName.substring(0, end);\n            final String[] domains = serverName.split(\"\\\\.\");\n            int len = domains.length;\n            if (len &gt; 3) {\n                // www.xxx.com.cn\n                domainName = \".\" + domains[len - 3] + \".\" + domains[len - 2] + \".\" + domains[len - 1];\n            } else if (len &lt;= 3 &amp;&amp; len &gt; 1) {\n                // xxx.com or xxx.cn\n                domainName = \".\" + domains[len - 2] + \".\" + domains[len - 1];\n            } else {\n                domainName = serverName;\n            }\n        }\n\n        if (domainName != null &amp;&amp; domainName.indexOf(\":\") &gt; 0) {\n            String[] ary = domainName.split(\"\\\\:\");\n            domainName = ary[0];\n        }\n        return domainName;\n    }\n\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:16','2018-12-19 15:31:16'),
(30,3,'Spring 整合 Spring MVC',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h3>\n <p>在 <code>pom.xml</code> 配置文件中增加 <code>org.springframework:spring-webmvc</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h3 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h3>\n <h4 id=\"CharacterEncodingFilter\"><a href=\"#CharacterEncodingFilter\" class=\"headerlink\" title=\"CharacterEncodingFilter\"></a>CharacterEncodingFilter</h4>\n <p>配置字符集过滤器，用于解决中文编码问题</p> \n <pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre>\n <h4 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h4>\n <p>配置 Spring 的 Servlet 分发器处理所有 HTTP 的请求和响应</p> \n <pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath*:/spring-mvc*.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n <h3 id=\"配置-Spring-MVC\"><a href=\"#配置-Spring-MVC\" class=\"headerlink\" title=\"配置 Spring MVC\"></a>配置 Spring MVC</h3>\n <p>创建一个名为 <code>spring-mvc.xml</code> 文件来配置 MVC</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;\n\n    &lt;description&gt;Spring MVC Configuration&lt;/description&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:myshop.properties\"/&gt;\n\n    &lt;!-- 使用 Annotation 自动注册 Bean,只扫描 @Controller --&gt;\n    &lt;context:component-scan base-package=\"com.lusifer.myshop\" use-default-filters=\"false\"&gt;\n        &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n    &lt;/context:component-scan&gt;\n\n    &lt;!-- 默认的注解映射的支持 --&gt;\n    &lt;mvc:annotation-driven /&gt;\n\n    &lt;!-- 定义视图文件解析 --&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"${web.view.prefix}\"/&gt;\n        &lt;property name=\"suffix\" value=\"${web.view.suffix}\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 静态资源映射 --&gt;\n    &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" cache-period=\"31536000\"/&gt;\n&lt;/beans&gt;\n</code></pre>\n <p>相关配置说明：</p> \n <ul> \n  <li><p><code>context:property-placeholder</code>：动态加载属性配置文件以变量的方式引用需要的值</p> </li> \n  <li><p><code>context:component-scan</code>：当前配置文件为 MVC 相关，故只需要扫描包含 <code>@Controller</code> 的注解即可，由于 <code>spring-context.xml</code> 配置文件中也配置了包扫描，所以还需要排除 <code>@Controller</code> 的注解扫描。</p> </li> \n  <li><p><code>InternalResourceViewResolver</code>：视图文件解析器的一种，用于配置视图资源的路径和需要解释的视图资源文件类型，这里有两个需要配置的属性 <code>prefix</code>（前缀）以及 <code>suffix</code>（后缀）。</p> \n   <ul> \n    <li><code>prefix</code>：配置视图资源路径，如：<code>/WEB-INF/views/</code></li> \n    <li><code>suffix</code>：配置视图资源类型，如：<code>.jsp</code></li> \n   </ul> </li> \n  <li><p><code>mvc:resources</code>：静态资源映射，主要用于配置静态资源文件存放路径，如：JS、CSS、Image 等</p> </li> \n </ul> \n <h4 id=\"系统相关配置\"><a href=\"#系统相关配置\" class=\"headerlink\" title=\"系统相关配置\"></a>系统相关配置</h4>\n <p>在 <code>spring-mvc.xnl</code> 中，我们配置了 <code>&lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:myshop.properties\"/&gt;</code> 用于动态加载属性配置文件，实际开发中我们会将系统所需的一些配置信息封装到 <code>.properties</code> 配置文件中便于统一的管理。</p> \n <p>创建一个名为 <code>myshop.properties</code> 的配置文件，内容如下：</p> \n <pre><code>#============================#\n#==== Framework settings ====#\n#============================#\n\n# \\u89c6\\u56fe\\u6587\\u4ef6\\u5b58\\u653e\\u8def\\u5f84\nweb.view.prefix=/WEB-INF/views/\nweb.view.suffix=.jsp\n</code></pre>\n <h4 id=\"去掉-Spring-配置的重复扫描\"><a href=\"#去掉-Spring-配置的重复扫描\" class=\"headerlink\" title=\"去掉 Spring 配置的重复扫描\"></a>去掉 Spring 配置的重复扫描</h4>\n <p>由于 <code>spring-mvc.xml</code> 中已经配置了 <code>@Controller</code> 注解的扫描而 <code>spring-context.xml</code> 中配置的是扫描全部注解，故在这里需要将 <code>@Controller</code> 注解的扫描配置排除。</p> \n <p>修改 <code>spring-context.xml</code> 配置：</p> \n <pre><code>&lt;!-- 使用 Annotation 自动注册 Bean，在主容器中不扫描 @Controller 注解，在 SpringMVC 中只扫描 @Controller 注解。--&gt;\n&lt;context:component-scan base-package=\"com.funtl.my.shop\"&gt;\n    &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n&lt;/context:component-scan&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(31,3,'Bootstrap 字体图标',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是字体图标\"><a href=\"#什么是字体图标\" class=\"headerlink\" title=\"什么是字体图标\"></a>什么是字体图标</h3>\n <p>所谓字体图标，就是使用字体（Font）格式的字形做成了图标。</p> \n <h3 id=\"Bootstrap-自带的字体图标\"><a href=\"#Bootstrap-自带的字体图标\" class=\"headerlink\" title=\"Bootstrap 自带的字体图标\"></a>Bootstrap 自带的字体图标</h3>\n <p>Bootstrap 捆绑了 200 多种字体格式的字形，在 fonts 文件夹内可以找到字体图标，它包含了下列这些文件：</p> \n <ul> \n  <li><p>glyphicons-halflings-regular.eot</p> </li> \n  <li><p>glyphicons-halflings-regular.svg</p> </li> \n  <li><p>glyphicons-halflings-regular.ttf</p> </li> \n  <li><p>glyphicons-halflings-regular.woff</p> </li> \n </ul> \n <p>相关的 CSS 规则写在 dist 文件夹内的 css 文件夹内的 <code>bootstrap.css</code> 和 <code>bootstrap-min.css</code> 文件上。</p> \n <h3 id=\"使用字体图标\"><a href=\"#使用字体图标\" class=\"headerlink\" title=\"使用字体图标\"></a>使用字体图标</h3>\n <p>如需使用图标，只需要简单地使用下面的代码即可：</p> \n <pre><code>&lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt;\n</code></pre>\n <h3 id=\"其它字体图标库\"><a href=\"#其它字体图标库\" class=\"headerlink\" title=\"其它字体图标库\"></a>其它字体图标库</h3>\n <ul> \n  <li><p>FontAwesome：<a href=\"http://fontawesome.dashgame.com/\" target=\"_blank\" rel=\"noopener\">http://fontawesome.dashgame.com/</a></p> </li> \n  <li><p>LineAwesome：<a href=\"https://icons8.com/line-awesome\" target=\"_blank\" rel=\"noopener\">https://icons8.com/line-awesome</a></p> </li> \n  <li><p>SocialIcons：<a href=\"http://www.socicon.com/chart.php\" target=\"_blank\" rel=\"noopener\">http://www.socicon.com/chart.php</a></p> </li> \n  <li><p><strong>阿里巴巴矢量图标库</strong>：<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">http://www.iconfont.cn/</a></p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(32,3,'第一个 Controller 控制器',1,NULL,1,'<div class=\"col-sm-12\"> \n <pre><code>package com.funtl.my.shop.web.controller;\n\nimport com.funtl.my.shop.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class LoginController {\n\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(value = {\"\", \"login\"}, method = RequestMethod.GET)\n    public String login() {\n        return \"login\";\n    }\n\n    @RequestMapping(value = \"login\", method = RequestMethod.POST)\n    public String login(@RequestParam(required = true) String email, @RequestParam(required = true) String password) {\n        return \"redirect:/main\";\n    }\n}\n</code></pre>\n <h4 id=\"注解说明\"><a href=\"#注解说明\" class=\"headerlink\" title=\"注解说明\"></a>注解说明</h4>\n <h5 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"@Controller\"></a>@Controller</h5>\n <p>在 Spring MVC 中，控制器 Controller 负责处理由 <code>DispatcherServlet</code> 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。在 Spring MVC 中提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用 <code>@Controller</code> 标记一个类是 Controller ，然后使用 <code>@RequestMapping</code> 和 <code>@RequestParam</code> 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。此外 Controller 不会直接依赖于 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 等 <code>HttpServlet</code> 对象，它们可以通过 Controller 的方法参数灵活的获取到。</p> \n <p><code>@Controller</code> 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了 <code>@RequestMapping</code> 注解。<code>@Controller</code> 只是定义了一个控制器类，而使用 <code>@RequestMapping</code> 注解的方法才是真正处理请求的处理器。</p> \n <h5 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"@RequestMapping\"></a>@RequestMapping</h5>\n <p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。<strong>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</strong>。</p> \n <p>RequestMapping 注解有六个属性：</p> \n <ul> \n  <li><p>value， method</p> \n   <ul> \n    <li>value：指定请求的实际地址，指定的地址可以是 URI Template 模式</li> \n    <li>method：指定请求的method类型， GET、POST、PUT、DELETE 等</li> \n   </ul> </li> \n  <li><p>consumes，produces</p> \n   <ul> \n    <li>consumes：指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html</li> \n    <li>produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回</li> \n   </ul> </li> \n  <li><p>params，headers</p> \n   <ul> \n    <li>params：指定 request 中必须包含某些参数值是，才让该方法处理</li> \n    <li>headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(33,3,'MyBatis 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不用再花费精力去处理诸如注册驱动、创建 Connection、配置 Statement 等繁杂过程。</p> \n <p>Mybatis 通过 xml 或注解的方式将要执行的各种 Statement（Statement、PreparedStatement 等）配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射成 Java 对象并返回。</p> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018061304510001.png\">\n  <br>\n </div> \n <h3 id=\"MyBatis-与-Hibernate\"><a href=\"#MyBatis-与-Hibernate\" class=\"headerlink\" title=\"MyBatis 与 Hibernate\"></a>MyBatis 与 Hibernate</h3>\n <p>Hibernate 框架是提供了全面的数据库封装机制的 <strong>“全自动”</strong> ORM，即实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。</p> \n <p>相对于此，MyBatis 只能算作是 <strong>“半自动”</strong> ORM。其着力点，是在 POJO 类与 SQL 语句之间的映射关系。也就是说，MyBatis 并不会为程序员自动生成 SQL 语句。具体的 SQL 需要程序员自己编写，然后通过 SQL 语句映射文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO。因此，MyBatis 成为了“全自动”ORM 的一种有益补充。</p> \n <h3 id=\"MyBatis-的特点\"><a href=\"#MyBatis-的特点\" class=\"headerlink\" title=\"MyBatis 的特点\"></a>MyBatis 的特点</h3>\n <ul> \n  <li><p>在 XML 文件中配置 SQL 语句，实现了 SQL 语句与代码的分离，给程序的维护带来了很大便利。</p> </li> \n  <li><p>因为需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。</p> </li> \n  <li><p>简单，易于学习，易于使用，上手快。</p> </li> \n </ul> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018061304510002.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(34,3,'Bootstrap 环境安装',1,'www.funtl.com/assets/Lusifer1526581943.png',1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 安装是非常容易的。本章将讲解如何下载并安装 Bootstrap，讨论 Bootstrap 文件结构，并通过一个实例演示它的用法。</p> \n <h3 id=\"下载-Bootstrap\"><a href=\"#下载-Bootstrap\" class=\"headerlink\" title=\"下载 Bootstrap\"></a>下载 Bootstrap</h3>\n <p>您可以从 <a href=\"http://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">http://getbootstrap.com/</a> 上下载 Bootstrap 的最新版本。</p> \n <h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3>\n <h4 id=\"预编译的-Bootstrap\"><a href=\"#预编译的-Bootstrap\" class=\"headerlink\" title=\"预编译的 Bootstrap\"></a>预编译的 Bootstrap</h4>\n <p>当您下载了 Bootstrap 的已编译的版本，解压缩 ZIP 文件，您将看到下面的文件/目录结构：</p> \n <p><img src=\"/assets/Lusifer1526581943.png\" alt=\"\"></p> \n <p>如上图所示，可以看到已编译的 CSS 和 JS（bootstrap.<em>），以及已编译压缩的 CSS 和 JS（bootstrap.min.</em>）。同时也包含了 Glyphicons 的字体，这是一个可选的 Bootstrap 主题。</p> \n <h3 id=\"HTML-模板\"><a href=\"#HTML-模板\" class=\"headerlink\" title=\"HTML 模板\"></a>HTML 模板</h3>\n <p>一个使用了 Bootstrap 的基本的 HTML 模板如下所示：</p> \n <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n   &lt;head&gt;\n      &lt;title&gt;Bootstrap 模板&lt;/title&gt;\n      &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n      &lt;!-- 引入 Bootstrap --&gt;\n      &lt;link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n\n      &lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;\n      &lt;!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 --&gt;\n      &lt;!--[if lt IE 9]&gt;\n         &lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;\n         &lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt;\n      &lt;![endif]--&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n\n      &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;\n      &lt;script src=\"https://code.jquery.com/jquery.js\"&gt;&lt;/script&gt;\n      &lt;!-- 包括所有已编译的插件 --&gt;\n      &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n <p>在这里，您可以看到包含了 jquery.js、bootstrap.min.js 和 bootstrap.min.css 文件，用于让一个常规的 HTML 文件变为使用了 Bootstrap 的模板。</p> \n <h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3>\n <p>现在让我们尝试使用 Bootstrap 输出 “Hello, world!”：</p> \n <pre><code>&lt;h1&gt;Hello, world!&lt;/h1&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(35,3,'Spring MVC 拦截器的使用',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"拦截器简介\"><a href=\"#拦截器简介\" class=\"headerlink\" title=\"拦截器简介\"></a>拦截器简介</h3>\n <p>Spring Web MVC 的处理器拦截器，类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p> \n <h3 id=\"常见应用场景\"><a href=\"#常见应用场景\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h3>\n <ul> \n  <li><p>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算 PV（Page View）等</p> </li> \n  <li><p>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</p> </li> \n  <li><p>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</p> </li> \n  <li><p>通用行为：读取 Cookie 得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取 Locale、Theme 信息等，只要是多个处理器都需要的即可使用拦截器实现</p> </li> \n </ul> \n <h3 id=\"第一个-Spring-MVC-拦截器\"><a href=\"#第一个-Spring-MVC-拦截器\" class=\"headerlink\" title=\"第一个 Spring MVC 拦截器\"></a>第一个 Spring MVC 拦截器</h3>\n <p>Spring MVC 拦截器需要实现 <code>HandlerInterceptor</code> 接口，该接口定义了 3 个方法，分别为 <code>preHandle()</code>、<code>postHandle()</code> 和 <code>afterCompletion()</code>，咱们就是通过重写这 3 个方法来对用户的请求进行拦截处理的。</p> \n <ul> \n  <li><p><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</code>：该方法在请求处理之前进行调用。Spring MVC 中的 Interceptor 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个 Interceptor 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 Interceptor 中的 <code>preHandle</code> 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 Boolean 类型的，当它返回为 <code>false</code> 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 <code>true</code> 时，就会继续调用下一个 Interceptor 的 <code>preHandle</code> 方法，如果已经是最后一个 Interceptor 的时候，就会是调用当前请求的 Controller 中的方法。</p> </li> \n  <li><p><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</code>：通过 <code>preHandle</code> 方法的解释咱们知道这个方法包括后面要说到的 <code>afterCompletion</code> 方法都只能在当前所属的 Interceptor 的 <code>preHandle</code> 方法的返回值为 <code>true</code> 的时候，才能被调用。<code>postHandle</code> 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 <code>DispatcherServlet</code> 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 <code>ModelAndView</code> 对象进行操作。<code>postHandle</code> 方法被调用的方向跟 <code>preHandle</code> 是相反的，也就是说，先声明的 Interceptor 的 <code>postHandle</code> 方法反而会后执行。</p> </li> \n  <li><p><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</code>：也是需要当前对应的 Interceptor 的 <code>preHandle</code> 方法的返回值为 <code>true</code> 时才会执行。因此，该方法将在整个请求结束之后，也就是在 <code>DispatcherServlet</code> 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。</p> </li> \n </ul> \n <h4 id=\"创建登录拦截器\"><a href=\"#创建登录拦截器\" class=\"headerlink\" title=\"创建登录拦截器\"></a>创建登录拦截器</h4>\n <p>我们知道对系统的相关操作是需要登录后才可以使用的，当未登录时是无法直接访问需要登录权限的操作的，为了做到这个效果，我们使用登录拦截器来判断用户是否登录，如果用户已登录则放行让用户继续操作，否则就将其跳转到登录页。</p> \n <p>定义一个名为 <code>LoginInterceptor</code> 的拦截器，代码如下：</p> \n <pre><code>package com.funtl.my.shop.web.interceptor;\n\nimport com.funtl.my.shop.entity.User;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 登录拦截器\n * &lt;p&gt;Title: LoginInterceptor&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/12 5:44\n */\npublic class LoginInterceptor implements HandlerInterceptor {\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n        User user = (User) httpServletRequest.getSession().getAttribute(\"user\");\n\n        // 判断用户是否登录\n        if (user == null) {\n            // 用户未登录，重定向到登录页\n            httpServletResponse.sendRedirect(\"/login\");\n            return false;\n        }\n\n        // 放行\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n        // 如果请求来自登录页\n        if (modelAndView.getViewName().endsWith(\"login\")) {\n            // 则直接重定向到首页不再显示登录页\n            httpServletResponse.sendRedirect(\"/main\");\n        }\n    }\n\n    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n    }\n}\n</code></pre>\n <h4 id=\"在-spring-mvc-xml-中配置拦截器\"><a href=\"#在-spring-mvc-xml-中配置拦截器\" class=\"headerlink\" title=\"在 spring-mvc.xml 中配置拦截器\"></a>在 <code>spring-mvc.xml</code> 中配置拦截器</h4>\n <p>拦截器定义后还需要在 <code>spring-mvc.xml</code> 中配置拦截器，代码如下：</p> \n <pre><code>&lt;!-- 拦截器配置，拦截顺序：先执行后定义的，排在第一位的最后执行。--&gt;\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=\"/**\"/&gt;\n        &lt;mvc:exclude-mapping path=\"/static/**\"/&gt;\n        &lt;mvc:exclude-mapping path=\"/login\"/&gt;\n        &lt;bean class=\"com.funtl.my.shop.web.interceptor.LoginInterceptor\"/&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n <p>相关配置说明：</p> \n <ul> \n  <li><code>mvc:interceptor</code>：定义一个拦截器\n   <ul> \n    <li><code>mvc:mapping</code>：映射路径，需要拦截的请求路径</li> \n    <li><code>mvc:exclude-mapping</code>：需要排除的请求路径，比如登录页本身是不需要拦截的，这里还包括了静态资源路径也是不需要拦截的</li> \n    <li><code>bean class</code>：配置指定的拦截器对象</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:17','2018-12-19 15:31:17'),
(36,3,'Spring 整合 MyBatis',1,NULL,1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>在 <code>pom.xml</code> 文件中增加 MyBatis 相关依赖：</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n    &lt;version&gt;3.2.8&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <p>主要增加了 3 个依赖，分别为 <code>org.mybatis:mybatis</code>、<code>org.mybatis:mybatis-spring</code>、<code>org.springframework:spring-jdbc</code></p> \n <h4 id=\"创建-MyBatis-配置文件\"><a href=\"#创建-MyBatis-配置文件\" class=\"headerlink\" title=\"创建 MyBatis 配置文件\"></a>创建 MyBatis 配置文件</h4>\n <p>创建一个名为 <code>mybatis-config.xml</code> 的配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;\n</code></pre>\n <h4 id=\"Spring-集成-MyBatis\"><a href=\"#Spring-集成-MyBatis\" class=\"headerlink\" title=\"Spring 集成 MyBatis\"></a>Spring 集成 MyBatis</h4>\n <p>创建一个名为 <code>spring-context-mybatis.xml</code> 的 Spring 配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 \',\' 号分割 --&gt;\n        &lt;property name=\"typeAliasesPackage\" value=\"com.funtl.my.shop.domain\"/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=\"mapperLocations\" value=\"classpath:/mapper/**/*.xml\"/&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;property name=\"basePackage\" value=\"com.funtl.my.shop.web.admin.dao\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(37,3,'第一个 MyBatis 对象关系映射',1,NULL,1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>编写完相关代码后，我们可以使用单元测试查看 MyBatis 的执行效果，需要增加单元测试相关依赖，配置如下：</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"导入-SQL\"><a href=\"#导入-SQL\" class=\"headerlink\" title=\"导入 SQL\"></a>导入 SQL</h4>\n <p>群共享中已经为大家准备好了练习用的 SQL，位置： <code>Java 微服务架构相关环境资料-SQL/myshop.zip</code>，有需要的同学可以加群获取</p> \n <h4 id=\"定义实体类\"><a href=\"#定义实体类\" class=\"headerlink\" title=\"定义实体类\"></a>定义实体类</h4>\n <p>以 <code>tb_user</code> 表为例，实体类代码如下：</p> \n <pre><code>package com.funtl.my.shop.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class TbUser implements Serializable {\n    private Long id;\n    private String username;\n    private String password;\n    private String phone;\n    private String email;\n    private Date created;\n    private Date update;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public Date getUpdate() {\n        return update;\n    }\n\n    public void setUpdate(Date update) {\n        this.update = update;\n    }\n}\n</code></pre>\n <h4 id=\"定义数据访问接口\"><a href=\"#定义数据访问接口\" class=\"headerlink\" title=\"定义数据访问接口\"></a>定义数据访问接口</h4>\n <p>注意：Spring 集成 MyBatis 后，不需要手动实现 DAO 层的接口，所有的 SQL 执行语句都写在对应的关系映射配置文件中。</p> \n <pre><code>package com.funtl.my.shop.web.admin.dao;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface TbUserDao {\n\n    /**\n     * 查询全部用户信息\n     * @return\n     */\n    public List&lt;TbUser&gt; selectAll();\n}\n</code></pre>\n <h4 id=\"定义业务逻辑接口\"><a href=\"#定义业务逻辑接口\" class=\"headerlink\" title=\"定义业务逻辑接口\"></a>定义业务逻辑接口</h4>\n <pre><code>package com.funtl.my.shop.web.admin.service;\n\nimport com.funtl.my.shop.domain.TbUser;\n\nimport java.util.List;\n\npublic interface TbUserService {\n\n    /**\n     * 查询全部用户信息\n     * @return\n     */\n    public List&lt;TbUser&gt; selectAll();\n}\n</code></pre>\n <h4 id=\"实现业务逻辑接口\"><a href=\"#实现业务逻辑接口\" class=\"headerlink\" title=\"实现业务逻辑接口\"></a>实现业务逻辑接口</h4>\n <pre><code>package com.funtl.my.shop.web.admin.service.impl;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.dao.TbUserDao;\nimport com.funtl.my.shop.web.admin.service.TbUserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\npublic class TbUserServiceImpl implements TbUserService {\n\n    @Autowired\n    private TbUserDao tbUserDao;\n\n    @Override\n    public List&lt;TbUser&gt; selectAll() {\n        return tbUserDao.selectAll();\n    }\n}\n</code></pre>\n <h4 id=\"定义映射文件\"><a href=\"#定义映射文件\" class=\"headerlink\" title=\"定义映射文件\"></a>定义映射文件</h4>\n <p>映射文件，简称为 Mapper，主要完成 DAO 层中 SQL 语句的映射。映射文件名随意，一般放在 <code>src/resources/mapper</code> 文件夹中。这里映射文件名称定为 <code>TbUserMapper.xml</code>。</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.funtl.my.shop.web.admin.dao.TbUserDao\"&gt;\n    &lt;select id=\"selectAll\" resultType=\"TbUser\"&gt;\n        SELECT\n          a.id,\n          a.username,\n          a.password,\n          a.phone,\n          a.email,\n          a.created,\n          a.updated\n        FROM\n          tb_user AS a\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h4 id=\"创建单元测试\"><a href=\"#创建单元测试\" class=\"headerlink\" title=\"创建单元测试\"></a>创建单元测试</h4>\n <p>所有工作准备就绪，我们就可以测试 MyBatis 是否能够正常执行了。创建一个单元测试类，代码如下：</p> \n <pre><code>package com.funtl.my.shop.web.admin.service.test;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.dao.TbUserDao;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.util.List;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:spring-context.xml\", \"classpath:spring-context-druid.xml\", \"classpath:spring-context-mybatis.xml\"})\npublic class TbUserServiceTest {\n\n    @Autowired\n    private TbUserDao tbUserDao;\n\n    @Test\n    public void testSelectAll() {\n        List&lt;TbUser&gt; tbUsers = tbUserDao.selectAll();\n        for (TbUser tbUser : tbUsers) {\n            System.out.println(tbUser.getUsername());\n        }\n    }\n}\n</code></pre>\n <p>成功执行测试后，控制台输出如下：</p> \n <pre><code>2018-06-13 08:00:40,069 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener]\n2018-06-13 08:00:40,106 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Using TestExecutionListeners: [org.springframework.test.context.web.ServletTestExecutionListener@4b9e13df, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@2b98378d, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@475530b9, org.springframework.test.context.support.DirtiesContextTestExecutionListener@1d057a39, org.springframework.test.context.transaction.TransactionalTestExecutionListener@26be92ad, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener@4c70fda8]2018-06-13 08:00:40,213 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context.xml]\n2018-06-13 08:00:40,513 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-druid.xml]\n2018-06-13 08:00:40,565 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-mybatis.xml]\n2018-06-13 08:00:40,586 INFO [org.springframework.context.support.GenericApplicationContext] - Refreshing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy\n2018-06-13 08:00:41,650 INFO [com.alibaba.druid.pool.DruidDataSource] - {dataSource-1} inited\nzhangsan\nzhangsan1\nzhangsan2\nzhangsan3\nzhangsan5\nlisi\nlisi1\njd_gogogo\ntidy\ntidy1\nniuniu\nniuniu2\nniuniu3\nniuniu4\ntest01\ntest02\n2018-06-13 08:00:42,143 INFO [org.springframework.context.support.GenericApplicationContext] - Closing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy\n2018-06-13 08:00:42,149 INFO [com.alibaba.druid.pool.DruidDataSource] - {dataSource-1} closed\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(38,3,'Maven 模块化开发',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在多人协同开发时，特别是规模较大的项目，为了方便日后的代码维护和管理，我们会将每个开发人员的工作细分到具体的功能和模块上。随着项目的不断扩大，模块也会越来越多，后续会更加难以维护和扩展，为了应对这种情况后期我们还会采用微服务架构的方式进行开发。</p> \n <p>以当前教程为例，我们可以将模块划分为如下形式：</p> \n <ul> \n  <li><p>统一的依赖管理（dependencies）</p> </li> \n  <li><p>通用的工具类（commons）</p> </li> \n  <li><p>领域模型（domain）</p> </li> \n  <li><p>管理后台（admin）</p> </li> \n  <li><p>商城前端（ui）</p> </li> \n  <li><p>接口模块（api）</p> </li> \n </ul> \n <p>整个模块化开发过程主要是在开发思想上稍作了一些转变，只需要按照下面的流程操作即可。</p> \n <h4 id=\"创建根项目（工程）\"><a href=\"#创建根项目（工程）\" class=\"headerlink\" title=\"创建根项目（工程）\"></a>创建根项目（工程）</h4>\n <p>创建一个名为 <code>my-shop</code> 的工程，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;modules&gt;\n\n    &lt;/modules&gt;\n&lt;/project&gt;\n</code></pre>\n <p>该项目称之为 Root 项目，主要作用是管理整个工程的全部模块，当有新模块加入时需要在 <code>modules</code> 元素下配置对应的模块目录</p> \n <h4 id=\"创建统一的依赖管理\"><a href=\"#创建统一的依赖管理\" class=\"headerlink\" title=\"创建统一的依赖管理\"></a>创建统一的依赖管理</h4>\n <p>创建一个名为 <code>my-shop-dependencies</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-dependencies&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;!-- 环境配置 --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n\n        &lt;!-- 统一的依赖管理 --&gt;\n        &lt;commons-lang3.version&gt;3.5&lt;/commons-lang3.version&gt;\n        &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;\n        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n        &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;\n        &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt;\n        &lt;spring.version&gt;4.3.17.RELEASE&lt;/spring.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- Spring Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n                &lt;version&gt;${spring.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n                &lt;version&gt;${spring.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Spring End --&gt;\n\n            &lt;!-- Servlet Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n                &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n                &lt;version&gt;${servlet-api.version}&lt;/version&gt;\n                &lt;scope&gt;provided&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n                &lt;artifactId&gt;jstl&lt;/artifactId&gt;\n                &lt;version&gt;${jstl.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Servlet End --&gt;\n\n            &lt;!-- Log Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;log4j&lt;/groupId&gt;\n                &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n                &lt;version&gt;${log4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Log End --&gt;\n\n            &lt;!-- Commons Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n                &lt;version&gt;${commons-lang3.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Commons End --&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.7.0&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                    &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n\n        &lt;!-- 资源文件配置 --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;**/*.java&lt;/exclude&gt;\n                &lt;/excludes&gt;\n            &lt;/resource&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-dependencies&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建通用的工具类\"><a href=\"#创建通用的工具类\" class=\"headerlink\" title=\"创建通用的工具类\"></a>创建通用的工具类</h4>\n <p>创建一个名为 <code>my-shop-commons</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-commons&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-commons&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建领域模型\"><a href=\"#创建领域模型\" class=\"headerlink\" title=\"创建领域模型\"></a>创建领域模型</h4>\n <p>创建一个名为 <code>my-shop-domain</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-domain&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-domain&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-domain&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建管理后台\"><a href=\"#创建管理后台\" class=\"headerlink\" title=\"创建管理后台\"></a>创建管理后台</h4>\n <p>创建一个名为 <code>my-shop-web-admin</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-admin&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-admin&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-domain&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-admin&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建商城前端\"><a href=\"#创建商城前端\" class=\"headerlink\" title=\"创建商城前端\"></a>创建商城前端</h4>\n <p>创建一个名为 <code>my-shop-web-ui</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-ui&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-ui&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-ui&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建接口模块\"><a href=\"#创建接口模块\" class=\"headerlink\" title=\"创建接口模块\"></a>创建接口模块</h4>\n <p>创建一个名为 <code>my-shop-web-api</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-api&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-api&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-api&lt;/module&gt;</code> 配置</p> \n <h4 id=\"清理、编译、打包\"><a href=\"#清理、编译、打包\" class=\"headerlink\" title=\"清理、编译、打包\"></a>清理、编译、打包</h4>\n <p>至此一个完整的模块化工程创建完毕，此时的 Root 工程 <code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;my-shop-dependencies&lt;/module&gt;\n        &lt;module&gt;my-shop-commons&lt;/module&gt;\n        &lt;module&gt;my-shop-domain&lt;/module&gt;\n        &lt;module&gt;my-shop-web-admin&lt;/module&gt;\n        &lt;module&gt;my-shop-web-ui&lt;/module&gt;\n        &lt;module&gt;my-shop-web-api&lt;/module&gt;\n    &lt;/modules&gt;\n&lt;/project&gt;\n</code></pre>\n <p>我们可以在 Root 工程中使用 Maven 提供的 <code>mvn clean</code> 命令测试一下效果，控制台输出如下：</p> \n <pre><code>[INFO] Scanning for projects...\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] my-shop\n[INFO] my-shop-dependencies\n[INFO] my-shop-commons\n[INFO] my-shop-domain\n[INFO] my-shop-web-admin\n[INFO] my-shop-web-ui\n[INFO] my-shop-web-api\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-dependencies 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-dependencies ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-commons 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-commons ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-commons\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-domain 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-domain ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-domain\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-admin 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-admin ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-web-admin\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-ui 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-ui ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-api 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-api ---\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] my-shop ............................................ SUCCESS [  0.158 s]\n[INFO] my-shop-dependencies ............................... SUCCESS [  0.004 s]\n[INFO] my-shop-commons .................................... SUCCESS [  0.020 s]\n[INFO] my-shop-domain ..................................... SUCCESS [  0.016 s]\n[INFO] my-shop-web-admin .................................. SUCCESS [  0.033 s]\n[INFO] my-shop-web-ui ..................................... SUCCESS [  0.012 s]\n[INFO] my-shop-web-api .................................... SUCCESS [  0.008 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.400 s\n[INFO] Finished at: 2018-06-12T07:47:58+08:00\n[INFO] Final Memory: 8M/241M\n[INFO] ------------------------------------------------------------------------\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(39,3,'Druid 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Druid 是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和 SQL 解析器组成。该项目主要是为了扩展 JDBC 的一些限制，可以让程序员实现一些特殊的需求，比如向密钥服务请求凭证、统计 SQL 信息、SQL 性能收集、SQL 注入检查、SQL 翻译等，程序员可以通过定制来实现自己需要的功能。</p> \n <h3 id=\"各种连接池性能对比测试\"><a href=\"#各种连接池性能对比测试\" class=\"headerlink\" title=\"各种连接池性能对比测试\"></a>各种连接池性能对比测试</h3>\n <p>测试执行申请归还连接 1,000,000（一百万）次总耗时性能对比。</p> \n <h4 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h4>\n <table> \n  <thead> \n   <tr> \n    <th>环境</th> \n    <th>版本</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>OS</td> \n    <td>OS X 10.8.2</td> \n   </tr> \n   <tr> \n    <td>CPU</td> \n    <td>Intel i7 2GHz 4 Core</td> \n   </tr> \n   <tr> \n    <td>JVM</td> \n    <td>Java Version 1.7.0_05</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"基准测试结果\"><a href=\"#基准测试结果\" class=\"headerlink\" title=\"基准测试结果\"></a>基准测试结果</h4>\n <table> \n  <thead> \n   <tr> \n    <th>Jdbc Connection Pool</th> \n    <th>1 thread</th> \n    <th>2 threads</th> \n    <th>5 threads</th> \n    <th>10 threads</th> \n    <th>20 threads</th> \n    <th>50 threads</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>Druid</td> \n    <td>898</td> \n    <td>1,191</td> \n    <td>1,324</td> \n    <td>1,362</td> \n    <td>1,325</td> \n    <td>1,459</td> \n   </tr> \n   <tr> \n    <td>tomcat-jdbc</td> \n    <td>1,269</td> \n    <td>1,378</td> \n    <td>2,029</td> \n    <td>2,103</td> \n    <td>1,879</td> \n    <td>2,025</td> \n   </tr> \n   <tr> \n    <td>DBCP</td> \n    <td>2,324</td> \n    <td>5,055</td> \n    <td>5,446</td> \n    <td>5,471</td> \n    <td>5,524</td> \n    <td>5,415</td> \n   </tr> \n   <tr> \n    <td>BoneCP</td> \n    <td>3,738</td> \n    <td>3,150</td> \n    <td>3,194</td> \n    <td>5,681</td> \n    <td>11,018</td> \n    <td>23,125</td> \n   </tr> \n   <tr> \n    <td>jboss-datasource</td> \n    <td>4,377</td> \n    <td>2,988</td> \n    <td>3,680</td> \n    <td>3,980</td> \n    <td>32,708</td> \n    <td>37,742</td> \n   </tr> \n   <tr> \n    <td>C3P0</td> \n    <td>10,841</td> \n    <td>13,637</td> \n    <td>10,682</td> \n    <td>11,055</td> \n    <td>14,497</td> \n    <td>20,351</td> \n   </tr> \n   <tr> \n    <td>Proxool</td> \n    <td>16,337</td> \n    <td>16,187</td> \n    <td>18,310(Exception)</td> \n    <td>25,945</td> \n    <td>33,706(Exception)</td> \n    <td>39,501 (Exception)</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4>\n <ul> \n  <li><p>Druid 是性能最好的数据库连接池，tomcat-jdbc 和 druid 性能接近。</p> </li> \n  <li><p>proxool 在激烈并发时会抛异常，完全不靠谱。</p> </li> \n  <li><p>c3p0 和 proxool 都相当慢，慢到影响 sql 执行效率的地步。</p> </li> \n  <li><p>bonecp 性能并不优越，采用 LinkedTransferQueue 并没有能够获得性能提升。</p> </li> \n  <li><p>除了 bonecp，其他的在 JDK 7 上跑得比 JDK 6 上快</p> </li> \n  <li><p>jboss-datasource 虽然稳定，但是性能很糟糕</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(40,3,'Spring 整合 Druid',1,'www.funtl.com/assets/Lusifer1528842755.png',1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>在 <code>pom.xml</code> 文件中新增 <code>com.alibaba:druid</code> 和 <code>mysql:mysql-connector-java</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid&lt;/artifactId&gt;\n    &lt;version&gt;1.1.6&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.46&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"配置数据库连接\"><a href=\"#配置数据库连接\" class=\"headerlink\" title=\"配置数据库连接\"></a>配置数据库连接</h4>\n <p>配置数据库连接 <code>jdbc.properties</code> ，配置代码如下：</p> \n <pre><code># JDBC\n# MySQL 8.x: com.mysql.cj.jdbc.Driver\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.connectionURL=jdbc:mysql://192.168.75.134:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\njdbc.username=root\njdbc.password=123456\n\n# JDBC Pool\njdbc.pool.init=1\njdbc.pool.minIdle=3\njdbc.pool.maxActive=20\n\n# JDBC Test\njdbc.testSql=SELECT \'x\' FROM DUAL\n</code></pre>\n <h4 id=\"Spring-集成-Druid\"><a href=\"#Spring-集成-Druid\" class=\"headerlink\" title=\"Spring 集成 Druid\"></a>Spring 集成 Druid</h4>\n <p>创建一个名为 <code>spring-context-druid.xml</code> 的 Spring 配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;\n        &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;\n        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClass}\"/&gt;\n\n        &lt;!-- 基本属性 url、user、password --&gt;\n        &lt;property name=\"url\" value=\"${jdbc.connectionURL}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n\n        &lt;!-- 配置初始化大小、最小、最大 --&gt;\n        &lt;property name=\"initialSize\" value=\"${jdbc.pool.init}\"/&gt;\n        &lt;property name=\"minIdle\" value=\"${jdbc.pool.minIdle}\"/&gt;\n        &lt;property name=\"maxActive\" value=\"${jdbc.pool.maxActive}\"/&gt;\n\n        &lt;!-- 配置获取连接等待超时的时间 --&gt;\n        &lt;property name=\"maxWait\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;\n        &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;\n        &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt;\n\n        &lt;property name=\"validationQuery\" value=\"${jdbc.testSql}\"/&gt;\n        &lt;property name=\"testWhileIdle\" value=\"true\"/&gt;\n        &lt;property name=\"testOnBorrow\" value=\"false\"/&gt;\n        &lt;property name=\"testOnReturn\" value=\"false\"/&gt;\n\n        &lt;!-- 配置监控统计拦截的filters --&gt;\n        &lt;property name=\"filters\" value=\"stat\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h4 id=\"配置-Druid-监控中心\"><a href=\"#配置-Druid-监控中心\" class=\"headerlink\" title=\"配置 Druid 监控中心\"></a>配置 Druid 监控中心</h4>\n <p>Druid 提供了大量的监控数据，只需要在 <code>web.xml</code> 中配置一个 Servlet 就可以方便的查看这些信息。</p> \n <p>修改 <code>web.xml</code> 配置文件，增加 Druid 提供的 Servlet</p> \n <pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n <p>打开浏览器，输入：<a href=\"http://localhost:8080/druid/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/druid/index.html</a> 浏览器显示效果如下：</p> \n <p><img src=\"/assets/Lusifer1528842755.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(41,3,'使用 Spring 注解管理事务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>通过 <code>@Transactional</code> 注解方式，也可将事务织入到相应方法中。而使用注解方式，只需在配置文件中加入一个 <code>tx</code> 标签，以告诉 Spring 使用注解来完成事务的织入。该标签只需指定一个属性，事务管理器。</p> \n <pre><code>&lt;!-- 开启事务注解驱动 --&gt;\n&lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt;\n</code></pre>\n <h3 id=\"Transactional-注解简介\"><a href=\"#Transactional-注解简介\" class=\"headerlink\" title=\"@Transactional 注解简介\"></a><code>@Transactional</code> 注解简介</h3>\n <p><code>@Transactional</code> 的所有可选属性：</p> \n <ul> \n  <li><p><code>propagation</code>：用于设置事务传播属性。该属性类型为 Propagation 枚举，默认值为 <code>Propagation.REQUIRED</code>。</p> </li> \n  <li><p><code>isolation</code>：用于设置事务的隔离级别。该属性类型为 Isolation 枚举 ，默认值为 <code>Isolation.DEFAULT</code>。</p> </li> \n  <li><p><code>readOnly</code>：用于设置该方法对数据库的操作是否是只读的。该属性为 boolean，默认值为 <code>false</code>。</p> </li> \n  <li><p><code>timeout</code>：用于设置本操作与数据库连接的超时时限。单位为秒，类型为 int，默认值为 -1，即没有时限。</p> </li> \n  <li><p><code>rollbackFor</code>：指定需要回滚的异常类。类型为 <code>Class[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>rollbackForClassName</code>：指定需要回滚的异常类类名。类型为 <code>String[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>noRollbackFor</code>：指定不需要回滚的异常类。类型为 <code>Class[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>noRollbackForClassName</code>： 指定不需要回滚的异常类类名。类型为 <code>String[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n </ul> \n <p>需要注意的是，<code>@Transactional</code> 若用在方法上，只能用于 <code>public</code> 方法上。对于其他非 <code>public</code> 方法，如果加上了注解 <code>@Transactional</code>，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 <code>public</code> 方法上的 <code>@Transaction</code> 注解。</p> \n <p>若 <code>@Transaction</code> 注解在类上，则表示该类上所有的方法均将在执行时织入事务。</p> \n <h3 id=\"使用-Transaction-注解\"><a href=\"#使用-Transaction-注解\" class=\"headerlink\" title=\"使用 @Transaction 注解\"></a>使用 <code>@Transaction</code> 注解</h3>\n <p>使用起来很简单，只需要在需要增加事务的业务类上增加 <code>@Transaction</code> 注解即可，案例代码如下：</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Transactional\n@Service(value = \"tbContentCategoryService\")\npublic class TbContentCategoryServiceImpl implements TbContentCategoryService {\n\n    @Autowired\n    private TbContentCategoryDao tbContentCategoryDao;\n\n    @Autowired\n    private TbContentService tbContentService;\n\n    public void save(TbContentCategory tbContentCategory, TbContent tbContent) {\n        tbContentCategoryDao.insert(tbContentCategory);\n        tbContentService.save(tbContent);\n    }\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(42,3,'Spring 事务管理简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>事务原本是数据库中的概念，用于数据访问层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。</p> \n <p>在 Spring 中通常可以通过以下三种方式来实现对事务的管理：</p> \n <ul> \n  <li><p>使用 Spring 的事务代理工厂管理事务（已过时）</p> </li> \n  <li><p>使用 Spring 的事务注解管理事务</p> </li> \n  <li><p>使用 AspectJ 的 AOP 配置管理事务</p> </li> \n </ul> \n <h3 id=\"Spring-事务管理-API\"><a href=\"#Spring-事务管理-API\" class=\"headerlink\" title=\"Spring 事务管理 API\"></a>Spring 事务管理 API</h3>\n <p>Spring 的事务管理，主要用到两个事务相关的接口。</p> \n <h4 id=\"事务管理器接口\"><a href=\"#事务管理器接口\" class=\"headerlink\" title=\"事务管理器接口\"></a>事务管理器接口</h4>\n <p>事务管理器是 <code>PlatformTransactionManager</code> 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。 </p> \n <p>该接口定义了 3 个事务方法：</p> \n <ul> \n  <li><p><code>void commit(TransactionStatus status)</code>：事务的提交</p> </li> \n  <li><p><code>TransactionStatus getTransaction(TransactionDefinition definition)</code>：获取事务的状态</p> </li> \n  <li><p><code>void rollback(TranscationStatus status)</code>：事务的回滚</p> </li> \n </ul> \n <h5 id=\"常用的两个实现类\"><a href=\"#常用的两个实现类\" class=\"headerlink\" title=\"常用的两个实现类\"></a>常用的两个实现类</h5>\n <p><code>PlatformTransactionManager</code> 接口有两个常用的实现类：</p> \n <ul> \n  <li><p><code>DataSourceTransactionManager</code>：使用 JDBC 或 MyBatis 进行持久化数据时使用。</p> </li> \n  <li><p><code>HibernateTransactionManager</code>：使用 Hibernate 进行持久化数据时使用。</p> </li> \n </ul> \n <h5 id=\"Spring-的回滚方式\"><a href=\"#Spring-的回滚方式\" class=\"headerlink\" title=\"Spring 的回滚方式\"></a>Spring 的回滚方式</h5>\n <p>Spring 事务的默认回滚方式是：发生运行时异常回滚</p> \n <h4 id=\"事务定义接口\"><a href=\"#事务定义接口\" class=\"headerlink\" title=\"事务定义接口\"></a>事务定义接口</h4>\n <p>事务定义接口 <code>TransactionDefinition</code> 中定义了事务描述相关的三类常量：<strong>事务隔离级别</strong>、<strong>事务传播行为</strong>、<strong>事务默认超时时限</strong>，及对它们的操作。</p> \n <h5 id=\"事务的四种隔离级别\"><a href=\"#事务的四种隔离级别\" class=\"headerlink\" title=\"事务的四种隔离级别\"></a>事务的四种隔离级别</h5>\n <ul> \n  <li><p>DEFAULT：采用 DB 默认的事务隔离级别。MySql 默认为 REPEATABLE_READ；Oracle 默认为：READ_COMMITTED；</p> </li> \n  <li><p>READ_UNCOMMITTED：读未提交。未解决任何并发问题。</p> </li> \n  <li><p>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。</p> </li> \n  <li><p>REPEATABLE_READ：可重复读。解决脏读、不可重复读。存在幻读。</p> </li> \n  <li><p>SERIALIZABLE：串行化。不存在并发问题。</p> </li> \n </ul> \n <h5 id=\"事务的七种传播行为\"><a href=\"#事务的七种传播行为\" class=\"headerlink\" title=\"事务的七种传播行为\"></a>事务的七种传播行为</h5>\n <p>所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 <code>a()</code> 调用 B 事务中的方法 <code>b()</code>，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。</p> \n <ul> \n  <li><p>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。</p> </li> \n  <li><p>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。</p> </li> \n  <li><p>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</p> </li> \n  <li><p>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p> </li> \n  <li><p>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</p> </li> \n  <li><p>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</p> </li> \n  <li><p>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:18','2018-12-19 15:31:18'),
(43,3,'MyBatis 单表 CRUD 操作',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>本章主要内容是带领大家学习 MyBatis 的单表 CRUD 的相关操作方法</p> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(44,3,'使用 Jackson 处理 JSON 数据',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Jackson-简介\"><a href=\"#Jackson-简介\" class=\"headerlink\" title=\"Jackson 简介\"></a>Jackson 简介</h3>\n <p>Jackson 是一个简单基于 Java 应用库，Jackson 可以轻松的将 Java 对象转换成 json 对象和 xml 文档，同样也可以将 json、xml 转换成 Java 对象。Jackson 所依赖的 jar 包较少，简单易用并且性能也要相对高些，并且 Jackson 社区相对比较活跃，更新速度也比较快。</p> \n <h3 id=\"Jackson-特点\"><a href=\"#Jackson-特点\" class=\"headerlink\" title=\"Jackson 特点\"></a>Jackson 特点</h3>\n <ul> \n  <li><p>容易使用 - jackson API 提供了一个高层次外观，以简化常用的用例。</p> </li> \n  <li><p>无需创建映射 - API提供了默认的映射大部分对象序列化。</p> </li> \n  <li><p>性能高 - 快速，低内存占用，适合大型对象图表或系统。</p> </li> \n  <li><p>干净的 JSON - jackson 创建一个干净和紧凑的 JSON 结果，这是让人很容易阅读。</p> </li> \n  <li><p>不依赖 - 库不需要任何其他的库，除了 JDK。</p> </li> \n  <li><p>开源代码 - jackson 是开源的，可以免费使用。</p> </li> \n </ul> \n <h3 id=\"Jackson-注解\"><a href=\"#Jackson-注解\" class=\"headerlink\" title=\"Jackson 注解\"></a>Jackson 注解</h3>\n <p>Jackson 类库包含了很多注解，可以让我们快速建立 Java 类与 JSON 之间的关系。</p> \n <h4 id=\"JsonProperty\"><a href=\"#JsonProperty\" class=\"headerlink\" title=\"@JsonProperty\"></a><code>@JsonProperty</code></h4>\n <p><code>@JsonProperty</code> 注解指定一个属性用于 JSON 映射，默认情况下映射的 JSON 属性与注解的属性名称相同，不过可以使用该注解的 <code>value</code> 值修改 JSON 属性名，该注解还有一个 <code>index</code> 属性指定生成 JSON 属性的顺序，如果有必要的话。</p> \n <h4 id=\"JsonIgnore\"><a href=\"#JsonIgnore\" class=\"headerlink\" title=\"@JsonIgnore\"></a><code>@JsonIgnore</code></h4>\n <p><code>@JsonIgnore</code> 注解用于排除某个属性，这样该属性就不会被 Jackson 序列化和反序列化。</p> \n <h4 id=\"JsonIgnoreProperties\"><a href=\"#JsonIgnoreProperties\" class=\"headerlink\" title=\"@JsonIgnoreProperties\"></a><code>@JsonIgnoreProperties</code></h4>\n <p><code>@JsonIgnoreProperties</code> 注解是类注解。在序列化为 JSON 的时候，<code>@JsonIgnoreProperties({\"prop1\", \"prop2\"})</code> 会忽略 <code>pro1</code> 和 <code>pro2</code> 两个属性。在从 JSON 反序列化为 Java 类的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code> 会忽略所有没有 <code>Getter</code> 和 <code>Setter</code> 的属性。该注解在 Java 类和 JSON 不完全匹配的时候很有用。</p> \n <h4 id=\"JsonIgnoreType\"><a href=\"#JsonIgnoreType\" class=\"headerlink\" title=\"@JsonIgnoreType\"></a><code>@JsonIgnoreType</code></h4>\n <p><code>@JsonIgnoreType</code> 也是类注解，会排除所有指定类型的属性。</p> \n <h4 id=\"JsonPropertyOrder\"><a href=\"#JsonPropertyOrder\" class=\"headerlink\" title=\"@JsonPropertyOrder\"></a><code>@JsonPropertyOrder</code></h4>\n <p><code>@JsonPropertyOrder</code> 和 <code>@JsonProperty</code> 的 <code>index</code> 属性类似，指定属性序列化时的顺序。</p> \n <h4 id=\"JsonRootName\"><a href=\"#JsonRootName\" class=\"headerlink\" title=\"@JsonRootName\"></a><code>@JsonRootName</code></h4>\n <p><code>@JsonRootName</code> 注解用于指定 JSON 根属性的名称。</p> \n <h3 id=\"Jackson-使用实例\"><a href=\"#Jackson-使用实例\" class=\"headerlink\" title=\"Jackson 使用实例\"></a>Jackson 使用实例</h3>\n <h4 id=\"对象的序列化与反序列化\"><a href=\"#对象的序列化与反序列化\" class=\"headerlink\" title=\"对象的序列化与反序列化\"></a>对象的序列化与反序列化</h4>\n <pre><code>package com.funtl.hello.httpclient;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\n\npublic class JsonTester {\n    public static void main(String[] args) {\n        // 创建 ObjectMapper 对象\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonString = \"{\\\"name\\\":\\\"Mahesh\\\", \\\"age\\\":21}\";\n\n        try {\n            // 反序列化 JSON 到对象\n            Student student = mapper.readValue(jsonString, Student.class);\n            System.out.println(student);\n\n            // 序列化对象到 JSON\n            String json = mapper.writeValueAsString(student);\n            System.out.println(json);\n        } catch (JsonParseException e) {\n            e.printStackTrace();\n        } catch (JsonMappingException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Student {\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student [ name: \" + name + \", age: \" + age + \" ]\";\n    }\n}\n</code></pre>\n <h4 id=\"集合的序列化与反序列化\"><a href=\"#集合的序列化与反序列化\" class=\"headerlink\" title=\"集合的序列化与反序列化\"></a>集合的序列化与反序列化</h4>\n <pre><code>package com.funtl.hello.httpclient;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JsonTester {\n    public static void main(String[] args) {\n        // 创建 ObjectMapper 对象\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonString = \"{\\\"draw\\\":1,\\\"recordsTotal\\\":1,\\\"recordsFiltered\\\":1,\\\"data\\\":[{\\\"id\\\":33,\\\"title\\\":\\\"ad1\\\",\\\"subTitle\\\":\\\"ad1\\\",\\\"titleDesc\\\":\\\"ad1\\\",\\\"url\\\":\\\"https://sale.jd.com/act/XkCzhoisOMSW.html\\\",\\\"pic\\\":\\\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\\\",\\\"pic2\\\":\\\"\\\",\\\"content\\\":\\\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\\\"}],\\\"error\\\":null}\";\n\n        try {\n            // 反序列化 JSON 到树\n            JsonNode jsonNode = mapper.readTree(jsonString);\n\n            // 从树中读取 data 节点\n            JsonNode jsonData = jsonNode.findPath(\"data\");\n            System.out.println(jsonData);\n\n            // 反序列化 JSON 到集合\n            JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, TbContent.class);\n            List&lt;TbContent&gt; tbContents = mapper.readValue(jsonData.toString(), javaType);\n            for (TbContent tbContent : tbContents) {\n                System.out.println(tbContent);\n            }\n\n            // 序列化集合到 JSON\n            String json = mapper.writeValueAsString(tbContents);\n            System.out.println(json);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass TbContent {\n    private Long id;\n    private String title;\n    private String subTitle;\n    private String titleDesc;\n    private String url;\n    private String pic;\n    private String pic2;\n    private String content;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getSubTitle() {\n        return subTitle;\n    }\n\n    public void setSubTitle(String subTitle) {\n        this.subTitle = subTitle;\n    }\n\n    public String getTitleDesc() {\n        return titleDesc;\n    }\n\n    public void setTitleDesc(String titleDesc) {\n        this.titleDesc = titleDesc;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getPic() {\n        return pic;\n    }\n\n    public void setPic(String pic) {\n        this.pic = pic;\n    }\n\n    public String getPic2() {\n        return pic2;\n    }\n\n    public void setPic2(String pic2) {\n        this.pic2 = pic2;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    @Override\n    public String toString() {\n        return \"TbContent{\" +\n                \"id=\" + id +\n                \", title=\'\" + title + \'\\\'\' +\n                \", subTitle=\'\" + subTitle + \'\\\'\' +\n                \", titleDesc=\'\" + titleDesc + \'\\\'\' +\n                \", url=\'\" + url + \'\\\'\' +\n                \", pic=\'\" + pic + \'\\\'\' +\n                \", pic2=\'\" + pic2 + \'\\\'\' +\n                \", content=\'\" + content + \'\\\'\' +\n                \'}\';\n    }\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(45,3,'使用 AspectJ 的 AOP 配置管理事务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>注：本案例所使用的数据库为 <code>项目实战</code> 中的数据库，有需要的请加群获取</p> \n <p>AspectJ 主要是使用 XML 配置顾问方式自动为每个符合切入点表达式的类生成事务代理。创建测试操作步骤如下：</p> \n <h4 id=\"创建测试项目\"><a href=\"#创建测试项目\" class=\"headerlink\" title=\"创建测试项目\"></a>创建测试项目</h4>\n <p>创建一个名为 <code>aspectj-aop</code> 项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;hello-spring-transaction&lt;/groupId&gt;\n    &lt;artifactId&gt;aspectj-aop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;!-- 环境配置 --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n\n        &lt;!-- 统一的依赖管理 --&gt;\n        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n        &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt;\n        &lt;spring.version&gt;4.3.17.RELEASE&lt;/spring.version&gt;\n        &lt;alibaba-druid.version&gt;1.1.6&lt;/alibaba-druid.version&gt;\n        &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt;\n        &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt;\n        &lt;mybaits-spring.version&gt;1.3.1&lt;/mybaits-spring.version&gt;\n        &lt;junit.version&gt;4.12&lt;/junit.version&gt;\n        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Test Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;${junit.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Test Begin --&gt;\n\n        &lt;!-- Spring Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring End --&gt;\n\n        &lt;!-- Log Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n            &lt;version&gt;${log4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Log End --&gt;\n\n        &lt;!-- Database Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid&lt;/artifactId&gt;\n            &lt;version&gt;${alibaba-druid.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;${mysql.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;${mybatis.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n            &lt;version&gt;${mybaits-spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Database End --&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombok.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n <p>相较于 <code>项目实战</code> 中的 POM，主要是增加了 <code>org.springframework:spring-aspects</code> 依赖</p> \n <h4 id=\"创建实体类\"><a href=\"#创建实体类\" class=\"headerlink\" title=\"创建实体类\"></a>创建实体类</h4>\n <h5 id=\"TbContentCategory\"><a href=\"#TbContentCategory\" class=\"headerlink\" title=\"TbContentCategory\"></a>TbContentCategory</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.domain;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n/**\n * 分类管理\n * &lt;p&gt;Title: TbContentCategory&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/25 9:14\n */\n@Data\npublic class TbContentCategory {\n    private Long id;\n    private String name;\n    private Integer status;\n    private Integer sortOrder;\n    private Boolean isParent;\n    private Date created;\n    private Date updated;\n    private TbContentCategory parent;\n}\n</code></pre>\n <h5 id=\"TbContent\"><a href=\"#TbContent\" class=\"headerlink\" title=\"TbContent\"></a>TbContent</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.domain;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n/**\n * 内容管理\n * &lt;p&gt;Title: TbContent&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/25 14:02\n */\n@Data\npublic class TbContent {\n    private Long id;\n    private String title;\n    private String subTitle;\n    private String titleDesc;\n    private String url;\n    private String pic;\n    private String pic2;\n    private String content;\n    private Date created;\n    private Date updated;\n    private TbContentCategory tbContentCategory;\n}\n</code></pre>\n <h4 id=\"创建数据访问层\"><a href=\"#创建数据访问层\" class=\"headerlink\" title=\"创建数据访问层\"></a>创建数据访问层</h4>\n <h5 id=\"TbContentCategoryDao\"><a href=\"#TbContentCategoryDao\" class=\"headerlink\" title=\"TbContentCategoryDao\"></a>TbContentCategoryDao</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.dao;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface TbContentCategoryDao {\n    void insert(TbContentCategory tbContentCategory);\n}\n</code></pre>\n <h5 id=\"TbContentDao\"><a href=\"#TbContentDao\" class=\"headerlink\" title=\"TbContentDao\"></a>TbContentDao</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.dao;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface TbContentDao {\n    void insert(TbContent tbContent);\n}\n</code></pre>\n <h4 id=\"创建业务逻辑层\"><a href=\"#创建业务逻辑层\" class=\"headerlink\" title=\"创建业务逻辑层\"></a>创建业务逻辑层</h4>\n <h5 id=\"TbContentCategoryService\"><a href=\"#TbContentCategoryService\" class=\"headerlink\" title=\"TbContentCategoryService\"></a>TbContentCategoryService</h5>\n <p>接口</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\n\npublic interface TbContentCategoryService {\n    void save(TbContentCategory tbContentCategory, TbContent tbContent);\n}\n</code></pre>\n <p>实现</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TbContentCategoryServiceImpl implements TbContentCategoryService {\n\n    @Autowired\n    private TbContentCategoryDao tbContentCategoryDao;\n\n    @Autowired\n    private TbContentService tbContentService;\n\n    public void save(TbContentCategory tbContentCategory, TbContent tbContent) {\n        tbContentCategoryDao.insert(tbContentCategory);\n        tbContentService.save(tbContent);\n    }\n}\n</code></pre>\n <h5 id=\"TbContentService\"><a href=\"#TbContentService\" class=\"headerlink\" title=\"TbContentService\"></a>TbContentService</h5>\n <p>接口</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\n\npublic interface TbContentService {\n    void save(TbContent tbContent);\n}\n</code></pre>\n <p>实现</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TbContentServiceImpl implements TbContentService {\n\n    @Autowired\n    private TbContentDao tbContentDao;\n\n    public void save(TbContent tbContent) {\n        tbContentDao.insert(tbContent);\n    }\n}\n</code></pre>\n <h4 id=\"创建-Spring-配置\"><a href=\"#创建-Spring-配置\" class=\"headerlink\" title=\"创建 Spring 配置\"></a>创建 Spring 配置</h4>\n <h5 id=\"spring-context-xml\"><a href=\"#spring-context-xml\" class=\"headerlink\" title=\"spring-context.xml\"></a><code>spring-context.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;context:annotation-config/&gt;\n    &lt;context:component-scan base-package=\"com.hello.spring.transaction.aspectsj.aop\"&gt;\n        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n    &lt;/context:component-scan&gt;\n\n    &lt;!-- 配置事务管理器 --&gt;\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置事务通知 --&gt;\n    &lt;tx:advice id=\"myAdvice\" transaction-manager=\"transactionManager\"&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt;\n        &lt;/tx:attributes&gt;\n    &lt;/tx:advice&gt;\n\n    &lt;!-- 配置顾问和切入点 --&gt;\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.hello.spring.transaction.aspectsj.aop.service.*.*(..))\" /&gt;\n        &lt;aop:advisor advice-ref=\"myAdvice\" pointcut-ref=\"myPointcut\" /&gt;\n    &lt;/aop:config&gt;\n&lt;/beans&gt;\n</code></pre>\n <h5 id=\"spring-context-druid-xml\"><a href=\"#spring-context-druid-xml\" class=\"headerlink\" title=\"spring-context-druid.xml\"></a><code>spring-context-druid.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;\n        &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;\n        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClass}\"/&gt;\n\n        &lt;!-- 基本属性 url、user、password --&gt;\n        &lt;property name=\"url\" value=\"${jdbc.connectionURL}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n\n        &lt;!-- 配置初始化大小、最小、最大 --&gt;\n        &lt;property name=\"initialSize\" value=\"${jdbc.pool.init}\"/&gt;\n        &lt;property name=\"minIdle\" value=\"${jdbc.pool.minIdle}\"/&gt;\n        &lt;property name=\"maxActive\" value=\"${jdbc.pool.maxActive}\"/&gt;\n\n        &lt;!-- 配置获取连接等待超时的时间 --&gt;\n        &lt;property name=\"maxWait\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;\n        &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;\n        &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt;\n\n        &lt;property name=\"validationQuery\" value=\"${jdbc.testSql}\"/&gt;\n        &lt;property name=\"testWhileIdle\" value=\"true\"/&gt;\n        &lt;property name=\"testOnBorrow\" value=\"false\"/&gt;\n        &lt;property name=\"testOnReturn\" value=\"false\"/&gt;\n\n        &lt;!-- 配置监控统计拦截的filters --&gt;\n        &lt;property name=\"filters\" value=\"stat\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h5 id=\"spring-context-mybatis-xml\"><a href=\"#spring-context-mybatis-xml\" class=\"headerlink\" title=\"spring-context-mybatis.xml\"></a><code>spring-context-mybatis.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 \',\' 号分割 --&gt;\n        &lt;property name=\"typeAliasesPackage\" value=\"com.hello.spring.transaction.aspectsj.aop.domain\"/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=\"mapperLocations\" value=\"classpath:/mapper/**/*.xml\"/&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;property name=\"basePackage\" value=\"com.hello.spring.transaction.aspectsj.aop.dao\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h4 id=\"创建-MyBatis-配置和映射文件\"><a href=\"#创建-MyBatis-配置和映射文件\" class=\"headerlink\" title=\"创建 MyBatis 配置和映射文件\"></a>创建 MyBatis 配置和映射文件</h4>\n <h5 id=\"mybatis-config-xml\"><a href=\"#mybatis-config-xml\" class=\"headerlink\" title=\"mybatis-config.xml\"></a><code>mybatis-config.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;\n</code></pre>\n <h5 id=\"TbContentCategoryMapper-xml\"><a href=\"#TbContentCategoryMapper-xml\" class=\"headerlink\" title=\"TbContentCategoryMapper.xml\"></a><code>TbContentCategoryMapper.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao\"&gt;\n    &lt;insert id=\"insert\"&gt;\n        INSERT INTO tb_content_category (\n          `parent_id`,\n          `name`,\n          `status`,\n          `sort_order`,\n          `is_parent`,\n          `created`,\n          `updated`\n        )\n        VALUES\n          (\n            #{parent.id},\n            #{name},\n            #{status},\n            #{sortOrder},\n            #{isParent},\n            #{created},\n            #{updated}\n          );\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h5 id=\"TbContentMapper-xml\"><a href=\"#TbContentMapper-xml\" class=\"headerlink\" title=\"TbContentMapper.xml\"></a><code>TbContentMapper.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.hello.spring.transaction.aspectsj.aop.dao.TbContentDao\"&gt;\n    &lt;insert id=\"insert\"&gt;\n        INSERT INTO tb_content (\n          `category_id`,\n          `title`,\n          `sub_title`,\n          `title_desc`,\n          `url`,\n          `pic`,\n          `pic2`,\n          `content`,\n          `created`,\n          `updated`\n        )\n        VALUES\n          (\n            #{tbContentCategory.id},\n            #{title},\n            #{subTitle},\n            #{titleDesc},\n            #{url},\n            #{pic},\n            #{pic2},\n            #{content},\n            #{created},\n            #{updated}\n          )\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h4 id=\"创建系统配置文件\"><a href=\"#创建系统配置文件\" class=\"headerlink\" title=\"创建系统配置文件\"></a>创建系统配置文件</h4>\n <h5 id=\"log4j-properties\"><a href=\"#log4j-properties\" class=\"headerlink\" title=\"log4j.properties\"></a><code>log4j.properties</code></h5>\n <pre><code>log4j.rootLogger=INFO, console, file\n\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n\n\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.File=logs/log.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A3.MaxFileSize=1024KB\nlog4j.appender.A3.MaxBackupIndex=10\nlog4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre>\n <h5 id=\"jdbc-properties\"><a href=\"#jdbc-properties\" class=\"headerlink\" title=\"jdbc.properties\"></a><code>jdbc.properties</code></h5>\n <pre><code>#============================#\n#==== Database settings ====#\n#============================#\n\n# JDBC\n# MySQL 8.x: com.mysql.cj.jdbc.Driver\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.connectionURL=jdbc:mysql://192.168.75.134:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\njdbc.username=root\njdbc.password=123456\n\n# JDBC Pool\njdbc.pool.init=1\njdbc.pool.minIdle=3\njdbc.pool.maxActive=20\n\n# JDBC Test\njdbc.testSql=SELECT \'x\' FROM DUAL\n</code></pre>\n <h4 id=\"创建测试类\"><a href=\"#创建测试类\" class=\"headerlink\" title=\"创建测试类\"></a>创建测试类</h4>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.test;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:spring-context.xml\", \"classpath:spring-context-druid.xml\", \"classpath:spring-context-mybatis.xml\"})\npublic class TestSpringTransaction {\n\n    @Autowired\n    private TbContentCategoryService tbContentCategoryService;\n\n    @Test\n    public void test() {\n        TbContentCategory tbContentCategory = new TbContentCategory();\n        tbContentCategory.setId(1L);\n        tbContentCategory.setName(\"测试事务分类\");\n\n        TbContent tbContent = new TbContent();\n        tbContent.setTbContentCategory(tbContentCategory);\n        // 在这里你可以将内容设置为超出数据库字段的存储范围来验证事务是否开启\n        tbContent.setTitle(\"测试事务内容\");\n\n        tbContentCategoryService.save(tbContentCategory, tbContent);\n    }\n}\n</code></pre>\n <p>运行观察事务效果：</p> \n <ul> \n  <li><p>有事务：数据插入成功则两张表都存在数据，只要出现异常则两张表都没有数据</p> </li> \n  <li><p>无事务：如果第一张表数据插入成功，但第二张表报错则第一张表的数据不会回滚</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(46,3,'你怎么理解 RESTful',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>2000 年，Roy Thomas Fielding 博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了几种软件应用的架构风格，REST 作为其中的一种架构风格在这篇论文的第5章中进行了概括性的介绍。</p> \n <p>REST 是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”，但是在绝大多数场合中我们只说 REST 或者 RESTful。Fielding 在论文中将 REST 定位为“分布式超媒体应用（Distributed Hypermedia System）”的架构风格，它在文中提到一个名为“HATEOAS（Hypermedia as the engine of application state）”的概念。</p> \n <p>我们利用一个面向最终用户的 Web 应用来对这个概念进行简单阐述：这里所谓的应用状态（Application State）表示 Web 应用的客户端的状态，简单起见可以理解为会话状态。资源在浏览器中以超媒体的形式呈现，通过点击超媒体中的链接可以获取其它相关的资源或者对当前资源进行相应的处理，获取的资源或者针对资源处理的响应同样以超媒体的形式再次呈现在浏览器上。由此可见，超媒体成为了驱动客户端会话状态的转换的引擎。</p> \n <p>借助于超媒体这种特殊的资源呈现方式，应用状态的转换体现为浏览器中呈现资源的转换。如果将超媒体进一步抽象成一般意义上的资源呈现（Representation ）方式，那么应用状态变成了可被呈现的状态（REpresentational State）。应用状态之间的转换就成了可被呈现的状态装换（REpresentational State Transfer），这就是 REST。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>REST 是一种很笼统的概念，它代表一种架构风格。</p> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(47,3,'使用 Apache HttpClient 解决通信问题',1,'www.funtl.com/assets/Lusifer201807030001.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"简易架构图\"><a href=\"#简易架构图\" class=\"headerlink\" title=\"简易架构图\"></a>简易架构图</h3>\n <p><img src=\"/assets/Lusifer201807030001.png\" alt=\"\"></p> \n <h3 id=\"Apache-HttpClient-简介\"><a href=\"#Apache-HttpClient-简介\" class=\"headerlink\" title=\"Apache HttpClient 简介\"></a>Apache HttpClient 简介</h3>\n <blockquote> \n  <p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p> \n </blockquote> \n <p>HttpClient 相比传统 JDK 自带的 <code>URLConnection</code>，增加了易用性和灵活性，它不仅是客户端发送 HTTP 请求变得容易，而且也方便了开发人员测试接口（基于 HTTP 协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握 HttpClient 是很重要的必修内容，掌握 HttpClient 后，相信对于 HTTP 协议的了解会更加深入。</p> \n <h3 id=\"Apache-HttpClient-特性\"><a href=\"#Apache-HttpClient-特性\" class=\"headerlink\" title=\"Apache HttpClient 特性\"></a>Apache HttpClient 特性</h3>\n <ul> \n  <li><p>基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1</p> </li> \n  <li><p>以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</p> </li> \n  <li><p>支持 HTTPS 协议。</p> </li> \n  <li><p>通过 HTTP 代理建立透明的连接。</p> </li> \n  <li><p>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</p> </li> \n  <li><p>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。</p> </li> \n  <li><p>插件式的自定义认证方案。</p> </li> \n  <li><p>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</p> </li> \n  <li><p>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</p> </li> \n  <li><p>自动处理 Set-Cookie 中的 Cookie。</p> </li> \n  <li><p>插件式的自定义 Cookie 策略。</p> </li> \n  <li><p>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</p> </li> \n  <li><p>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</p> </li> \n  <li><p>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</p> </li> \n  <li><p>直接获取服务器发送的 response code 和 headers。</p> </li> \n  <li><p>设置连接超时的能力。</p> </li> \n  <li><p>实验性的支持 HTTP 1.1 response caching。</p> </li> \n  <li><p>源代码基于 Apache License 可免费获取。</p> </li> \n </ul> \n <h3 id=\"Apache-HttpClient-使用流程\"><a href=\"#Apache-HttpClient-使用流程\" class=\"headerlink\" title=\"Apache HttpClient 使用流程\"></a>Apache HttpClient 使用流程</h3>\n <p>使用 HttpClient 发送请求、接收响应很简单，一般需要如下几步即可。</p> \n <ul> \n  <li><p>创建 <code>HttpClient</code> 对象。</p> </li> \n  <li><p>创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 <code>HttpGet</code> 对象；如果需要发送 POST 请求，创建 <code>HttpPost</code> 对象。</p> </li> \n  <li><p>如果需要发送请求参数，可调用 <code>HttpGet</code>、<code>HttpPost</code> 共同的 <code>setParams(HttpParams params)</code> 方法来添加请求参数；对于 <code>HttpPost</code> 对象而言，也可调用 <code>setEntity(HttpEntity entity)</code> 方法来设置请求参数。</p> </li> \n  <li><p>调用 <code>HttpClient</code> 对象的 <code>execute(HttpUriRequest request)</code> 发送请求，该方法返回一个 <code>HttpResponse</code>。</p> </li> \n  <li><p>调用 <code>HttpResponse</code> 的 <code>getAllHeaders()</code>、<code>getHeaders(String name)</code> 等方法可获取服务器的响应头；调用 <code>HttpResponse</code> 的 <code>getEntity()</code> 方法可获取 <code>HttpEntity</code> 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</p> </li> \n  <li><p>释放连接。无论执行方法是否成功，都必须释放连接</p> </li> \n </ul> \n <h3 id=\"Apache-HttpClient-使用实例\"><a href=\"#Apache-HttpClient-使用实例\" class=\"headerlink\" title=\"Apache HttpClient 使用实例\"></a>Apache HttpClient 使用实例</h3>\n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p><code>pom.xml</code> 配置如下：</p> \n <pre><code>&lt;!-- Apache Http Begin --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- Apache Http End --&gt;\n</code></pre>\n <p>主要增加了 <code>org.apache.httpcomponents:httpclient</code>、<code>org.apache.httpcomponents:fluent-hc</code>、<code>org.apache.httpcomponents:httpmime</code> 三个依赖</p> \n <h4 id=\"创建-HttpGet-请求\"><a href=\"#创建-HttpGet-请求\" class=\"headerlink\" title=\"创建 HttpGet 请求\"></a>创建 HttpGet 请求</h4>\n <p>案例代码如下：</p> \n <pre><code>package com.funtl.hello.httpclient;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        get();\n    }\n\n    private static void get() {\n        // 创建 HttpClient 客户端\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n\n        // 创建 HttpGet 请求\n        HttpGet httpGet = new HttpGet(\"http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10\");\n        // 设置长连接\n        httpGet.setHeader(\"Connection\", \"keep-alive\");\n        // 设置代理（模拟浏览器版本）\n        httpGet.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n        // 设置 Cookie\n        httpGet.setHeader(\"Cookie\", \"UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4\");\n\n        CloseableHttpResponse httpResponse = null;\n        try {\n            // 请求并获得响应结果\n            httpResponse = httpClient.execute(httpGet);\n            HttpEntity httpEntity = httpResponse.getEntity();\n            // 输出请求结果\n            System.out.println(EntityUtils.toString(httpEntity));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 无论如何必须关闭连接\n        finally {\n            if (httpResponse != null) {\n                try {\n                    httpResponse.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (httpClient != null) {\n                try {\n                    httpClient.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n <p>控制台输出结果：</p> \n <pre><code>{\"draw\":1,\"recordsTotal\":1,\"recordsFiltered\":1,\"data\":[{\"id\":33,\"created\":1530542074000,\"updated\":1530542074000,\"title\":\"ad1\",\"subTitle\":\"ad1\",\"titleDesc\":\"ad1\",\"url\":\"https://sale.jd.com/act/XkCzhoisOMSW.html\",\"pic\":\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\",\"pic2\":\"\",\"content\":\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\",\"tbContentCategory\":{\"id\":89,\"created\":null,\"updated\":null,\"parent\":null,\"isParent\":null,\"name\":\"幻灯片\",\"status\":null,\"sortOrder\":null}}],\"error\":null}\n</code></pre>\n <h4 id=\"创建-HttpPost-请求\"><a href=\"#创建-HttpPost-请求\" class=\"headerlink\" title=\"创建 HttpPost 请求\"></a>创建 HttpPost 请求</h4>\n <p>案例代码如下：</p> \n <pre><code>package com.funtl.hello.httpclient;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        post();\n    }\n\n    private static void post() {\n        // 创建 HttpClient 客户端\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n\n        // 创建 HttpPost 请求\n        HttpPost httpPost = new HttpPost(\"http://localhost:8080/content/page\");\n        // 设置长连接\n        httpPost.setHeader(\"Connection\", \"keep-alive\");\n        // 设置代理（模拟浏览器版本）\n        httpPost.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n        // 设置 Cookie\n        httpPost.setHeader(\"Cookie\", \"UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4\");\n\n        // 创建 HttpPost 参数\n        List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;();\n        params.add(new BasicNameValuePair(\"draw\", \"1\"));\n        params.add(new BasicNameValuePair(\"start\", \"0\"));\n        params.add(new BasicNameValuePair(\"length\", \"10\"));\n\n        CloseableHttpResponse httpResponse = null;\n        try {\n            // 设置 HttpPost 参数\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            httpResponse = httpClient.execute(httpPost);\n            HttpEntity httpEntity = httpResponse.getEntity();\n            // 输出请求结果\n            System.out.println(EntityUtils.toString(httpEntity));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 无论如何必须关闭连接\n        finally {\n            try {\n                if (httpResponse != null) {\n                    httpResponse.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (httpClient != null) {\n                    httpClient.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n <p>控制台输出结果：</p> \n <pre><code>{\"draw\":1,\"recordsTotal\":1,\"recordsFiltered\":1,\"data\":[{\"id\":33,\"created\":1530542074000,\"updated\":1530542074000,\"title\":\"ad1\",\"subTitle\":\"ad1\",\"titleDesc\":\"ad1\",\"url\":\"https://sale.jd.com/act/XkCzhoisOMSW.html\",\"pic\":\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\",\"pic2\":\"\",\"content\":\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\",\"tbContentCategory\":{\"id\":89,\"created\":null,\"updated\":null,\"parent\":null,\"isParent\":null,\"name\":\"幻灯片\",\"status\":null,\"sortOrder\":null}}],\"error\":null}\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(48,3,'媒体查询的用法',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"media-媒体查询的用法\"><a href=\"#media-媒体查询的用法\" class=\"headerlink\" title=\"@media 媒体查询的用法\"></a><code>@media</code> 媒体查询的用法</h3>\n <p>媒体查询能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。</p> \n <h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h3>\n <p>表格中的数字表示支持 <code>@media</code> 规则的第一个浏览器的版本号</p> \n <table> \n  <thead> \n   <tr> \n    <th>Chrome</th> \n    <th>IE</th> \n    <th>Firefox</th> \n    <th>Safari</th> \n    <th>Opera</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>21</td> \n    <td>9</td> \n    <td>3.5</td> \n    <td>4.0</td> \n    <td>9</td> \n   </tr> \n  </tbody> \n </table> \n <h3 id=\"媒体类型\"><a href=\"#媒体类型\" class=\"headerlink\" title=\"媒体类型\"></a>媒体类型</h3>\n <p>媒体类型在 CSS2 中是一个常见属性，可以通过媒体类型对不同设备指定不同样式。</p> \n <ul> \n  <li><p>ALL：所有设备</p> </li> \n  <li><p>Braille：盲人用点子法触觉回馈设备</p> </li> \n  <li><p>Embossed：盲文打印机</p> </li> \n  <li><p>Handheld：便携设备</p> </li> \n  <li><p>Print：打印用纸或打印预览视图</p> </li> \n  <li><p>Projection：各种投影设备</p> </li> \n  <li><p>Screen：电脑显示器</p> </li> \n  <li><p>Speech：语音或音频合成器</p> </li> \n  <li><p>Tv：电视机类型设备</p> </li> \n  <li><p>Tty：使用固定密度字母栅格的媒介，比如电传打字机和终端 </p> </li> \n </ul> \n <p><strong>Screen</strong>、<strong>All</strong>、<strong>Print</strong> 为最常见的三种媒体类型。</p> \n <h3 id=\"媒体特性\"><a href=\"#媒体特性\" class=\"headerlink\" title=\"媒体特性\"></a>媒体特性</h3>\n <p>媒体查询中的大部分接受 <code>min/max</code> 前缀，用来表达其逻辑关系，表示应用大于等于或小于等于某个值的情况。没有特殊说明都支持 <code>min/max</code>。</p> \n <ul> \n  <li><p>width：Length 渲染界面的宽度 </p> </li> \n  <li><p>height：Length 渲染界面的高度</p> </li> \n  <li><p>color：整数，表示色彩的字节数 </p> </li> \n  <li><p>color-index：整数， 色彩表中的色彩数 </p> </li> \n  <li><p>device-aspct-ratio：整数/整数，宽高比例 </p> </li> \n  <li><p>device-height：Length 设备屏幕的输出高度 </p> </li> \n  <li><p>device-width：Length 设备屏幕的输出宽度 </p> </li> \n  <li><p>grid（不支持 <code>min/max</code> 前缀）：整数，是否基于栅格的设备 </p> </li> \n  <li><p>monochrome：整数，单色帧缓冲器中每像素字节数 </p> </li> \n  <li><p>resolution：分辨率（dpi/dpcm）分辨率 </p> </li> \n  <li><p>scan（不支持 <code>min/max</code> 前缀）：Progressive interlaced，Tv 媒体类型的扫描方式 </p> </li> \n  <li><p>orientation（不支持 <code>min/max</code> 前缀）：Portrait//landscape 横屏或竖屏</p> </li> \n </ul> \n <h3 id=\"使用媒体查询\"><a href=\"#使用媒体查询\" class=\"headerlink\" title=\"使用媒体查询\"></a>使用媒体查询</h3>\n <p>语法：<code>@media 媒体类型 and (媒体特性) {你的样式}</code></p> \n <h4 id=\"最大宽度\"><a href=\"#最大宽度\" class=\"headerlink\" title=\"最大宽度\"></a>最大宽度</h4>\n <p><code>max-width</code> 是媒体特性中最常用的一个特性，其意思是指媒体类型小于或等于指定的宽度时，样式生效。如：</p> \n <pre><code>@media screen and (max-width:480px) {\n .ads {\n   display:none;\n  }\n}\n</code></pre>\n <p>上面表示的是：当屏幕小于或等于 480px 时，页面中包含类样式 <code>.ads</code> 的元素都将被隐藏。</p> \n <h4 id=\"最小宽度\"><a href=\"#最小宽度\" class=\"headerlink\" title=\"最小宽度\"></a>最小宽度</h4>\n <p><code>min-width</code> 与 <code>max-width</code> 相反，指的是媒体类型大于或等于指定宽度时，样式生效。</p> \n <pre><code>@media screen and (min-width: 900px) {\n    .wrapper {width: 980px;}\n}\n</code></pre>\n <p>上面表示的是：当屏幕大于或等于 900px 时，页面中包含类样式 <code>.wrapper</code> 元素的宽度为 980px。</p> \n <h4 id=\"多个媒体特性的使用\"><a href=\"#多个媒体特性的使用\" class=\"headerlink\" title=\"多个媒体特性的使用\"></a>多个媒体特性的使用</h4>\n <p>媒体查询可以使用关键词 <code>and</code> 将多个媒体特性结合在一起。也就是说，一个媒体查询中可以包含 0 到多个表达式，表达式又可以包含 0 到多个关键字，以及一种媒体类型。</p> \n <p>当屏幕在 600px~900px 之间时，<code>body</code> 的背景色渲染为 <code>#F5F5F5</code> ，如下所示：</p> \n <pre><code>@media screen and (min-width:600px) and (max-width:900px) {\n  body {background-color:#F5F5F5;}\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:31:19','2018-12-19 15:31:19'),
(49,12,'面试宝典',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av31873911/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/09/16/interview/Java-面试宝典-知己知彼百战不殆/\">面试心经-知己知彼百战不殆</a></li> \n </ul> \n <h3 id=\"简历篇\"><a href=\"#简历篇\" class=\"headerlink\" title=\"简历篇\"></a>简历篇</h3>\n <ul> \n  <li>自我介绍</li> \n  <li>项目介绍</li> \n </ul> \n <h3 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h3>\n <ul> \n  <li><h4 id=\"Java-基础\"><a href=\"#Java-基础\" class=\"headerlink\" title=\"Java 基础\"></a>Java 基础</h4>\n   <ul> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-面向对象的特征/\">面向对象的特征</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-final-finally-finalize-的区别/\">final, finally, finalize 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-int-和-Integer-有什么区别/\">int 和 Integer 有什么区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-重载和重写的区别/\">重载和重写的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-抽象类和接口有什么区别/\">抽象类和接口有什么区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-说说反射的用途及实现/\">说说反射的用途及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-说说自定义注解的场景及实现/\">说说自定义注解的场景及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HTTP-请求的-GET-与-POST-方式的区别/\">HTTP 请求的 GET 与 POST 方式的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-session-与-cookie-区别/\">session 与 cookie 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-session-分布式处理/\">session 分布式处理</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-JDBC-流程/\">JDBC 流程</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-MVC-设计思想/\">MVC 设计思想</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-equals-与-的区别/\">equals 与 == 的区别</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-集合\"><a href=\"#Java-集合\" class=\"headerlink\" title=\"Java 集合\"></a>Java 集合</h4>\n   <ul> \n    <li><a href=\"/2018/07/11/interview/Java-面试宝典-List-和-Set-区别/\">List 和 Set 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-List-和-Map-区别/\">List 和 Map 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-Arraylist-与-LinkedList-区别/\">ArrayList 与 LinkedList 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-ArrayList-与-Vector-区别/\">ArrayList 与 Vector 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-和-HashTable-的区别/\">HashMap 和 HashTable 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashSet-和-HashMap-区别/\">HashSet 和 HashMap 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-和-ConcurrentHashMap-的区别/\">HashMap 和 ConcurrentHashMap 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-的工作原理及代码实现/\">HashMap 的工作原理及代码实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-ConcurrentHashMap-的工作原理及代码实现/\">ConcurrentHashMap 的工作原理及代码实现</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h4>\n   <ul> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-创建线程的方式及实现/\">创建线程的方式及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-sleep-、join（）、yield（）有什么区别/\">sleep() 、join（）、yield（）有什么区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CountDownLatch-原理/\">说说 CountDownLatch 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CyclicBarrier-原理/\">说说 CyclicBarrier 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-Semaphore-原理/\">说说 Semaphore 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-Exchanger-原理/\">说说 Exchanger 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CountDownLatch-与-CyclicBarrier-区别/\">说说 CountDownLatch 与 CyclicBarrier 区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ThreadLocal-原理分析/\">ThreadLocal 原理分析</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-讲讲线程池的实现原理/\">讲讲线程池的实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-线程池的几种方式与使用场景/\">线程池的几种方式与使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-线程的生命周期/\">线程的生命周期</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-锁机制\"><a href=\"#Java-锁机制\" class=\"headerlink\" title=\"Java 锁机制\"></a>Java 锁机制</h4>\n   <ul> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说线程安全问题/\">说说线程安全问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-volatile-实现原理/\">volatile 实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-synchronize-实现原理/\">synchronize 实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-synchronized-与-lock-的区别/\">synchronized 与 lock 的区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-CAS-乐观锁/\">CAS 乐观锁</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ABA-问题/\">ABA 问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-乐观锁的业务场景及实现方式/\">乐观锁的业务场景及实现方式</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"核心篇\"><a href=\"#核心篇\" class=\"headerlink\" title=\"核心篇\"></a>核心篇</h3>\n <ul> \n  <li><h4 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h4>\n   <ul> \n    <li><a href=\"/2018/08/26/interview/58-到家-MySQL-军规升级版/\">58 到家 MySQL 军规升级版（如何优化 MySQL）</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-MySQL-索引使用的注意事项/\">MySQL 索引使用的注意事项</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说反模式设计/\">说说反模式设计</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说分库与分表设计/\">说说分库与分表设计</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-分库与分表带来的分布式困境与应对之策/\">分库与分表带来的分布式困境与应对之策</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-SQL-优化之道/\">说说 SQL 优化之道</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-MySQL-遇到的死锁问题/\">MySQL 遇到的死锁问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-存储引擎的-InnoDB-与-MyISAM/\">存储引擎的 InnoDB 与 MyiSAM</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-数据库索引的原理/\">数据库索引的原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-为什么要用-B-Tree/\">为什么要用 B-Tree</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聚集索引与非聚集索引的区别/\">聚集索引与非聚集索引的区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-limit-20000-加载很慢怎么解决/\">limit 20000 加载很慢怎么解决</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-选择合适的分布式主键方案/\">选择合适的分布式主键方案</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-选择合适的数据存储方案/\">选择合适的数据存储方案</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ObjectId-规则/\">ObjectId 规则</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-MongoDB-使用场景/\">聊聊 MongoDB 使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-倒排索引/\">倒排索引</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-ElasticSearch-使用场景/\">聊聊 ElasticSearch 使用场景</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"缓存使用\"><a href=\"#缓存使用\" class=\"headerlink\" title=\"缓存使用\"></a>缓存使用</h4>\n   <ul> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-有哪些类型/\">Redis 有哪些类型</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-内部结构/\">Redis 内部结构</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-内存淘汰机制/\">Redis 内存淘汰机制</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-Redis-使用场景/\">聊聊 Redis 使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-持久化机制/\">Redis 持久化机制</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-集群方案与实现/\">Redis 集群方案与实现</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-为什么是单线程的/\">Redis 为什么是单线程的</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-缓存崩溃/\">缓存崩溃</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-缓存降级/\">缓存降级</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-使用缓存的合理性问题/\">使用缓存的合理性问题</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息队列的使用场景/\">消息队列的使用场景</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的重发补偿解决思路/\">消息的重发补偿解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的幂等性解决思路/\">消息的幂等性解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的堆积解决思路/\">消息的堆积解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-自己如何实现消息队列/\">自己如何实现消息队列</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何保证消息的有序性/\">如何保证消息的有序性</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"框架篇\"><a href=\"#框架篇\" class=\"headerlink\" title=\"框架篇\"></a>框架篇</h3>\n <ul> \n  <li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-BeanFactory-和-ApplicationContext-有什么区别/\">BeanFactory 和 ApplicationContext 有什么区别</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-Bean-的生命周期/\">Spring Bean 的生命周期</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-IOC-如何实现/\">Spring IOC 如何实现</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Spring-AOP/\">说说 Spring AOP</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-AOP-实现原理/\">Spring AOP 实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-动态代理（CGLIB-与-JDK）/\">动态代理（CGLIB 与 JDK）</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-事务实现方式/\">Spring 事务实现方式</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-事务底层原理/\">Spring 事务底层原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何自定义注解实现功能/\">如何自定义注解实现功能</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-MVC-运行流程/\">Spring MVC 运行流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-MVC-启动流程/\">Spring MVC 启动流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-的单例实现原理/\">Spring 的单例实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-框架中用到了哪些设计模式/\">Spring 框架中用到了哪些设计模式</a></li> \n    <li>Spring 其他产品（Spring Boot、Spring Cloud、Spring Security、Spring Data、Spring AMQP 等）<br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-为什么选择-Netty/\">为什么选择 Netty</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说业务中-Netty-的使用场景/\">说说业务中 Netty 的使用场景</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-原生的-NIO-在-JDK-1-7-版本存在-EPoll-BUG/\">原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-什么是-TCP-粘包-拆包/\">什么是 TCP 粘包/拆包</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-TCP-粘包-拆包的解决办法/\">TCP 粘包/拆包的解决办法</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-线程模型/\">Netty 线程模型</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Netty-的零拷贝/\">说说 Netty 的零拷贝</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-内部执行流程/\">Netty 内部执行流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-重连实现/\">Netty 重连实现</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"微服务篇\"><a href=\"#微服务篇\" class=\"headerlink\" title=\"微服务篇\"></a>微服务篇</h3>\n <ul> \n  <li><h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-前后端分离是如何做的/\">前后端分离是如何做的</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何解决跨域/\">如何解决跨域</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-微服务哪些框架/\">微服务哪些框架</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RPC-框架/\">你怎么理解 RPC 框架</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-RPC-的实现原理/\">说说 RPC 的实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Dubbo-的实现原理/\">说说 Dubbo 的实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RESTful/\">你怎么理解 RESTful</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说如何设计一个良好的-API/\">说说如何设计一个良好的 API</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何理解-RESTful-API-的幂等性/\">如何理解 RESTful API 的幂等性</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何保证接口的幂等性/\">如何保证接口的幂等性</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-CAP-定理、-BASE-理论/\">说说 CAP 定理、 BASE 理论</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-怎么考虑数据一致性问题/\">怎么考虑数据一致性问题</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-说说最终一致性的实现方案/\">说说最终一致性的实现方案</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-你怎么看待微服务/\">你怎么看待微服务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务与-SOA-的区别/\">微服务与 SOA 的区别</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-如何拆分服务/\">如何拆分服务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务如何进行数据库管理/\">微服务如何进行数据库管理</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-如何应对微服务的链式调用异常/\">如何应对微服务的链式调用异常</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-对于快速追踪与定位问题/\">对于快速追踪与定位问题</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务的安全/\">微服务的安全</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h4>\n   <ul> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-谈谈业务中使用分布式的场景/\">谈谈业务中使用分布式的场景</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-Session-分布式方案/\">Session 分布式方案</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-分布式锁的场景/\">分布式锁的场景与实现</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-分布式事务/\">分布式事务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-集群与负载均衡的算法与实现/\">集群与负载均衡的算法与实现</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"安全篇\"><a href=\"#安全篇\" class=\"headerlink\" title=\"安全篇\"></a>安全篇</h3>\n <ul> \n  <li><a href=\"/2018/04/10/interview/Java-面试宝典-安全要素与-STRIDE-威胁/\">安全要素与 STRIDE 威胁</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-防范常见的-Web-攻击/\">防范常见的 Web 攻击</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-服务端通信安全攻防/\">服务端通信安全攻防</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-HTTPS-原理剖析/\">HTTPS 原理剖析</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-HTTPS-降级攻击/\">HTTPS 降级攻击</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-授权与认证/\">授权与认证</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-基于角色的访问控制/\">基于角色的访问控制</a></li> \n  <li>基于数据的访问控制</li> \n </ul> \n <h3 id=\"性能篇\"><a href=\"#性能篇\" class=\"headerlink\" title=\"性能篇\"></a>性能篇</h3>\n <ul> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-性能指标有哪些/\">性能指标有哪些</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-如何发现性能瓶颈/\">如何发现性能瓶颈</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-性能调优的常见手段/\">性能调优的常见手段</a></li> \n  <li>说说你在项目中如何进行性能调优</li> \n </ul> \n <h3 id=\"设计模式篇\"><a href=\"#设计模式篇\" class=\"headerlink\" title=\"设计模式篇\"></a>设计模式篇</h3>\n <ul> \n  <li>你项目中有使用哪些设计模式</li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-说说常用开源框架中设计模式使用分析/\">说说常用开源框架中设计模式使用分析</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-说说你对设计原则的理解/\">说说你对设计原则的理解</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-23-种设计模式的设计理念/\">23 种设计模式的设计理念</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-设计模式之间的异同，例如策略模式与状态模式的区别/\">设计模式之间的异同，例如策略模式与状态模式的区别</a></li> \n  <li><a href=\"/2018/04/12/interview/Java-面试宝典-设计模式之间的结合，例如策略模式-简单工厂模式的实践/\">设计模式之间的结合，例如策略模式 + 简单工厂模式的实践</a></li> \n  <li><a href=\"/2018/04/12/interview/Java-面试宝典-设计模式的性能，例如单例模式哪种性能更好/\">设计模式的性能，例如单例模式哪种性能更好</a></li> \n </ul> \n <h3 id=\"工程篇\"><a href=\"#工程篇\" class=\"headerlink\" title=\"工程篇\"></a>工程篇</h3>\n <ul> \n  <li><h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4>\n   <ul> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何对需求原型进行理解和拆分/\">你如何对需求原型进行理解和拆分</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你对功能性需求的理解/\">说说你对功能性需求的理解</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你对非功能性需求的理解/\">说说你对非功能性需求的理解</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你针对产品提出哪些交互和改进意见/\">你针对产品提出哪些交互和改进意见</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何理解用户痛点/\">你如何理解用户痛点</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"设计能力\"><a href=\"#设计能力\" class=\"headerlink\" title=\"设计能力\"></a>设计能力</h4>\n   <ul> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你在项目中使用过的-UML-图/\">说说你在项目中使用过的 UML 图</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何考虑组件化/\">你如何考虑组件化</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何考虑服务化/\">你如何考虑服务化</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何进行领域建模/\">你如何进行领域建模</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何划分领域边界/\">你如何划分领域边界</a></li> \n    <li>说说你项目中的领域建模</li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说概要设计/\">说说概要设计</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"业务工程\"><a href=\"#业务工程\" class=\"headerlink\" title=\"业务工程\"></a>业务工程</h3>\n <ul> \n  <li>你系统中的前后端分离是如何做的</li> \n  <li>说说你的开发流程</li> \n  <li>你和团队是如何沟通的</li> \n  <li>你如何进行代码评审</li> \n  <li>说说你对技术与业务的理解</li> \n  <li>说说你在项目中经常遇到的 Exception</li> \n  <li>说说你在项目中遇到感觉最难Bug，怎么解决的</li> \n  <li>说说你在项目中遇到印象最深困难，怎么解决的</li> \n  <li>你觉得你们项目还有哪些不足的地方</li> \n  <li>你是否遇到过 CPU 100%，如何排查与解决</li> \n  <li><a href=\"/2018/04/13/interview/Java-面试宝典-你是否遇到过内存-OOM，如何排查与解决/\">你是否遇到过内存 OOM，如何排查与解决</a></li> \n  <li>说说你对敏捷开发的实践</li> \n  <li>说说你对开发运维的实践</li> \n  <li>介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色<br><br><h3 id=\"软实力\"><a href=\"#软实力\" class=\"headerlink\" title=\"软实力\"></a>软实力</h3></li> \n  <li>说说你的亮点</li> \n  <li>说说你最近在看什么书</li> \n  <li>说说你觉得最有意义的技术书籍</li> \n  <li>说说个人发展方向方面的思考</li> \n  <li>说说你认为的服务端开发工程师应该具备哪些能力</li> \n  <li>说说你认为的架构师是什么样的，架构师主要做什么</li> \n  <li>说说你所理解的技术专家<br><br><h3 id=\"人力面\"><a href=\"#人力面\" class=\"headerlink\" title=\"人力面\"></a>人力面</h3></li> \n  <li>你为什么离开之前的公司</li> \n  <li>你为什么要进我们公司</li> \n  <li>说说职业规划</li> \n  <li>你如何看待加班问题</li> \n  <li>谈一谈你的一次失败经历</li> \n  <li>你觉得你最大的优点是什么</li> \n  <li>你觉得你最大的缺点是什么</li> \n  <li>你在工作之余做什么事情</li> \n  <li>你为什么认为你适合这个职位</li> \n  <li>你觉得自己那方面能力最急需提高</li> \n  <li>你来我们公司最希望得到什么</li> \n  <li>你希望从这份工作中获得什么</li> \n  <li>你对现在应聘的职位有什么了解</li> \n  <li>您还有什么想问的</li> \n  <li>你怎么看待自己的职涯</li> \n  <li>谈谈你的家庭情况</li> \n  <li>你有什么业余爱好</li> \n  <li>你计划在公司工作多久</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(50,12,'抽象类和接口有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>参数</th> \n    <th>抽象类</th> \n    <th>接口</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>默认的方法实现</td> \n    <td>它可以有默认的方法实现</td> \n    <td>接口完全是抽象的。它根本不存在方法的实现</td> \n   </tr> \n   <tr> \n    <td>实现</td> \n    <td>子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td> \n    <td>子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现</td> \n   </tr> \n   <tr> \n    <td>构造器</td> \n    <td>抽象类可以有构造器</td> \n    <td>接口不能有构造器</td> \n   </tr> \n   <tr> \n    <td>与正常 Java 类的区别</td> \n    <td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td> \n    <td>接口是完全不同的类型</td> \n   </tr> \n   <tr> \n    <td>访问修饰符</td> \n    <td>抽象方法可以有 public、protected 和 default 这些修饰符</td> \n    <td>接口方法默认修饰符是 public。你不可以使用其它修饰符。</td> \n   </tr> \n   <tr> \n    <td>main 方法</td> \n    <td>抽象方法可以有 main 方法并且我们可以运行它</td> \n    <td>接口没有 main 方法，因此我们不能运行它。</td> \n   </tr> \n   <tr> \n    <td>多继承</td> \n    <td>抽象方法可以继承一个类和实现多个接口</td> \n    <td>接口只可以继承一个或多个其它接口</td> \n   </tr> \n   <tr> \n    <td>速度</td> \n    <td>它比接口速度要快</td> \n    <td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td> \n   </tr> \n   <tr> \n    <td>添加新方法</td> \n    <td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td> \n    <td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(51,12,'int 和 Integer 有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。<br>int 的默认值为 <code>0</code>，而 Integer 的默认值为 <code>null</code>，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，<br>Java 中 int 和 Integer 关系是比较微妙的。关系如下：</p> \n <ul> \n  <li>int 是基本的数据类型；</li> \n  <li>Integer 是 int 的封装类；</li> \n  <li>int 和 Integer 都可以表示某一个数值；</li> \n  <li>int 和 Integer 不能够互用，因为他们两种不同的数据类型；</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(52,12,'面向对象的特征',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>面向对象的三个基本特征是：封装、继承、多态。</p> \n <h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3>\n <p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。<br>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p> \n <h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3>\n <p>面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p> \n <h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3>\n <p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(53,12,'final, finally, finalize 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3>\n <p>用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</p> \n <h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h3>\n <p>是异常处理语句结构的一部分，表示总是执行.</p> \n <h3 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize\"></a>finalize</h3>\n <p>是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</p> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(54,12,'重载和重写的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"重载-Overload\"><a href=\"#重载-Overload\" class=\"headerlink\" title=\"重载 Overload\"></a>重载 Overload</h3>\n <p>表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p> \n <h3 id=\"重写-Override\"><a href=\"#重写-Override\" class=\"headerlink\" title=\"重写 Override\"></a>重写 Override</h3>\n <p>表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(55,12,'说说自定义注解的场景及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>登陆、权限拦截、日志处理，以及各种 Java 框架，如 Spring，Hibernate，JUnit 提到注解就不能不说反射，Java 自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 JVM 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Class 数据流的处理我们即可得到字段、方法等数据。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(56,12,'说说反射的用途及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"反射的用途\"><a href=\"#反射的用途\" class=\"headerlink\" title=\"反射的用途\"></a>反射的用途</h3>\n <p>Java 反射机制是一个非常强大的功能，在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决 Java 泛型擦除等令人苦恼的问题。</p> \n <h3 id=\"反射的实现\"><a href=\"#反射的实现\" class=\"headerlink\" title=\"反射的实现\"></a>反射的实现</h3>\n <p>获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类</p> \n <ol> \n  <li>通过 <code>getClass()</code> 方法</li> \n  <li>通过 <code>Class.forName()</code> 方法</li> \n  <li>使用 <code>类.class</code></li> \n  <li>通过类加载器实现，<code>getClassLoader()</code></li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(57,12,'session 与 cookie 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li> \n  <li>cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li> \n  <li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li> \n  <li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(58,12,'HTTP 请求的 GET 与 POST 方式的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。</li> \n  <li>根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。</li> \n  <li>首先是 “GET 方式提交的数据最多只能是 1024 字节”，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</li> \n  <li>POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(59,12,'session 分布式处理',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Session-复制\"><a href=\"#Session-复制\" class=\"headerlink\" title=\"Session 复制\"></a>Session 复制</h3>\n <p>在支持 Session 复制的 Web 服务器上，通过修改 Web 服务器的配置，可以实现将 Session 同步到其它 Web 服务器上，达到每个 Web 服务器上都保存一致的 Session。</p> \n <ul> \n  <li>优点：代码上不需要做支持和修改。</li> \n  <li>缺点：需要依赖支持的 Web 服务器，一旦更换成不支持的 Web 服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。</li> \n  <li>适用场景：只适用于Web服务器比较少且 Session 数据量少的情况。</li> \n  <li>可用方案：开源方案 tomcat-redis-session-manager，暂不支持 Tomcat8。</li> \n </ul> \n <h3 id=\"Session-粘滞\"><a href=\"#Session-粘滞\" class=\"headerlink\" title=\"Session 粘滞\"></a>Session 粘滞</h3>\n <p>将用户的每次请求都通过某种方法强制分发到某一个 Web 服务器上，只要这个 Web 服务器上存储了对应 Session 数据，就可以实现会话跟踪。</p> \n <ul> \n  <li>优点：使用简单，没有额外开销。</li> \n  <li>缺点：一旦某个 Web 服务器重启或宕机，相对应的 Session 数据将会丢失，而且需要依赖负载均衡机制。</li> \n  <li>适用场景：对稳定性要求不是很高的业务情景。</li> \n </ul> \n <h3 id=\"Session-集中管理\"><a href=\"#Session-集中管理\" class=\"headerlink\" title=\"Session 集中管理\"></a>Session 集中管理</h3>\n <p>在单独的服务器或服务器集群上使用缓存技术，如 Redis 存储 Session 数据，集中管理所有的 Session，所有的Web服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。</p> \n <ul> \n  <li>优点：可靠性高，减少 Web 服务器的资源开销。</li> \n  <li>缺点：实现上有些复杂，配置较多。</li> \n  <li>适用场景：Web服务器较多、要求高可用性的情况。</li> \n  <li>可用方案：开源方案 Spring Session，也可以自己实现，主要是重写 HttpServletRequestWrapper 中的 getSession 方法。</li> \n </ul> \n <h3 id=\"基于-Cookie-管理\"><a href=\"#基于-Cookie-管理\" class=\"headerlink\" title=\"基于 Cookie 管理\"></a>基于 Cookie 管理</h3>\n <p>这种方式每次发起请求的时候都需要将 Session 数据放到 Cookie 中传递给服务端。</p> \n <ul> \n  <li>优点：不需要依赖额外外部存储，不需要额外配置。</li> \n  <li>缺点：不安全，易被盗取或篡改；Cookie 数量和长度有限制，需要消耗更多网络带宽。</li> \n  <li>适用场景：数据不重要、不敏感且数据量小的情况。</li> \n </ul> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>这四种方式，相对来说，<strong>Session 集中管理</strong> 更加可靠，使用也是最多的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:19','2018-12-19 15:45:19'),
(60,12,'MVC 设计思想',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。<br>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层：</p> \n <ul> \n  <li>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</li> \n  <li>最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</li> \n  <li>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(61,12,'JDBC 流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>向 DriverManager 类注册驱动数据库驱动程序</li> \n  <li>调用 DriverManager.getConnection 方法， 通过 JDBC URL，用户名，密码取得数据库连接的 Connection 对象。</li> \n  <li>获取 Connection 后， 便可以通过 createStatement 创建 Statement 用以执行 SQL 语句。</li> \n  <li>有时候会得到查询结果，比如 select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。</li> \n  <li>关闭数据库语句，关闭数据库连接。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(62,12,'equals 与 == 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><code>==</code> 与<code>equals</code> 的主要区别是：<code>==</code> 常用于比较原生类型，而 <code>equals()</code> 方法用于检查对象的相等性。</li> \n  <li>另一个不同的点是：如果 <code>==</code> 和 <code>equals()</code> 用于比较对象，当两个引用地址相同，<code>==</code> 返回 true。而 <code>equals()</code> 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 <code>==</code> 和 <code>equals()</code> 返回不同的结果。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(63,12,'List 和 Map 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>List 特点：元素有放入顺序，元素可重复;</li> \n  <li>Map 特点：元素按键值对存储，无放入顺序 ;</li> \n  <li>List 接口有三个实现类：LinkedList，ArrayList，Vector;</li> \n  <li>LinkedList：底层基于链表实现，链表内存是散乱的，每一个元素存储本身内存地址的同时还存储下一个元素的地址。链表增删快，查找慢;</li> \n  <li>Map 接口有三个实现类：HashMap，HashTable，LinkedHashMap</li> \n  <li>Map 相当于和 Collection 一个级别的；Map 集合存储键值对，且要求保持键的唯一性；</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(64,12,'ArrayList 与 Vector 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>同步性：Vector 是线程安全的，也就是说是同步的 ，而 ArrayList 是线程不安全的，不是同步的。</p> </li> \n  <li><p>数据增长：当需要增长时，Vector 默认增长为原来一倍 ，而 ArrayList 却是原来的 50% ，这样 ArrayList 就有利于节约内存空间。</p> </li> \n </ul> \n <p>说明：如果涉及到堆栈，队列等操作，应该考虑用 Vector，如果需要快速随机访问元素，应该使用 ArrayList</p> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(65,12,'List 和 Set 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>List, Set 都是继承自 Collection 接口</li> \n  <li>List 特点：元素有放入顺序，元素可重复。Set 特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在 set 中的位置是有该元素的 HashCode 决定的，其位置其实是固定的）</li> \n  <li>List 接口有三个实现类：LinkedList，ArrayList，Vector。Set 接口有两个实现类：HashSet(底层由 HashMap 实现)，LinkedHashSet</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(66,12,'HashMap 和 HashTable 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>HashMap 几乎可以等价于 HashTable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值 (value)，而 HashTable 则不行)。</li> \n  <li>HashMap 是非 synchronized，而 HashTable 是 synchronized，这意味着 HashTable 是线程安全的，多个线程可以共享一个 HashTable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。</li> \n  <li>另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 HashTable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。</li> \n  <li>由于 HashTable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 HashTable。</li> \n  <li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(67,12,'ArrayList 与 LinkedList 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>因为 Array 是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array 获取数据的时间复杂度是 <code>O(1)</code>,但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p> </li> \n  <li><p>相对于 ArrayList，LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 <code>O(n)</code>，而 LinkedList 中插入或删除的时间复杂度仅为 <code>O(1)</code>。ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。</p> </li> \n  <li><p>类似于插入数据，删除数据时，LinkedList 也优于 ArrayList。</p> </li> \n  <li><p>LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置。</p> </li> \n  <li><p>你的应用不会随机访问数据。因为如果你需要 LinkedList 中的第 n 个元素的时候，你需要从第一个元素顺序数到第 n 个数据，然后读取数据。</p> </li> \n  <li><p>你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比 ArrayList 要快。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:20','2018-12-19 15:45:20'),
(68,12,'创建线程的方式及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>继承 Thread 类创建线程类</p> \n   <ul> \n    <li>定义 Thread 类的子类，并重写该类的 <code>run</code> 方法，该 <code>run</code> 方法的方法体就代表了线程要完成的任务。因此把 <code>run()</code> 方法称为执行体。</li> \n    <li>创建 Thread 子类的实例，即创建了线程对象。</li> \n    <li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li> \n   </ul> </li> \n  <li><p>通过 Runnable 接口创建线程类</p> \n   <ul> \n    <li>定义 Runnable 接口的实现类，并重写该接口的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体同样是该线程的线程执行体。</li> \n    <li>创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。</li> \n    <li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li> \n   </ul> </li> \n  <li><p>通过 Callable 和 Future 创建线程</p> \n   <ul> \n    <li>创建 Callable 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li> \n    <li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 <code>call()</code> 方法的返回值。</li> \n    <li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li> \n    <li>调用 FutureTask 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值</li> \n   </ul> </li> \n  <li><p>采用实现 Runnable、Callable 接口的方式创见多线程时：</p> \n   <ul> \n    <li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li> \n    <li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</li> \n   </ul> </li> \n  <li><p>使用继承 Thread 类的方式创建多线程时：</p> \n   <ul> \n    <li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li> \n    <li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(69,12,'sleep() 、join（）、yield（）有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep()\"></a>sleep()</h3>\n <p><code>sleep()</code> 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 <code>sleep()</code> 方法不会释放“锁标志”，也就是说如果有 <code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。</p> \n <h3 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h3>\n <p><code>wait()</code> 方法需要和 <code>notify()</code> 及 <code>notifyAll()</code> 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 <code>synchronized</code> 语句块内使用，也就是说，调用 <code>wait()</code>，<code>notify()</code> 和 <code>notifyAll()</code> 的任务在调用这些方法前必须拥有对象的锁。注意，它们都是 <code>Object</code> 类的方法，而不是 <code>Thread</code> 类的方法。</p> \n <p><code>wait()</code> 方法与 <code>sleep()</code> 方法的不同之处在于，<code>wait()</code> 方法会释放对象的“锁标志”。当调用某一对象的 <code>wait()</code> 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 <code>notify()</code> 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 <code>notifyAll()</code> 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</p> \n <p>除了使用 <code>notify()</code> 和 <code>notifyAll()</code> 方法，还可以使用带毫秒参数的 <code>wait(long timeout)</code> 方法，效果是在延迟 timeout 毫秒后，被暂停的线程将被恢复到锁标志等待池。</p> \n <p>此外，<code>wait()</code>，<code>notify()</code> 及 <code>notifyAll()</code> 只能在 <code>synchronized</code> 语句中使用，但是如果使用的是 <code>ReenTrantLock</code> 实现同步，该如何达到这三个方法的效果呢？解决方法是使用 <code>ReenTrantLock.newCondition()</code> 获取一个 <code>Condition</code> 类对象，然后 <code>Condition</code> 的 <code>await()</code>，<code>signal()</code> 以及 <code>signalAll()</code> 分别对应上面的三个方法。</p> \n <h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a>yield()</h3>\n <p><code>yield()</code> 方法和 <code>sleep()</code> 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 <code>yield()</code> 方法只是使当前线程重新回到可执行状态，所以执行 <code>yield()</code> 的线程有可能在进入到可执行状态后马上又被执行，另外 <code>yield()</code> 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 <code>sleep()</code> 方法不同。</p> \n <h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3>\n <p><code>join()</code> 方法会使当前线程等待调用 <code>join()</code> 方法的线程结束后才能继续执行</p> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(70,12,'HashSet 和 HashMap 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>HashMap</th> \n    <th>HashSet</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>HashMap 实现了 Map 接口</td> \n    <td>HashSet 实现了 Set 接口</td> \n   </tr> \n   <tr> \n    <td>HashMap 储存键值对</td> \n    <td>HashSet 仅仅存储对象</td> \n   </tr> \n   <tr> \n    <td>使用 put() 方法将元素放入 map 中</td> \n    <td>使用 add() 方法将元素放入 set 中</td> \n   </tr> \n   <tr> \n    <td>HashMap 中使用键对象来计算 hashcode 值</td> \n    <td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals() 方法用来判断对象的相等性，如果两个对象不同的话，那么返回 false</td> \n   </tr> \n   <tr> \n    <td>HashMap 比较快，因为是使用唯一的键来获取对象</td> \n    <td>HashSet 较 HashMap 来说比较慢</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(71,12,'ConcurrentHashMap 的工作原理及代码实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(72,12,'HashMap 的工作原理及代码实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。HashMap 使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap 在每个链表节点中储存键值对对象。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(73,12,'HashMap 和 ConcurrentHashMap 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>放入 HashMap 的元素是 key-value 对。</li> \n  <li>底层说白了就是散列结构。</li> \n  <li>要将元素放入到 HashMap 中，那么 key 的类型必须要实现实现 hashcode 方法，默认这个方法是根据对象的地址来计算的，接着还必须覆盖对象的 equals() 方法。</li> \n  <li>ConcurrentHashMap 对整个桶数组进行了分段，而 HashMap 则没有</li> \n  <li>ConcurrentHashMap 在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而 HashMap 没有锁机制，不是线程安全的</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(74,12,'说说 CountDownLatch 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CountDownLatch 内部维护了一个整数 <code>n</code>，n（要大于等于0）在 <strong>当前线程</strong> 初始化 <code>CountDownLatch</code> 方法指定。当前线程调用 <code>CountDownLatch</code> 的 <code>await()</code> 方法阻塞当前线程，等待其他调用 <code>CountDownLatch</code> 对象的 <code>CountDown()</code> 方法的线程执行完毕。 其他线程调用该 <code>CountDownLatch</code> 的 <code>CountDown()</code> 方法，该方法会把 <code>n-1</code>，直到所有线程执行完成，<code>n</code> 等于 <code>0</code>，<strong>当前线程</strong> 就恢复执行。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(75,12,'说说 Semaphore 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p><code>Semaphore</code> 直译为信号。实际上 <code>Semaphore</code> 可以看做是一个信号的集合。不同的线程能够从 <code>Semaphore</code> 中获取若干个信号量。当 <code>Semaphore</code> 对象持有的信号量不足时，尝试从 <code>Semaphore</code> 中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:21','2018-12-19 15:45:21'),
(76,12,'说说 CyclicBarrier 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p><code>CyclicBarrier</code> 是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(CommonBarrierPoint)。因为该 <code>barrier</code> 在释放等待线程后可以重用,所以称它为循环的 <code>barrier</code>。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(77,12,'线程池的几种方式与使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 <code>Executors</code> 类里面提供了一些静态工厂，生成一些常用的线程池。</p> \n <ol> \n  <li><code>newFixedThreadPool</code>：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li> \n  <li><code>newCachedThreadPool</code>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li> \n  <li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li> \n  <li><code>newScheduledThreadPool</code>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li> \n  <li><code>newSingleThreadScheduledExecutor</code>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(78,12,'讲讲线程池的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当提交一个新任务到线程池时，线程池的处理流程如下：</p> \n <ol> \n  <li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li> \n  <li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li> \n  <li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(79,12,'说说 Exchanger 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当一个线程到达 <code>exchange</code> 调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(80,12,'线程的生命周期',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)5种状态</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(81,12,'说说 CountDownLatch 与 CyclicBarrier 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>CountDownLatch 的作用是允许 <code>1</code> 或 <code>N</code> 个线程等待其他线程完成执行;而 CyclicBarrier 则是允许 <code>N</code> 个线程相互等待。</li> \n  <li>CountDownLatch 的计数器无法被重置; CyclicBarrier 的计数器可以被重置后使用,因此它被称为是循环的 barrier。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(82,12,'synchronize 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>同步代码块是使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，同步方法（在这看不出来需要看 JVM 底层实现）依靠的是方法修饰符上的 <code>ACC_SYNCHRONIZED</code> 实现。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(83,12,'ThreadLocal 原理分析',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(84,12,'ABA 问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CAS 会导致“ABA问题”。</p> \n <p>CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p> \n <p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</p> \n <p>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:22','2018-12-19 15:45:22'),
(85,12,'说说线程安全问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。</p> \n <p>在 Java 多线程编程当中，提供了多种实现 Java 线程安全的方式：</p> \n <ul> \n  <li>最简单的方式，使用 <code>Synchronization</code> 关键字</li> \n  <li>使用 <code>java.util.concurrent.atomic</code> 包中的原子类，例如 <code>AtomicInteger</code></li> \n  <li>使用 <code>java.util.concurrent.locks</code> 包中的锁</li> \n  <li>使用线程安全的集合 <code>ConcurrentHashMap</code></li> \n  <li>使用 <code>volatile</code> 关键字，保证变量可见性（直接从内存读，而不是从线程 <code>cache</code> 读）</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(86,12,'synchronized 与 lock 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>synchronized 和 lock 的用法区别</p> \n   <ul> \n    <li>synchronized(隐式锁)：在需要同步的对象中加入此控制，<code>synchronized</code> 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</li> \n    <li>lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 <code>ReentrantLock</code> 类做为锁，多个线程中必须要使用一个 <code>ReentrantLock</code> 类做为对象才能保证锁的生效。且在加锁和解锁处需要通过 <code>lock()</code> 和 <code>unlock()</code> 显示指出。所以一般会在 <code>finally</code> 块中写 <code>unlock()</code> 以防死锁。</li> \n   </ul> </li> \n  <li><p>synchronized 和 lock 性能区别<br><code>synchronized</code> 是托管给 JVM 执行的，而 <code>lock</code> 是 Java 写的控制锁的代码。在 <strong>JDK 1.5</strong> 中，<code>synchronize</code> 是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用 Java 提供的 <code>Lock</code> 对象，性能更高一些。但是到了 <strong>JDK 1.6</strong>，发生了变化。<code>synchronize</code> 在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在 <strong>JDK 1.6</strong> 上 <code>synchronize</code> 的性能并不比 <code>Lock</code> 差。</p> </li> \n  <li><p>synchronized 和 lock 机制区别</p> \n   <ul> \n    <li><code>synchronized</code> 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。</li> \n    <li><code>Lock</code> 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(87,12,'volatile 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>在 JVM 底层 volatile 是采用“内存屏障”来实现的</li> \n  <li>缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个 CPU 在写数据时，如果发现操作的变量是共享变量，则会通知其他 CPU 告知该变量的缓存行是无效的，因此其他 CPU 在读取该变量时，发现其无效会重新从主存中加载数据</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(88,12,'乐观锁的业务场景及实现方式',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>乐观锁（Optimistic Lock）：</p> \n <ul> \n  <li>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</li> \n  <li>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(89,12,'CAS 乐观锁',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CAS 是项乐观锁技术，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p> \n <p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查 + 数据更新的原理是一样的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(90,12,'分库与分表带来的分布式困境与应对之策',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"数据迁移与扩容问题\"><a href=\"#数据迁移与扩容问题\" class=\"headerlink\" title=\"数据迁移与扩容问题\"></a>数据迁移与扩容问题</h3>\n <p>前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。</p> \n <p>针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</p> \n <h3 id=\"表关联问题\"><a href=\"#表关联问题\" class=\"headerlink\" title=\"表关联问题\"></a>表关联问题</h3>\n <p>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。</p> \n <h3 id=\"分页与排序问题\"><a href=\"#分页与排序问题\" class=\"headerlink\" title=\"分页与排序问题\"></a>分页与排序问题</h3>\n <p>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p> \n <h3 id=\"分布式事务问题\"><a href=\"#分布式事务问题\" class=\"headerlink\" title=\"分布式事务问题\"></a>分布式事务问题</h3>\n <p>随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。</p> \n <h3 id=\"分布式全局唯一ID\"><a href=\"#分布式全局唯一ID\" class=\"headerlink\" title=\"分布式全局唯一ID\"></a>分布式全局唯一ID</h3>\n <p>在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(91,12,'说说分库与分表设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a>垂直分表</h3>\n <p>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。</p> \n <h3 id=\"垂直分库\"><a href=\"#垂直分库\" class=\"headerlink\" title=\"垂直分库\"></a>垂直分库</h3>\n <p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。</p> \n <p>众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p> \n <h3 id=\"水平分表\"><a href=\"#水平分表\" class=\"headerlink\" title=\"水平分表\"></a>水平分表</h3>\n <p>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。</p> \n <h3 id=\"水平分库\"><a href=\"#水平分库\" class=\"headerlink\" title=\"水平分库\"></a>水平分库</h3>\n <p>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p> \n <h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3>\n <p>很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(92,12,'MySQL 索引使用的注意事项',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>索引不会包含有 <code>NULL</code> 的列<br>只要列中包含有 <code>NULL</code> 值，都将不会被包含在索引中，复合索引中只要有一列含有 <code>NULL</code> 值，那么这一列对于此符合索引就是无效的。</p> </li> \n  <li><p>使用短索引<br>对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个 <code>char（255）</code> 的列，如果在前 <code>10</code> 个或 <code>20</code> 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 <code>I/O</code> 操作。</p> </li> \n  <li><p>索引列排序<br>MySql 查询只使用一个索引，因此如果 <code>where</code> 子句中已经使用了索引的话，那么 <code>order by</code> 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</p> </li> \n  <li><p><code>like</code> 语句操作<br>一般情况下不鼓励使用 <code>like</code> 操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code> 不会使用索引，而 <code>like ‘aaa%’</code> 可以使用索引。</p> </li> \n  <li><p>不要在列上进行运算</p> </li> \n  <li><p>不使用 <code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但 <code>&lt;</code> , <code>&lt;=</code> ，<code>=</code> ，<code>&gt;</code> , <code>&gt;=</code> , <code>BETWEEN</code> , <code>IN</code> 是可以用到索引的</p> </li> \n  <li><p>索引要建立在经常进行select操作的字段上<br>这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p> </li> \n  <li><p>索引要建立在值比较唯一的字段上</p> </li> \n  <li><p>对于那些定义为 <code>text</code>、<code>image</code> 和 <code>bit</code> 数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</p> </li> \n  <li><p>在 <code>where</code> 和 <code>join</code> 中出现的列需要建立索引</p> </li> \n  <li><p><code>where</code> 的查询条件里有不等号 <code>(where column != …)</code> , MySql 将无法使用索引</p> </li> \n  <li><p>如果 <code>where</code> 字句的查询条件里使用了函数(如：<code>where DAY(column)=…)</code>, MySql 将无法使用索引</p> </li> \n  <li><p>在 <code>join</code> 操作中(需要从多个数据表提取数据时)，MySql 只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:23','2018-12-19 15:45:23'),
(93,12,'58 到家 MySQL 军规升级版',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"基础规范\"><a href=\"#基础规范\" class=\"headerlink\" title=\"基础规范\"></a>基础规范</h3>\n <ul> \n  <li>表存储引擎必须使用 <code>InnoDB</code></li> \n  <li>表字符集默认使用 <code>utf8</code>，必要时候使用 <code>utf8mb4</code>\n   <ul> \n    <li>通用，无乱码风险，汉字 3 字节，英文 1 字节</li> \n    <li><code>utf8mb4</code> 是 <code>utf8</code> 的超集，有存储 4 字节例如表情符号时，使用它</li> \n   </ul> </li> \n  <li>禁止使用存储过程，视图，触发器，Event\n   <ul> \n    <li>对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层</li> \n    <li>调试，排错，迁移都比较困难，扩展性较差</li> \n   </ul> </li> \n  <li>禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径</li> \n  <li>禁止在线上环境做数据库压力测试</li> \n  <li>测试，开发，线上数据库环境必须隔离</li> \n </ul> \n <h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3>\n <ul> \n  <li>库名，表名，列名必须用小写，采用下划线分隔\n   <ul> \n    <li>abc，Abc，ABC 都是给自己埋坑</li> \n   </ul> </li> \n  <li>库名，表名，列名必须见名知义，长度不要超过 32 字符\n   <ul> \n    <li>tmp，wushan 谁 TM 知道这些库是干嘛的</li> \n   </ul> </li> \n  <li>库备份必须以 bak 为前缀，以日期为后缀</li> \n  <li>从库必须以 <code>-s</code> 为后缀</li> \n  <li>备库必须以 <code>-ss</code> 为后缀</li> \n </ul> \n <h3 id=\"表设计规范\"><a href=\"#表设计规范\" class=\"headerlink\" title=\"表设计规范\"></a>表设计规范</h3>\n <ul> \n  <li>单实例表个数必须控制在 <code>2000</code> 个以内</li> \n  <li>单表分表个数必须控制在 <code>1024</code> 个以内</li> \n  <li>表必须有主键，推荐使用 <code>UNSIGNED</code> 整数为主键\n   <ul> \n    <li>删除无主键的表，如果是 <code>row</code> 模式的主从架构，从库会挂住</li> \n   </ul> </li> \n  <li>禁止使用外键，如果要保证完整性，应由应用程式实现\n   <ul> \n    <li>外键使得表之间相互耦合，影响 <code>update/delete</code> 等 SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈</li> \n   </ul> </li> \n  <li>建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据（具体参考：<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959773&amp;idx=1&amp;sn=7e4ad0dcd050f6662dfaf39d9de36f2c&amp;chksm=bd2d04018a5a8d17b92098b4840aac23982e32d179cdd957e4c55011f6a08f6bd31f9ba5cfee&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《如何实施数据库垂直拆分》</a>）</li> \n </ul> \n <h3 id=\"列设计规范\"><a href=\"#列设计规范\" class=\"headerlink\" title=\"列设计规范\"></a>列设计规范</h3>\n <ul> \n  <li>根据业务区分使用 <code>tinyint/int/bigint</code>，分别会占用 <code>1/4/8</code> 字节</li> \n  <li>根据业务区分使用 <code>char/varchar</code>\n   <ul> \n    <li>字段长度固定，或者长度近似的业务场景，适合使用 <code>char</code>，能够减少碎片，查询性能高</li> \n    <li>字段长度相差较大，或者更新较少的业务场景，适合使用 <code>varchar</code>，能够减少空间</li> \n   </ul> </li> \n  <li>根据业务区分使用 <code>datetime/timestamp</code>\n   <ul> \n    <li>前者占用 5 个字节，后者占用 4 个字节，存储年使用 <code>YEAR</code>，存储日期使用 <code>DATE</code>，存储时间使用 <code>datetime</code></li> \n   </ul> </li> \n  <li>必须把字段定义为 <code>NOT NULL</code> 并设默认值\n   <ul> \n    <li>NULL 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化</li> \n    <li>NULL 需要更多的存储空间</li> \n    <li>NULL 只能采用 <code>IS NULL</code> 或者 <code>IS NOT NULL</code> ，而在 <code>=/!=/in/not in</code> 时有大坑</li> \n   </ul> </li> \n  <li>使用 <code>INT UNSIGNED</code> 存储 <code>IPv4</code> ，不要用 <code>char(15)</code></li> \n  <li>使用 <code>varchar(20)</code> 存储手机号，不要使用整数\n   <ul> \n    <li>牵扯到国家代号，可能出现 <code>+/-/()</code> 等字符，例如 <code>+86</code></li> \n    <li>手机号不会用来做数学运算</li> \n    <li><code>varchar</code> 可以模糊查询，例如 <code>like‘138%’</code></li> \n   </ul> </li> \n  <li>使用 <code>TINYINT</code> 来代替 <code>ENUM</code>\n   <ul> \n    <li><code>ENUM</code> 增加新值要进行 <code>DDL</code> 操作</li> \n   </ul> </li> \n </ul> \n <h3 id=\"索引规范\"><a href=\"#索引规范\" class=\"headerlink\" title=\"索引规范\"></a>索引规范</h3>\n <ul> \n  <li>唯一索引使用 <code>uniq_[字段名]</code> 来命名</li> \n  <li>非唯一索引使用 <code>idx_[字段名]</code> 来命名</li> \n  <li>单张表索引数量建议控制在 5 个以内\n   <ul> \n    <li>互联网高并发业务，太多索引会影响写性能</li> \n    <li>生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引</li> \n    <li>异常复杂的查询需求，可以选择 <code>ES</code> 等更为适合的方式存储</li> \n   </ul> </li> \n  <li>组合索引字段数不建议超过 5 个\n   <ul> \n    <li>如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题</li> \n   </ul> </li> \n  <li>不建议在频繁更新的字段上建立索引</li> \n  <li>非必要不要进行 <code>JOIN</code> 查询，如果要进行 <code>JOIN</code> 查询，被 <code>JOIN</code> 的字段必须类型相同，并建立索引\n   <ul> \n    <li>踩过因为 <code>JOIN</code> 字段类型不一致，而导致全表扫描的坑么？</li> \n   </ul> </li> \n  <li>理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</li> \n </ul> \n <h3 id=\"SQL-规范\"><a href=\"#SQL-规范\" class=\"headerlink\" title=\"SQL 规范\"></a>SQL 规范</h3>\n <ul> \n  <li>禁止使用 <code>select *</code>，只获取必要字段\n   <ul> \n    <li><code>select *</code> 会增加 <code>cpu/io/内存/带宽</code> 的消耗</li> \n    <li>指定字段能有效利用索引覆盖</li> \n    <li>指定字段查询，在表结构变更时，能保证对应用程序无影响</li> \n   </ul> </li> \n  <li><code>insert</code> 必须指定字段，禁止使用 <code>insert into T values()</code>\n   <ul> \n    <li>指定字段插入，在表结构变更时，能保证对应用程序无影响</li> \n   </ul> </li> \n  <li>隐式类型转换会使索引失效，导致全表扫描</li> \n  <li>禁止在 <code>where</code> 条件列使用函数或者表达式\n   <ul> \n    <li>导致不能命中索引，全表扫描</li> \n   </ul> </li> \n  <li>禁止负向查询以及 <code>%</code> 开头的模糊查询\n   <ul> \n    <li>导致不能命中索引，全表扫描</li> \n   </ul> </li> \n  <li>禁止大表 <code>JOIN</code> 和子查询</li> \n  <li>同一个字段上的 <code>OR</code> 必须改写问 <code>IN</code>，<code>IN</code> 的值必须少于 50 个</li> \n  <li>应用程序必须捕获 SQL 异常\n   <ul> \n    <li>方便定位线上问题</li> \n   </ul> </li> \n </ul> \n <h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3>\n <p>本军规适用于并发量大，数据量大的典型互联网业务，可直接带走参考，不谢。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(94,12,'MySQL 遇到的死锁问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>产生死锁的四个必要条件：</p> \n <ul> \n  <li>互斥条件：一个资源每次只能被一个进程使用。</li> \n  <li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li> \n  <li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li> \n  <li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li> \n </ul> \n <p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。<br>下列方法有助于最大限度地降低死锁：</p> \n <ul> \n  <li>按同一顺序访问对象。</li> \n  <li>避免事务中的用户交互。</li> \n  <li>保持事务简短并在一个批处理中。</li> \n  <li>使用低隔离级别。</li> \n  <li>使用绑定连接。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(95,12,'数据库索引的原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 <strong>BTree</strong> 及其变种 <strong>B+Tree</strong>。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(96,12,'存储引擎的 InnoDB 与 MyiSAM',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>InnoDB 不支持 <code>FULLTEXT</code> 类型的索引。</li> \n  <li>InnoDB 中不保存表的具体行数，也就是说，执行 <code>select count() from table</code> 时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 <code>count()</code> 语句包含 <code>where</code> 条件时，两种表的操作是一样的。</li> \n  <li>对于 <code>AUTO_INCREMENT</code> 类型的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中，可以和其他字段一起建立联合索引。</li> \n  <li><code>DELETE FROM table</code> 时，InnoDB 不会重新建立表，而是一行一行的删除。</li> \n  <li><code>LOAD TABLE FROM MASTER</code> 操作对 InnoDB 是不起作用的，解决方法是首先把 InnoDB 表改成 MyISAM 表，导入数据后再改成 InnoDB 表，但是对于使用的额外的 InnoDB 特性(例如外键)的表不适用。</li> \n </ol> \n <p>另外，InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表，例如 <code>update table set num=1 where name like “%aaa%”</code></p> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(97,12,'说说 SQL 优化之道',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"一些常见的-SQL-实践\"><a href=\"#一些常见的-SQL-实践\" class=\"headerlink\" title=\"一些常见的 SQL 实践\"></a>一些常见的 SQL 实践</h3>\n <ul> \n  <li>负向条件查询不能使用索引</li> \n </ul> \n <pre><code>select from order where status!=0 and status!=1\n</code></pre>\n <pre><code>not in/not exists # 都不是好习惯\n</code></pre>\n <p>可以优化为 <code>in</code> 查询：</p> \n <pre><code>select from order where status in(2,3)\n</code></pre>\n <ul> \n  <li>前导模糊查询不能使用索引<pre><code>select from order where desc like \'%XX\'\n</code></pre></li> \n </ul> \n <p>而非前导模糊查询则可以：</p> \n <pre><code>select from order where desc like \'XX%\'\n</code></pre>\n <ul> \n  <li>数据区分度不大的字段不宜使用索引<pre><code>select from user where sex=1\n</code></pre></li> \n </ul> \n <p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。</p> \n <p>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p> \n <ul> \n  <li>在属性上进行计算不能命中索引<pre><code>select from order where YEAR(date) &lt; = \'2017\'\n</code></pre></li> \n </ul> \n <p>即使date上建立了索引，也会全表扫描，可优化为值计算：</p> \n <pre><code>select from order where date &lt; = CURDATE()\n</code></pre>\n <p>或者：</p> \n <pre><code>select from order where date &lt; = \'2017-01-01\'\n</code></pre>\n <h3 id=\"并非周知的-SQL-实践\"><a href=\"#并非周知的-SQL-实践\" class=\"headerlink\" title=\"并非周知的 SQL 实践\"></a>并非周知的 SQL 实践</h3>\n <ul> \n  <li>如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心<pre><code>select from user where uid=?\nselect from user where login_name=?\n</code></pre></li> \n </ul> \n <p>原因：<code>B-Tree</code> 索引的时间复杂度是 <code>O(log(n))</code>；<code>Hash</code> 索引的时间复杂度是 <code>O(1)</code></p> \n <ul> \n  <li>允许为 <code>null</code> 的列，查询有潜在大坑</li> \n </ul> \n <p>单列索引不存 <code>null</code> 值，复合索引不存全为 <code>null</code> 的值，如果列允许为 <code>null</code>，可能会得到“不符合预期”的结果集</p> \n <pre><code>select from user where name != \'shenjian\'\n</code></pre>\n <p>如果 <code>name</code> 允许为 <code>null</code>，索引不存储 <code>null</code> 值，结果集中不会包含这些记录。所以，请使用 <code>not null</code> 约束以及默认值。</p> \n <ul> \n  <li>复合索引最左前缀，并不是值 SQL 语句的 <code>where</code> 顺序要和复合索引一致</li> \n </ul> \n <p>用户中心建立了(login_name, passwd)的复合索引</p> \n <pre><code>select from user where login_name=? and passwd=?\nselect from user where passwd=? and login_name=?\n</code></pre>\n <p>都能够命中索引</p> \n <pre><code>select from user where login_name=?\n</code></pre>\n <p>也能命中索引，满足复合索引最左前缀</p> \n <pre><code>select from user where passwd=?\n</code></pre>\n <p>不能命中索引，不满足复合索引最左前缀</p> \n <ul> \n  <li>使用 <code>ENUM</code> 而不是字符串</li> \n </ul> \n <p><code>ENUM</code> 保存的是 <code>TINYINT</code>，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</p> \n <h3 id=\"小众但有用的-SQL-实践\"><a href=\"#小众但有用的-SQL-实践\" class=\"headerlink\" title=\"小众但有用的 SQL 实践\"></a>小众但有用的 SQL 实践</h3>\n <ul> \n  <li>如果明确知道只有一条结果返回，<code>limit 1</code> 能够提高效率</li> \n </ul> \n <pre><code>select from user where login_name=?\n</code></pre>\n <p>可以优化为：</p> \n <pre><code>select from user where login_name=? limit 1\n</code></pre>\n <p>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p> \n <ul> \n  <li>把计算放到业务层而不是数据库层，除了节省数据的 CPU，还有意想不到的查询缓存优化效果</li> \n </ul> \n <pre><code>select from order where date &lt; = CURDATE()\n</code></pre>\n <p>这不是一个好的SQL实践，应该优化为：</p> \n <pre><code>$curDate = date(\'Y-m-d\');\n$res = mysqlquery(\'select from order where date &lt; = $curDate\');\n</code></pre>\n <p>原因：释放了数据库的 CPU，多次调用，传入的SQL相同，才可以利用查询缓存</p> \n <ul> \n  <li>强制类型转换会全表扫描</li> \n </ul> \n <pre><code>select from user where phone=13800001234\n</code></pre>\n <p>你以为会命中 phone 索引么？大错特错了，这个语句究竟要怎么改？</p> \n <p>末了，再加一条，不要使用 <code>select *（潜台词，文章的 SQL 都不合格 ==）</code>，只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(98,12,'为什么要用 B-Tree',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(99,12,'聚集索引与非聚集索引的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</li> \n  <li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li> \n  <li>聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序</li> \n  <li>非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.</li> \n  <li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:24','2018-12-19 15:45:24'),
(100,12,'limit 20000 加载很慢怎么解决',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MySQL 的性能低是因为数据库要去扫描 <code>N + M</code> 条记录，然后又要放弃之前 <code>N</code> 条记录，开销很大</p> \n <p>解决思路：</p> \n <ul> \n  <li>前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用 es 等进行搜索</li> \n  <li>使用延迟关联，即先通用 limit 得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据</li> \n </ul> \n <pre><code>select a.* from a,(select id from table_1 where is_deleted=\'N\' limit 100000,20) b where a.id = b.id\n</code></pre>\n <ul> \n  <li>从业务上实现，不分页如此多，例如只能分页前 100 页，后面的不允许再查了</li> \n  <li>不使用 limit N,M, 而是使用 limit N，即将 offset 转化为 where 条件。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(101,12,'ObjectId 规则',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>时间戳</th> \n    <th>机器码</th> \n    <th>PID</th> \n    <th>计数器</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>0,1,2,3</td> \n    <td>4,5,6</td> \n    <td>7,8</td> \n    <td>9,10,11</td> \n   </tr> \n  </tbody> \n </table> \n <ul> \n  <li>前四位是时间戳，可以提供秒级别的唯一性。</li> \n  <li>接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。</li> \n  <li>接下来两位是产生 ObjectId 的 PID，确保同一台机器上并发产生的 ObjectId 是唯一的。</li> \n  <li>前九位保证了同一秒钟不同机器的不同进程产生的 ObjectId 时唯一的。</li> \n  <li>最后三位是自增计数器，确保相同进程同一秒钟产生的 ObjectId 是唯一的。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(102,12,'说说反模式设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(103,12,'选择合适的数据存储方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"关系型数据库-MySQL\"><a href=\"#关系型数据库-MySQL\" class=\"headerlink\" title=\"关系型数据库 MySQL\"></a>关系型数据库 MySQL</h3>\n <p>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。</p> \n <h3 id=\"内存数据库-Redis\"><a href=\"#内存数据库-Redis\" class=\"headerlink\" title=\"内存数据库 Redis\"></a>内存数据库 Redis</h3>\n <p>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。</p> \n <p>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。</p> \n <p>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p> \n <h3 id=\"文档数据库-MongoDB\"><a href=\"#文档数据库-MongoDB\" class=\"headerlink\" title=\"文档数据库 MongoDB\"></a>文档数据库 MongoDB</h3>\n <p>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</p> \n <p>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p> \n <p>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。</p> \n <h3 id=\"列族数据库-HBase\"><a href=\"#列族数据库-HBase\" class=\"headerlink\" title=\"列族数据库 HBase\"></a>列族数据库 HBase</h3>\n <p>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。</p> \n <h3 id=\"全文搜索引擎-ElasticSearch\"><a href=\"#全文搜索引擎-ElasticSearch\" class=\"headerlink\" title=\"全文搜索引擎 ElasticSearch\"></a>全文搜索引擎 ElasticSearch</h3>\n <p>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p> \n <p>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。<strong>著名的 ELK 日志处理方案，由 ElasticSearch、LogStash 和 KibAna 三个组件组成</strong>，包括了日志收集、聚合、多维度查询、可视化显示等。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(104,12,'选择合适的分布式主键方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>数据库自增长序列或字段</li> \n  <li>UUID</li> \n  <li><strong>使用 UUID to Int64 的方法</strong></li> \n  <li><strong>Redis 生成 ID</strong></li> \n  <li><strong>Twitter 的 snowflake 算法</strong></li> \n  <li><strong>利用 zookeeper 生成唯一 ID</strong></li> \n  <li>MongoDB 的 ObjectId</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(105,12,'聊聊 MongoDB 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"高伸缩性的场景\"><a href=\"#高伸缩性的场景\" class=\"headerlink\" title=\"高伸缩性的场景\"></a>高伸缩性的场景</h3>\n <p>MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</p> \n <h3 id=\"日志系统的场景\"><a href=\"#日志系统的场景\" class=\"headerlink\" title=\"日志系统的场景\"></a>日志系统的场景</h3>\n <p>日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p> \n <h3 id=\"分布式文件存储\"><a href=\"#分布式文件存储\" class=\"headerlink\" title=\"分布式文件存储\"></a>分布式文件存储</h3>\n <p>MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(106,12,'Redis 有哪些类型',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 Redis 中有五种数据类型</p> \n <ul> \n  <li>String：字符串</li> \n  <li>Hash：字典</li> \n  <li>List：列表</li> \n  <li>Set：集合</li> \n  <li>Sorted Set：有序集合</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(107,12,'聊聊 ElasticSearch 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。</p> </li> \n  <li><p>数据库，挺奇葩的用法，因为 ES 存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式 P2P 扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。</p> </li> \n  <li><p>在线统计分析引擎，日志系统，LogStash，不用解释了吧; 可以实时动态分析数据，很是爽。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:25','2018-12-19 15:45:25'),
(108,12,'Redis 内部结构',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p> \n <ul> \n  <li>type ：代表一个 value 对象具体是何种数据类型。</li> \n  <li>encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。</li> \n  <li>vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(109,12,'聊聊 Redis 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>缓存</li> \n  <li>会话缓存</li> \n  <li>时效性</li> \n  <li>访问频率</li> \n  <li>计数器</li> \n  <li>社交列表</li> \n  <li>记录用户判定信息</li> \n  <li>交集、并集和差集</li> \n  <li>热门列表与排行榜</li> \n  <li>最新动态</li> \n  <li>消息队列</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(110,12,'Redis 集群方案与实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>客户端分片</li> \n  <li>基于代理的分片</li> \n  <li>路由查询</li> \n  <li>客户端分片</li> \n  <li>由客户端决定 key 写入或者读取的节点</li> \n  <li>包括 Jedis 在内的一些客户端，实现了客户端分片机制</li> \n </ul> \n <h3 id=\"路由查询\"><a href=\"#路由查询\" class=\"headerlink\" title=\"路由查询\"></a>路由查询</h3>\n <p>将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p> \n <h3 id=\"开源方案\"><a href=\"#开源方案\" class=\"headerlink\" title=\"开源方案\"></a>开源方案</h3>\n <p>Sentinel</p> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(111,12,'Redis 为什么是单线程的',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>因为 CPU 不是 Redis 的瓶颈。Redis 的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方 FAQ）既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(112,12,'缓存崩溃',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p> </li> \n  <li><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间 key 是锁着的，这时过来 1000 个请求 999 个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(113,12,'Redis 持久化机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 有两种持久化机制：</p> \n <h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3>\n <p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照</p> \n <h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3>\n <p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存</p> \n <p>Redis 的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(114,12,'缓存降级',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"页面降级\"><a href=\"#页面降级\" class=\"headerlink\" title=\"页面降级\"></a>页面降级</h3>\n <p>在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；</p> \n <h3 id=\"页面片段降级\"><a href=\"#页面片段降级\" class=\"headerlink\" title=\"页面片段降级\"></a>页面片段降级</h3>\n <p>比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；</p> \n <h3 id=\"页面异步请求降级\"><a href=\"#页面异步请求降级\" class=\"headerlink\" title=\"页面异步请求降级\"></a>页面异步请求降级</h3>\n <p>比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</p> \n <h3 id=\"服务功能降级\"><a href=\"#服务功能降级\" class=\"headerlink\" title=\"服务功能降级\"></a>服务功能降级</h3>\n <p>比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；</p> \n <h3 id=\"读降级\"><a href=\"#读降级\" class=\"headerlink\" title=\"读降级\"></a>读降级</h3>\n <p>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；</p> \n <h3 id=\"写降级\"><a href=\"#写降级\" class=\"headerlink\" title=\"写降级\"></a>写降级</h3>\n <p>比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</p> \n <h3 id=\"爬虫降级\"><a href=\"#爬虫降级\" class=\"headerlink\" title=\"爬虫降级\"></a>爬虫降级</h3>\n <p>在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。</p> \n <h3 id=\"自动开关降级\"><a href=\"#自动开关降级\" class=\"headerlink\" title=\"自动开关降级\"></a>自动开关降级</h3>\n <p>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。</p> \n <h3 id=\"超时降级\"><a href=\"#超时降级\" class=\"headerlink\" title=\"超时降级\"></a>超时降级</h3>\n <p>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(115,12,'消息的重发补偿解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>可靠消息服务定时查询状态为已发送并超时的消息</li> \n  <li>可靠消息将消息重新投递到 MQ 组件中</li> \n  <li>下游应用监听消息，在满足幂等性的条件下，重新执行业务。</li> \n  <li>下游应用通知可靠消息服务该消息已经成功消费。</li> \n  <li>通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(116,12,'倒排索引',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。</p> \n <p>有两种不同的反向索引形式：</p> \n <ul> \n  <li><p>一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。</p> </li> \n  <li><p>一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(117,12,'使用缓存的合理性问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>热点数据，缓存才有价值</li> \n  <li>频繁修改的数据，看情况考虑使用缓存</li> \n  <li>数据不一致性</li> \n  <li>缓存更新机制</li> \n  <li>缓存可用性</li> \n  <li>缓存服务降级</li> \n  <li>缓存预热</li> \n  <li>缓存穿透</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:26','2018-12-19 15:45:26'),
(118,12,'自己如何实现消息队列',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>大体上的设计是由一条线程 1 执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.</p> \n <p>添加一条线程 1 主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,</p> \n <p>当任务队列长度达到最大值时,线程 1 将被阻塞,等待线程 2,3… 从任务队列取出任务执行。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(119,12,'消息的幂等性解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3>\n <p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p> \n <h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3>\n <p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p> \n <h3 id=\"唯一索引，防止新增脏数据\"><a href=\"#唯一索引，防止新增脏数据\" class=\"headerlink\" title=\"唯一索引，防止新增脏数据\"></a>唯一索引，防止新增脏数据</h3>\n <p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p> \n <h3 id=\"Token-机制\"><a href=\"#Token-机制\" class=\"headerlink\" title=\"Token 机制\"></a>Token 机制</h3>\n <p>防止页面重复提交</p> \n <h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3>\n <p>获取数据的时候加锁获取</p> \n <pre><code>select * from table_xxx where id=\'xxx\' for update;\n</code></pre>\n <p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p> \n <p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p> \n <h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3>\n <p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p> \n <h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3>\n <p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多个系统，也就是分布式系统中得解决思路。</p> \n <h3 id=\"select-insert\"><a href=\"#select-insert\" class=\"headerlink\" title=\"select + insert\"></a>select + insert</h3>\n <p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p> \n <p>注意：核心高并发流程不要用这种方法</p> \n <h3 id=\"状态机幂等\"><a href=\"#状态机幂等\" class=\"headerlink\" title=\"状态机幂等\"></a>状态机幂等</h3>\n <p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p> \n <h3 id=\"对外提供接口的-API-如何保证幂等\"><a href=\"#对外提供接口的-API-如何保证幂等\" class=\"headerlink\" title=\"对外提供接口的 API 如何保证幂等\"></a>对外提供接口的 API 如何保证幂等</h3>\n <p>如银联提供的付款接口：需要接入商户提交付款请求时附带：<code>source</code> 来源，<code>seq</code> 序列号<br><code>source + seq</code> 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(120,12,'消息的堆积解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>如果还没开始投入使用 Kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。</p> \n <h3 id=\"增大批次\"><a href=\"#增大批次\" class=\"headerlink\" title=\"增大批次\"></a>增大批次</h3>\n <p>瓶颈在消费吞吐量的时候，增加批次也可以改善性能</p> \n <h3 id=\"增加线程数\"><a href=\"#增加线程数\" class=\"headerlink\" title=\"增加线程数\"></a>增加线程数</h3>\n <p>如果一些消费者组中的消费者线程还是有 1 个消费者线程消费多个分区的情况，建议增加消费者线程。尽量 1 个消费者线程对应 1 个分区，从而发挥现有分区数下的最大并行度。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(121,12,'如何保证消息的有序性',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，</li> \n  <li>在获取到路由信息以后，会根据算法来选择一个队列，同一个 OrderId 获取到的肯定是同一个队列。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(122,12,'BeanFactory 和 ApplicationContext 有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。</p> </li> \n  <li><p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p> </li> \n  <li><p>从表面上看，ApplicationContext 如同 BeanFactory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 ApplicationContext 在此基础上还提供了其他的功能：</p> \n   <ul> \n    <li>提供了支持国际化的文本消息</li> \n    <li>统一的资源文件读取方式</li> \n    <li>已在监听器中注册的 bean 的事件</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(123,12,'Spring IOC 如何实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring 中的 <code>org.springframework.beans</code> 包和 <code>org.springframework.context</code> 包构成了 Spring 框架 IoC 容器的基础。</li> \n  <li>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContext 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的 WebApplicationContext。</li> \n  <li><code>org.springframework.beans.factory.BeanFactory</code> 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(124,12,'Spring Bean 的生命周期',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。</li> \n  <li>Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n   <ul> \n    <li>初始化之后调用的回调方法。</li> \n    <li>销毁之前调用的回调方法。</li> \n   </ul> </li> \n  <li>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：\n   <ul> \n    <li>InitializingBean 和 DisposableBean 回调接口</li> \n    <li>针对特殊行为的其他 Aware 接口</li> \n    <li>Bean 配置文件中的 Custom init() 方法和 destroy() 方法</li> \n    <li>@PostConstruct 和 @PreDestroy 注解方式</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:27','2018-12-19 15:45:27'),
(125,12,'说说 Spring AOP',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有 update 方法的执行时间时间，操作人等等信息，记录到日志，<br>通过 Spring 的 AOP 技术，就可以在不修改 update 的代码的情况下完成该需求。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(126,12,'动态代理（CGLIB 与 JDK）',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用 Java 动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而 CGLIB 则可以实现对类的动态代理。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(127,12,'Spring AOP 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Spring AOP 中的动态代理主要有两种方式，<strong>JDK 动态代理</strong> 和 <strong>CGLIB 动态代理</strong>。JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类。</p> \n <p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(128,12,'消息队列的使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>校验用户名等信息，如果没问题会在数据库中添加一个用户记录</li> \n  <li>如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</li> \n  <li>分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</li> \n  <li>发送给用户一个包含操作指南的系统通知</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(129,12,'Spring 事务实现方式',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"编码方式\"><a href=\"#编码方式\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3>\n <p>所谓编程式事务指的是通过编码方式实现事务，即类似于 JDBC 编程实现事务管理。</p> \n <h3 id=\"声明式事务管理方式\"><a href=\"#声明式事务管理方式\" class=\"headerlink\" title=\"声明式事务管理方式\"></a>声明式事务管理方式</h3>\n <p>声明式事务管理又有两种实现方式：</p> \n <ul> \n  <li>基于 xml 配置文件的方式；</li> \n  <li>另一个实在业务方法上进行 <code>@Transaction</code> 注解，将事务规则应用到业务逻辑中；</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(130,12,'Spring 事务底层原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"划分处理单元-IOC\"><a href=\"#划分处理单元-IOC\" class=\"headerlink\" title=\"划分处理单元 IOC\"></a>划分处理单元 IOC</h3>\n <p>由于 Spring 解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用 Spring 中的 IOC 划分了事务处理单元。并且将对事务的各种配置放到了 IOC 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。</p> \n <h3 id=\"AOP-拦截需要进行事务处理的类\"><a href=\"#AOP-拦截需要进行事务处理的类\" class=\"headerlink\" title=\"AOP 拦截需要进行事务处理的类\"></a>AOP 拦截需要进行事务处理的类</h3>\n <p>Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用 <code>TransactionProxyFactoryBean</code> 接口来使用 AOP 功能，生成 proxy 代理对象，通过 <code>TransactionInterceptor</code> 完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，转化为 Spring 事务处理需要的内部数据结构（<code>TransactionAttributeSourceAdvisor</code>），转化为 <code>TransactionAttribute</code> 表示的数据对象。</p> \n <h3 id=\"对事物处理实现（事务的生成、提交、回滚、挂起）\"><a href=\"#对事物处理实现（事务的生成、提交、回滚、挂起）\" class=\"headerlink\" title=\"对事物处理实现（事务的生成、提交、回滚、挂起）\"></a>对事物处理实现（事务的生成、提交、回滚、挂起）</h3>\n <p>Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource 数据源支持、Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，JPA、JTA 数据源事务处理支持。这些支持都是通过设计 <code>PlatformTransactionManager</code>、<code>AbstractPlatforTransaction</code> 一系列事务处理的支持。 为常用数据源支持提供了一系列的 <code>TransactionManager</code>。</p> \n <h3 id=\"结合\"><a href=\"#结合\" class=\"headerlink\" title=\"结合\"></a>结合</h3>\n <p><code>PlatformTransactionManager</code> 实现了 <code>TransactionInterception</code> 接口，让其与 <code>TransactionProxyFactoryBean</code> 结合起来，形成一个 Spring 声明式事务处理的设计体系。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(131,12,'Spring 的单例实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(132,12,'Spring MVC 运行流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring MVC 将所有的请求都提交给 <code>DispatcherServlet</code>，它会委托应用系统的其他模块负责对请求进行真正的处理工作。</li> \n  <li><code>DispatcherServlet</code> 查询一个或多个 <code>HandlerMapping</code>，找到处理请求的 Controller.</li> \n  <li><code>DispatcherServlet</code> 请求提交到目标 Controller</li> \n  <li>Controller 进行业务逻辑处理后，会返回一个 <code>ModelAndView</code></li> \n  <li>Dispatcher 查询一个或多个 <code>ViewResolver</code> 视图解析器,找到 <code>ModelAndView</code> 对象指定的视图对象</li> \n  <li>视图对象负责渲染返回给客户端。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(133,12,'如何自定义注解实现功能',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>创建自定义注解和创建一个接口相似，但是注解的 <code>interface</code> 关键字需要以 <code>@</code> 符号开头。</li> \n  <li>注解方法不能带有参数；</li> \n  <li>注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的数组；</li> \n  <li>注解方法可以有默认值；</li> \n  <li>注解本身能够包含元注解，元注解被用来注解其它注解。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:28','2018-12-19 15:45:28'),
(134,12,'Spring 框架中用到了哪些设计模式',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>代理模式：在 AOP 和 Remoting 中被用的比较多。</li> \n  <li>单例模式：在 Spring 配置文件中定义的 Bean 默认为单例模式。</li> \n  <li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li> \n  <li>前端控制器：Spring 提供了 DispatcherServlet 来对请求进行分发。</li> \n  <li>视图帮助(View Helper )：Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li> \n  <li>依赖注入：贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li> \n  <li>工厂模式：BeanFactory 用来创建对象的实例。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(135,12,'为什么选择 Netty',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>API 使用简单，开发门槛低；</li> \n  <li>功能强大，预置了多种编解码功能，支持多种主流协议；</li> \n  <li>定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；</li> \n  <li>性能高，通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优；</li> \n  <li>成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼；</li> \n  <li>社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；</li> \n  <li>经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。</li> \n </ul> \n <p>正是因为这些优点，Netty 逐渐成为 Java NIO 编程的首选框架。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(136,12,'Redis 内存淘汰机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 内存淘汰指的是用户存储的一些键被可以被 Redis 主动地从实例中删除，从而产生读 miss 的情况，那么 Redis 为什么要有这种功能？这就是我们需要探究的设计初衷。Redis 最常见的两种应用场景为缓存和持久存储，首先要明确的一个问题是内存淘汰策略更适合于那种场景？是持久存储还是缓存？</p> \n <p>假设我们有一个 Redis 服务器，服务器物理内存大小为 1G 的，我们需要存在 Redis 中的数据量很小，这看起来似乎足够用很长时间了，随着业务量的增长，我们放在 Redis 里面的数据越来越多了，数据量大小似乎超过了 1G，但是应用还可以正常运行，这是因为操作系统的可见内存并不受物理内存限制，而是虚拟内存，物理内存不够用没关系，操作系统会从硬盘上划出一片空间用于构建虚拟内存，比如32位的操作系统的可见内存大小为 <code>2^32</code>，而用户空间的可见内存要小于 <code>2^32</code> 很多，大概是 3G 左右。好了，我们庆幸操作系统为我们做了这些，但是我们需要知道这背后的代价是不菲的，不合理的使用内存有可能发生频繁的 swap，频繁 swap 的代价是惨痛的。所以回过头来看，作为有追求的程序员，我们还是要小心翼翼地使用好每块内存，把用户代码能解决的问题尽量不要抛给操作系统解决。</p> \n <p><strong>内存的淘汰机制的初衷是为了更好地使用内存，用一定的缓存 miss 来换取内存的使用效率。</strong></p> \n <h3 id=\"如何用\"><a href=\"#如何用\" class=\"headerlink\" title=\"如何用\"></a>如何用</h3>\n <p>作为 Redis 用户，我们如何使用 Redis 提供的这个特性呢？</p> \n <pre><code># maxmemory &lt;bytes&gt;\n</code></pre>\n <p>我们可以通过配置 <code>redis.conf</code> 中的 <code>maxmemory</code> 这个值来开启内存淘汰功能，至于这个值有什么意义，我们可以通过了解内存淘汰的过程来理解它的意义：</p> \n <ul> \n  <li>客户端发起了需要申请更多内存的命令（如set）</li> \n  <li>Redis 检查内存使用情况，如果已使用的内存大于 <code>maxmemory</code> 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存</li> \n  <li>如果上面都没问题，则这个命令执行成功</li> \n </ul> \n <p><code>maxmemory</code> 为 0 的时候表示我们对 Redis 的内存使用没有限制</p> \n <h3 id=\"内存淘汰策略\"><a href=\"#内存淘汰策略\" class=\"headerlink\" title=\"内存淘汰策略\"></a>内存淘汰策略</h3>\n <p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p> \n <p>Redis 提供了下面几种淘汰策略供用户选择，其中默认的策略为 <code>noeviction</code> 策略：</p> \n <ul> \n  <li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错</li> \n  <li>allkeys-lru：在主键空间中，优先移除最近未使用的key</li> \n  <li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的 key</li> \n  <li>allkeys-random：在主键空间中，随机移除某个 key</li> \n  <li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key</li> \n  <li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除</li> \n </ul> \n <p>这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p> \n <h3 id=\"如何选择淘汰策略\"><a href=\"#如何选择淘汰策略\" class=\"headerlink\" title=\"如何选择淘汰策略\"></a>如何选择淘汰策略</h3>\n <p>我们了解了 Redis 大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p> \n <pre><code># maxmemory-policy noeviction\n</code></pre>\n <p>但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于 Redis 中存储的数据集的访问方式以及我们的诉求是什么。同时 Redis 也支持 Runtime 修改淘汰策略，这使得我们不需要重启 Redis 实例而实时的调整内存淘汰策略。</p> \n <p>下面看看几种策略的适用场景：</p> \n <ul> \n  <li>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略</li> \n  <li>allkeys-random：如果我们的应用对于缓存 key 的访问概率相等，则可以使用这个策略</li> \n  <li>volatile-ttl：这种策略使得我们可以向 Redis 提示哪些 key 更适合被 eviction</li> \n </ul> \n <p>另外，<code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</p> \n <h3 id=\"非精准的-LRU\"><a href=\"#非精准的-LRU\" class=\"headerlink\" title=\"非精准的 LRU\"></a>非精准的 LRU</h3>\n <p>上面提到的 LRU（Least Recently Used）策略，实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的，这里涉及到一个权衡的问题，如果需要在全部键空间内搜索最优解，则必然会增加系统的开销，Redis 是单线程的，也就是同一个实例在每一个时刻只能服务于一个客户端，所以耗时的操作一定要谨慎。为了在一定成本内实现相对的 LRU，早期的 Redis 版本是基于采样的 LRU，也就是放弃全部键空间内搜索解改为采样空间搜索最优解。自从 Redis3.0 版本之后，Redis 作者对于基于采样的 LRU 进行了一些优化，目的是在一定的成本内让结果更靠近真实的 LRU。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(137,12,'原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有得到根本性解决。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(138,12,'什么是 TCP 粘包/拆包',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li> \n  <li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li> \n  <li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li> \n  <li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(139,12,'TCP 粘包/拆包的解决办法',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li> \n  <li>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li> \n  <li>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(140,12,'Netty 线程模型',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先，Netty 使用 EventLoop 来处理连接上的读写事件，而一个连接上的所有请求都保证在一个 EventLoop 中被处理，一个 EventLoop 中只有一个 Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个 EventLoopGroup 包含多个 EventLoop，可以把一个 EventLoop 当做是 Reactor 线程模型中的一个线程，而一个 EventLoopGroup 类似于一个 ExecutorService</p> \n</div>',NULL,NULL,'2018-12-19 15:45:29','2018-12-19 15:45:29'),
(141,12,'说说 Netty 的零拷贝',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>“零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(142,12,'Netty 重连实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>心跳机制检测连接存活</li> \n  <li>启动时连接重试</li> \n  <li>运行中连接断开时重试</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(143,12,'Netty 内部执行流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <h2 id=\"Netty-内部执行流程\"><a href=\"#Netty-内部执行流程\" class=\"headerlink\" title=\"Netty 内部执行流程\"></a>Netty 内部执行流程</h2>\n <ul> \n  <li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li> \n  <li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</li> \n  <li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(144,12,'前后端分离是如何做的',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的 API 服务即可。前后端之间通过 HTTP 请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(145,12,'如何解决跨域',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是跨域问题？\"><a href=\"#什么是跨域问题？\" class=\"headerlink\" title=\"什么是跨域问题？\"></a>什么是跨域问题？</h3>\n <p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。</p> \n <h3 id=\"什么是同源？\"><a href=\"#什么是同源？\" class=\"headerlink\" title=\"什么是同源？\"></a>什么是同源？</h3>\n <p>所谓同源是指，域名，协议，端口均相同</p> \n <ul> \n  <li><code>http://www.funtl.com --&gt; http://admin.funtl.com 跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; http://www.funtl.com 非跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; http://www.funtl.com:8080 跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; https://www.funtl.com 跨域</code></li> \n </ul> \n <h3 id=\"使用-CORS（跨资源共享）解决跨域问题\"><a href=\"#使用-CORS（跨资源共享）解决跨域问题\" class=\"headerlink\" title=\"使用 CORS（跨资源共享）解决跨域问题\"></a>使用 CORS（跨资源共享）解决跨域问题</h3>\n <p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p> \n <p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10</p> \n <p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉</p> \n <p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信</p> \n <h3 id=\"CORS-与-JSONP-的比较\"><a href=\"#CORS-与-JSONP-的比较\" class=\"headerlink\" title=\"CORS 与 JSONP 的比较\"></a>CORS 与 JSONP 的比较</h3>\n <p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p> \n <p>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(146,12,'微服务哪些框架',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3>\n <p>是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。阿里巴巴近几年对开源社区的贡献不论在国内还是国外都是引人注目的，比如：JStorm 捐赠给 Apache 并加入 Apache 基金会等，为中国互联网人争足了面子，使得阿里巴巴在国人眼里已经从电商升级为一家科技公司了。</p> \n <h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3>\n <p>从命名我们就可以知道，它是 Spring Source 的产物，Spring 社区的强大背书可以说是 Java 企业界最有影响力的组织了，除了 Spring Source 之外，还有 Pivotal 和 Netflix 是其强大的后盾与技术输出。其中 Netflix 开源的整套微服务架构套件是 Spring Cloud 的核心。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(147,12,'你怎么理解 RPC 框架',1,'www.funtl.com/assets/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是-RPC？\"><a href=\"#什么是-RPC？\" class=\"headerlink\" title=\"什么是 RPC？\"></a>什么是 RPC？</h3>\n <p>RPC 是指远程过程调用，也就是说两台服务器 A，B 一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数或方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p> \n <h3 id=\"RPC-是如何通讯的？\"><a href=\"#RPC-是如何通讯的？\" class=\"headerlink\" title=\"RPC 是如何通讯的？\"></a>RPC 是如何通讯的？</h3>\n <p><img src=\"/assets/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg\" alt=\"\"></p> \n <ol> \n  <li>要解决通讯的问题，主要是通过在客户端和服务器之间建立 TCP 连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li> \n  <li>要解决寻址的问题，也就是说，A 服务器上的应用怎么告诉底层的 RPC 框架，如何连接到 B 服务器（如主机或 IP 地址）以及特定的端口，方法的名称是什么，这样才能完成调用。比如基于 Web 服务协议栈的 RPC，就要提供一个 endpoint URI，或者是从 UDDI 服务上查找。如果是 RMI 调用的话，还需要一个 RMI Registry 来注册服务的地址。</li> \n  <li>当 A 服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如 TCP 传递到 B 服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给 B 服务器。</li> \n  <li>B 服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li> \n  <li>返回值还要发送回服务器 A 上的应用，也要经过序列化的方式发送，服务器 A 接到后，再反序列化，恢复为内存中的表达方式，交给 A 服务器上的应用。</li> \n </ol> \n <h3 id=\"为什么要用-RPC？\"><a href=\"#为什么要用-RPC？\" class=\"headerlink\" title=\"为什么要用 RPC？\"></a>为什么要用 RPC？</h3>\n <p>就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(148,12,'说说业务中 Netty 的使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务；</p> </li> \n  <li><p>公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；</p> </li> \n  <li><p>各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(149,12,'你怎么理解 RESTful',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>2000 年，Roy Thomas Fielding 博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了几种软件应用的架构风格，REST 作为其中的一种架构风格在这篇论文的第5章中进行了概括性的介绍。</p> \n <p>REST 是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”，但是在绝大多数场合中我们只说 REST 或者 RESTful。Fielding 在论文中将 REST 定位为“分布式超媒体应用（Distributed Hypermedia System）”的架构风格，它在文中提到一个名为“HATEOAS（Hypermedia as the engine of application state）”的概念。</p> \n <p>我们利用一个面向最终用户的 Web 应用来对这个概念进行简单阐述：这里所谓的应用状态（Application State）表示 Web 应用的客户端的状态，简单起见可以理解为会话状态。资源在浏览器中以超媒体的形式呈现，通过点击超媒体中的链接可以获取其它相关的资源或者对当前资源进行相应的处理，获取的资源或者针对资源处理的响应同样以超媒体的形式再次呈现在浏览器上。由此可见，超媒体成为了驱动客户端会话状态的转换的引擎。</p> \n <p>借助于超媒体这种特殊的资源呈现方式，应用状态的转换体现为浏览器中呈现资源的转换。如果将超媒体进一步抽象成一般意义上的资源呈现（Representation ）方式，那么应用状态变成了可被呈现的状态（REpresentational State）。应用状态之间的转换就成了可被呈现的状态装换（REpresentational State Transfer），这就是 REST。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>REST 是一种很笼统的概念，它代表一种架构风格。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:30','2018-12-19 15:45:30'),
(150,12,'如何理解 RESTful API 的幂等性',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3>\n <p>HTTP 幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p> \n <pre><code>GET     /tickets       # 获取ticket列表\nGET     /tickets/12    # 查看某个具体的ticket\nPOST    /tickets       # 新建一个ticket\nPUT     /tickets/12    # 更新ticket 12\nPATCH   /tickets/12    # 更新ticket 12\nDELETE  /tickets/12    # 删除ticekt 12\n</code></pre>\n <h4 id=\"HTTP-GET-方法\"><a href=\"#HTTP-GET-方法\" class=\"headerlink\" title=\"HTTP GET 方法\"></a>HTTP GET 方法</h4>\n <p>HTTP GET 方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p> \n <pre><code>GET     /tickets       # 获取ticket列表\nGET     /tickets/12    # 查看某个具体的ticket\n</code></pre>\n <p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p> \n <p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个 HTTP GET 方法可能会每次得到不同的返回内容，但并不影响资源。</p> \n <p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p> \n <pre><code>GET     /service_time # 获取服务器当前时间\n</code></pre>\n <p>它本身不会对资源本身产生影响，因此满足幂等性。</p> \n <h4 id=\"HTTP-POST-方法\"><a href=\"#HTTP-POST-方法\" class=\"headerlink\" title=\"HTTP POST 方法\"></a>HTTP POST 方法</h4>\n <p>HTTP POST 方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p> \n <pre><code>POST    /tickets       # 新建一个ticket\n</code></pre>\n <p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p> \n <h4 id=\"HTTP-PUT-方法\"><a href=\"#HTTP-PUT-方法\" class=\"headerlink\" title=\"HTTP PUT 方法\"></a>HTTP PUT 方法</h4>\n <p>HTTP PUT 方法是不是幂等的呢？我们来看下</p> \n <pre><code>PUT     /tickets/12    # 更新ticket 12\n</code></pre>\n <p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p> \n <h4 id=\"HTTP-PATCH-方法\"><a href=\"#HTTP-PATCH-方法\" class=\"headerlink\" title=\"HTTP PATCH 方法\"></a>HTTP PATCH 方法</h4>\n <p>HTTP PATCH 方法是非幂等的。HTTP POST 方法和 HTTP PUT 方法可能比较好理解，但是 HTTP PATCH 方法只是更新部分资源，怎么是非幂等的呢?</p> \n <p>因为，PATCH 提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH 请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p> \n <p>可能你还不能理解这点。我们举个例子</p> \n <pre><code>PATCH   /tickets/12    # 更新ticket 12\n</code></pre>\n <p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条 ticket 记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p> \n <h4 id=\"HTTP-DELETE-方法\"><a href=\"#HTTP-DELETE-方法\" class=\"headerlink\" title=\"HTTP DELETE 方法\"></a>HTTP DELETE 方法</h4>\n <p>HTTP DELETE 方法用于删除资源，会将资源删除。</p> \n <pre><code>DELETE  /tickets/12    # 删除ticekt 12\n</code></pre>\n <p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p> \n <h3 id=\"如何设计符合幂等性的高质量-RESTful-API\"><a href=\"#如何设计符合幂等性的高质量-RESTful-API\" class=\"headerlink\" title=\"如何设计符合幂等性的高质量 RESTful API\"></a>如何设计符合幂等性的高质量 RESTful API</h3>\n <h4 id=\"HTTP-GET-vs-HTTP-POST\"><a href=\"#HTTP-GET-vs-HTTP-POST\" class=\"headerlink\" title=\"HTTP GET vs HTTP POST\"></a>HTTP GET vs HTTP POST</h4>\n <p>也许，你会想起一个面试题。<strong>HTTP 请求的 GET 与 POST 方式有什么区别？</strong> 你可能会回答到：GET 方式通过 URL 提交数据，数据在 URL 中可以看到；POST 方式，数据放置在 HTML HEADER 内提交。但是，我们现在从 RESTful 的资源角度来看待问题，HTTP GET 方法是幂等的，所以它适合作为查询操作，HTTP POST 方法是非幂等的，所以用来表示新增操作。</p> \n <p>但是，也有例外，我们有的时候可能需要把查询方法改造成 HTTP POST 方法。比如，超长（1k）的 GET URL 使用 POST 方法来替代，因为 GET 受到 URL 长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p> \n <h4 id=\"HTTP-POST-vs-HTTP-PUT\"><a href=\"#HTTP-POST-vs-HTTP-PUT\" class=\"headerlink\" title=\"HTTP POST vs HTTP PUT\"></a>HTTP POST vs HTTP PUT</h4>\n <p>对于 HTTP POST 方法和 HTTP PUT 方法，我们一般的理解是 POST 表示创建资源，PUT 表示更新资源。当然，这个是正确的理解。</p> \n <p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST 方法是非幂等，所以用来表示创建资源，HTTP PUT 方法是幂等的，因此表示更新资源更加贴切。</p> \n <h4 id=\"HTTP-PUT-vs-HTTP-PATCH\"><a href=\"#HTTP-PUT-vs-HTTP-PATCH\" class=\"headerlink\" title=\"HTTP PUT vs HTTP PATCH\"></a>HTTP PUT vs HTTP PATCH</h4>\n <p>此时，你看会有另外一个问题。HTTP PUT 方法和 HTTP PATCH 方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是 PUT 表示更新全部资源，PATCH 表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH 方法是非幂等的，因此我们在设计我们服务端的 RESTful API 的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用 HTTP PUT 方法。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(151,12,'说说 Dubbo 的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Dubbo 作为 RPC 框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到呢？</p> \n <ol> \n  <li>本地有对远程方法的描述，包括方法名、参数、返回值，在 Dubbo 中是远程和本地使用同样的接口</li> \n  <li>要有对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格式）传递到服务端</li> \n  <li>服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调用；</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(152,12,'说说如何设计一个良好的 API',1,NULL,1,'<div class=\"col-sm-12\"> \n <h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2>\n <p>在 RESTful API 中，API 接口应该尽量兼容之前的版本。但是，在实际业务开发场景中，可能随着业务需求的不断迭代，现有的 API 接口无法支持旧版本的适配，此时如果强制升级服务端的 API 接口将导致客户端旧有功能出现故障。实际上，Web 端是部署在服务器，因此它可以很容易为了适配服务端的新的 API 接口进行版本升级，然而像 Android 端、IOS 端、PC 端等其他客户端是运行在用户的机器上，因此当前产品很难做到适配新的服务端的 API 接口，从而出现功能故障，这种情况下，用户必须升级产品到最新的版本才能正常使用。</p> \n <p>为了解决这个版本不兼容问题，在设计 RESTful API 的一种实用的做法是使用版本号。一般情况下，我们会在 url 中保留版本号，并同时兼容多个版本。</p> \n <pre><code>【GET】  /v1/users/{user_id}  // 版本 v1 的查询用户列表的 API 接口\n【GET】  /v2/users/{user_id}  // 版本 v2 的查询用户列表的 API 接口\n</code></pre>\n <p>现在，我们可以不改变版本 v1 的查询用户列表的 API 接口的情况下，新增版本 v2 的查询用户列表的 API 接口以满足新的业务需求，此时，客户端的产品的新功能将请求新的服务端的 API 接口地址。虽然服务端会同时兼容多个版本，但是同时维护太多版本对于服务端而言是个不小的负担，因为服务端要维护多套代码。这种情况下，常见的做法不是维护所有的兼容版本，而是只维护最新的几个兼容版本，例如维护最新的三个兼容版本。在一段时间后，当绝大多数用户升级到较新的版本后，废弃一些使用量较少的服务端的老版本API 接口版本，并要求使用产品的非常旧的版本的用户强制升级。</p> \n <p>注意的是，“不改变版本 v1 的查询用户列表的 API 接口”主要指的是对于客户端的调用者而言它看起来是没有改变。而实际上，如果业务变化太大，服务端的开发人员需要对旧版本的 API 接口使用适配器模式将请求适配到新的API 接口上。</p> \n <h3 id=\"资源路径\"><a href=\"#资源路径\" class=\"headerlink\" title=\"资源路径\"></a>资源路径</h3>\n <p>RESTful API 的设计以资源为核心，每一个 URI 代表一种资源。因此，URI 不能包含动词，只能是名词。注意的是，形容词也是可以使用的，但是尽量少用。一般来说，不论资源是单个还是多个，API 的名词要以复数进行命名。此外，命名名词的时候，要使用小写、数字及下划线来区分多个单词。这样的设计是为了与 json 对象及属性的命名方案保持一致。例如，一个查询系统标签的接口可以进行如下设计。</p> \n <pre><code>【GET】  /v1/tags/{tag_id} \n</code></pre>\n <p>同时，资源的路径应该从根到子依次如下</p> \n <pre><code>/{resources}/{resource_id}/{sub_resources}/{sub_resource_id}/{sub_resource_property}\n</code></pre>\n <p>我们来看一个“添加用户的角色”的设计，其中“用户”是主资源，“角色”是子资源。</p> \n <pre><code>【POST】  /v1/users/{user_id}/roles/{role_id} // 添加用户的角色\n</code></pre>\n <p>有的时候，当一个资源变化难以使用标准的 RESTful API 来命名，可以考虑使用一些特殊的 actions 命名。</p> \n <pre><code>/{resources}/{resource_id}/actions/{action}\n</code></pre>\n <p>举个例子，“密码修改”这个接口的命名很难完全使用名词来构建路径，此时可以引入 action 命名。</p> \n <pre><code>【PUT】  /v1/users/{user_id}/password/actions/modify // 密码修改\n</code></pre>\n <h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a>请求方式</h3>\n <p>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中：</p> \n <ul> \n  <li>GET：用于查询资源</li> \n  <li>POST：用于创建资源</li> \n  <li>PUT：用于更新服务端的资源的全部信息</li> \n  <li>PATCH：用于更新服务端的资源的部分信息</li> \n  <li>DELETE：用于删除服务端的资源。</li> \n </ul> \n <p>这里，使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p> \n <pre><code>【GET】          /users                # 查询用户信息列表\n【GET】          /users/1001           # 查看某个用户信息\n【POST】         /users                # 新建用户信息\n【PUT】          /users/1001           # 更新用户信息(全部字段)\n【PATCH】        /users/1001           # 更新用户信息(部分字段)\n【DELETE】       /users/1001           # 删除用户信息\n</code></pre>\n <h3 id=\"查询参数\"><a href=\"#查询参数\" class=\"headerlink\" title=\"查询参数\"></a>查询参数</h3>\n <p>RESTful API 接口应该提供参数，过滤返回结果。其中，offset 指定返回记录的开始位置。一般情况下，它会结合 limit 来做分页的查询，这里 limit 指定返回记录的数量。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?offset=0&amp;limit=20\n</code></pre>\n <p>同时，orderby 可以用来排序，但仅支持单个字符的排序，如果存在多个字段排序，需要业务中扩展其他参数进行支持。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?orderby={field} [asc|desc]\n</code></pre>\n <p>为了更好地选择是否支持查询总数，我们可以使用 count 字段，count 表示返回数据是否包含总条数，它的默认值为 false。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?count=[true|false]\n</code></pre>\n <p>上面介绍的 offset、 limit、 orderby 是一些公共参数。此外，业务场景中还存在许多个性化的参数。我们来看一个例子。</p> \n <pre><code>【GET】  /v1/categorys/{category_id}/apps/{app_id}?enable=[1|0]&amp;os_type={field}&amp;device_ids={field,field,…}\n</code></pre>\n <p>注意的是，不要过度设计，只返回用户需要的查询参数。此外，需要考虑是否对查询参数创建数据库索引以提高查询性能。</p> \n <h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3>\n <p>使用适合的状态码很重要，而不应该全部都返回状态码 200，或者随便乱使用。这里，列举在实际开发过程中常用的一些状态码，以供参考。</p> \n <table> \n  <thead> \n   <tr> \n    <th>状态码</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>200</td> \n    <td>请求成功</td> \n   </tr> \n   <tr> \n    <td>201</td> \n    <td>创建成功</td> \n   </tr> \n   <tr> \n    <td>400</td> \n    <td>错误的请求</td> \n   </tr> \n   <tr> \n    <td>401</td> \n    <td>未验证</td> \n   </tr> \n   <tr> \n    <td>403</td> \n    <td>被拒绝</td> \n   </tr> \n   <tr> \n    <td>404</td> \n    <td>无法找到</td> \n   </tr> \n   <tr> \n    <td>409</td> \n    <td>资源冲突</td> \n   </tr> \n   <tr> \n    <td>500</td> \n    <td>服务器内部错误</td> \n   </tr> \n  </tbody> \n </table> \n <h3 id=\"异常响应\"><a href=\"#异常响应\" class=\"headerlink\" title=\"异常响应\"></a>异常响应</h3>\n <p>当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。</p> \n <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n</code></pre>\n <h3 id=\"请求参数\"><a href=\"#请求参数\" class=\"headerlink\" title=\"请求参数\"></a>请求参数</h3>\n <p>在设计服务端的 RESTful API 的时候，我们还需要对请求参数进行限制说明。例如一个支持批量查询的接口，我们要考虑最大支持查询的数量。</p> \n <pre><code>【GET】     /v1/users/batch?user_ids=1001,1002      // 批量查询用户信息\n参数说明\n- user_ids: 用户ID串，最多允许 20 个。\n</code></pre>\n <p>此外，在设计新增或修改接口时，我们还需要在文档中明确告诉调用者哪些参数是必填项，哪些是选填项，以及它们的边界值的限制。</p> \n <pre><code>【POST】     /v1/users                             // 创建用户信息\n请求内容\n{\n    \"username\": \"lusifer\",                 // 必填, 用户名称, max 10\n    \"realname\": \"鲁斯菲尔\",               // 必填, 用户名称, max 10\n    \"password\": \"123456\",              // 必填, 用户密码, max 32\n    \"email\": \"topsale@vip.qq.com\",     // 选填, 电子邮箱, max 32\n    \"weixin\": \"Lusifer\",            // 选填，微信账号, max 32\n    \"sex\": 1                           // 必填, 用户性别[1-男 2-女 99-未知]\n}\n</code></pre>\n <h3 id=\"响应参数\"><a href=\"#响应参数\" class=\"headerlink\" title=\"响应参数\"></a>响应参数</h3>\n <p>针对不同操作，服务端向用户返回的结果应该符合以下规范。</p> \n <pre><code>【GET】     /{version}/{resources}/{resource_id}      // 返回单个资源对象\n【GET】     /{version}/{resources}                    // 返回资源对象的列表\n【POST】    /{version}/{resources}                    // 返回新生成的资源对象\n【PUT】     /{version}/{resources}/{resource_id}      // 返回完整的资源对象\n【PATCH】   /{version}/{resources}/{resource_id}      // 返回完整的资源对象\n【DELETE】  /{version}/{resources}/{resource_id}      // 状态码 200，返回完整的资源对象。\n                                                      // 状态码 204，返回一个空文档\n</code></pre>\n <p>如果是单条数据，则返回一个对象的 JSON 字符串。</p> \n <pre><code>HTTP/1.1 200 OK\n{\n    \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"name\" : \"example\",\n    \"created_time\": 1496676420000,\n    \"updated_time\": 1496676420000,\n    ...\n}\n</code></pre>\n <p>如果是列表数据，则返回一个封装的结构体。</p> \n <pre><code>HTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n            \"name\" : \"example\",\n            \"created_time\": 1496676420000,\n            \"updated_time\": 1496676420000,\n            ...\n        },\n        ...\n    ]\n}\n</code></pre>\n <h3 id=\"一个完整的案例\"><a href=\"#一个完整的案例\" class=\"headerlink\" title=\"一个完整的案例\"></a>一个完整的案例</h3>\n <p>最后，我们使用一个完整的案例将前面介绍的知识整合起来。这里，使用“获取用户列表”的案例。</p> \n <pre><code>【GET】     /v1/users?[&amp;keyword=xxx][&amp;enable=1][&amp;offset=0][&amp;limit=20] 获取用户列表\n功能说明：获取用户列表\n请求方式：GET\n参数说明\n- keyword: 模糊查找的关键字。[选填]\n- enable: 启用状态[1-启用 2-禁用]。[选填]\n- offset: 获取位置偏移，从 0 开始。[选填]\n- limit: 每次获取返回的条数，缺省为 20 条，最大不超过 100。 [选填]\n响应内容\nHTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n            \"name\" : \"example\",\n            \"created_time\": 1496676420000,\n            \"updated_time\": 1496676420000,\n            ...\n        },\n        ...\n    ]\n}\n失败响应\nHTTP/1.1 403 UC/AUTH_DENIED\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n错误代码\n- 403 UC/AUTH_DENIED    授权受限\n</code></pre> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(153,12,'如何保证接口的幂等性',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当通过调用创建实例接口在负载均衡中创建云服务器时，如果遇到了请求超时或服务器内部错误时，客户端可能会尝试重发请求，这时客户端可以通过提供可选参数 ClientToken 避免服务器创建出比预期要多的实例，也就是通过提供 ClientToken 参数保证请求的幂等性。ClientToken 是一个由客户端生成的唯一的、大小写敏感、不超过 64 个 ASCII 字符的字符串。</p> \n <p>如果用户使用同一个 ClientToken 值调用创建实例接口，则服务端会返回相同的请求结果，包含相同的 InstanceId。因此用户在遇到错误进行重试的时候，可以通过提供相同的 ClientToken 值，来确保负载均衡只创建一个实例，并得到这个实例的 InstanceId。</p> \n <p>如果用户提供了一个已经使用过的 ClientToken，但其他请求参数不同，则负载均衡会返回 IdempotentParameterMismatch 的错误代码。但需要注意的是，SignatureNonce、Timestamp 和 Signature 参数在重试时是需要变化的，因为负载均衡使用 SignatureNonce 来防止重放攻击，使用 Timestamp 来标记每次请求时间，所以再次请求必须提供不同的 SignatureNonce 和 Timestamp 参数值，这同时也会导致 Signature 值的变化。</p> \n <p>通常，客户端只需要在 500（InternetError）或 503（ServiceUnavailable）错误、或者无法得到响应结果的情况下进行重试操作。返回结果是 200 时，重试可以得到上次相同的结果，但不会对服务端状态带来任何影响。而对 4xx 的返回错误，通常重试也是不能成功的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(154,12,'说说 RPC 的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(155,12,'你怎么看待微服务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在我的课程 <a href=\"/2018/04/07/microservice/Java-微服务架构/\"><strong>【Java 微服务架构】</strong></a> 中的 <strong>微服务简介</strong> 章节即为参考答案。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(156,12,'说说 CAP 定理、 BASE 理论',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"CAP-定理\"><a href=\"#CAP-定理\" class=\"headerlink\" title=\"CAP 定理\"></a>CAP 定理</h3>\n <p>2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。</p> \n <p>CAP 理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p> \n <h4 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h4>\n <p>一致性指 “all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p> \n <h4 id=\"可用性（Availability）\"><a href=\"#可用性（Availability）\" class=\"headerlink\" title=\"可用性（Availability）\"></a>可用性（Availability）</h4>\n <p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p> \n <h4 id=\"分区容错性（Partition-tolerance）\"><a href=\"#分区容错性（Partition-tolerance）\" class=\"headerlink\" title=\"分区容错性（Partition tolerance）\"></a>分区容错性（Partition tolerance）</h4>\n <p>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p> \n <h3 id=\"CAP-权衡\"><a href=\"#CAP-权衡\" class=\"headerlink\" title=\"CAP 权衡\"></a>CAP 权衡</h3>\n <p>通过 CAP 理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p> \n <p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9，即保证 P 和 A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p> \n <p>对于涉及到钱财这样不能有一丝让步的场景，C 必须保证。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A。例如网络故障是只读不写。</p> \n <p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p> \n <h3 id=\"BASE-理论\"><a href=\"#BASE-理论\" class=\"headerlink\" title=\"BASE 理论\"></a>BASE 理论</h3>\n <p>eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p> \n <h4 id=\"基本可用（Basically-Available）\"><a href=\"#基本可用（Basically-Available）\" class=\"headerlink\" title=\"基本可用（Basically Available）\"></a>基本可用（Basically Available）</h4>\n <p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p> \n <p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p> \n <h4 id=\"软状态（Soft-State）\"><a href=\"#软状态（Soft-State）\" class=\"headerlink\" title=\"软状态（Soft State）\"></a>软状态（Soft State）</h4>\n <p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</p> \n <h4 id=\"最终一致性（Eventual-Consistency）\"><a href=\"#最终一致性（Eventual-Consistency）\" class=\"headerlink\" title=\"最终一致性（Eventual Consistency）\"></a>最终一致性（Eventual Consistency）</h4>\n <p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p> \n <h3 id=\"ACID-和-BASE-的区别与联系\"><a href=\"#ACID-和-BASE-的区别与联系\" class=\"headerlink\" title=\"ACID 和 BASE 的区别与联系\"></a>ACID 和 BASE 的区别与联系</h3>\n <p>ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p> \n <p>ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:31','2018-12-19 15:45:31'),
(157,12,'微服务与 SOA 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>微服务是 SOA 发展出来的产物，它是一种比较现代化的细粒度的 SOA 实现方式。</p> \n <p>较早实践微服务的公司 Netflix 就曾经称他们构建的架构是「细粒度的 SOA」。</p> \n <p>讨论「微服务和 SOA 的差别」的意义远不如讨论「微服务和单体系统的差别」更大，因为他们的区别实在有点微妙。此外，互联网近些年的发展，越来越朝去中心化的方向前进了，就像今天的IT工程师不需要像律师、教师那样，需要得到某些机构的认可才能更好的开展工作，这一方面意味着门槛的降低，另一方面也意味着更多的概念没有一个权威的声音来对它进行定义，使得每个人可以根据自己的需求做出不同的调整。</p> \n <p>微服务和 SOA 都是这样背景下的产物，并没有一个权威的定义，来说明它们各自包含了什么东西，使用什么的方法进行系统的构建。但是，还是可以从最大的范围来对比它们的不同，当我们今天说出这两个概念时，其区别往往没有那么大，但 SOA 是有一定的历史了，在历史上的 SOA 往往意味着更多的东西，而这些是现在很多人在做架构设计时不会采用的。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(158,12,'怎么考虑数据一致性问题',1,'www.funtl.com/assets/66ecd4cb674eb4b55f786b7f8517ea07.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"单体应用的数据一致性\"><a href=\"#单体应用的数据一致性\" class=\"headerlink\" title=\"单体应用的数据一致性\"></a>单体应用的数据一致性</h3>\n <p>想象一下如果我们经营着一家大型企业，下属有航空公司、租车公司、和连锁酒店。我们为客户提供一站式的旅游行程规划服务，这样客户只需要提供出行目的地，我们帮助客户预订机票、租车、以及预订酒店。从业务的角度，我们必须保证上述三个服务的预订都完成才能满足一个成功的旅游行程，否则不能成行。</p> \n <p>我们的单体应用要满足这个需求非常简单，只需将这个三个服务请求放到同一个数据库事务中，数据库会帮我们保证全部成功或者全部回滚。</p> \n <p><img src=\"/assets/66ecd4cb674eb4b55f786b7f8517ea07.png\" alt=\"\"></p> \n <p>当这个功能上线以后，公司非常满意，客户也非常高兴。</p> \n <h3 id=\"微服务场景下的数据一致性\"><a href=\"#微服务场景下的数据一致性\" class=\"headerlink\" title=\"微服务场景下的数据一致性\"></a>微服务场景下的数据一致性</h3>\n <p>这几年中，我们的行程规划服务非常成功，企业蒸蒸日上，用户量也翻了数十倍。企业的下属航空公司、租车公司、和连锁酒店也相继推出了更多服务以满足客户需求，我们的应用和开发团队也因此日渐庞大。如今我们的单体应用已变得如此复杂，以至于没人了解整个应用是怎么运作的。更糟的是新功能的上线现在需要所有研发团队合作，日夜奋战数周才能完成。看着市场占有率每况愈下，公司高层对研发部门越来越不满意。</p> \n <p>经过数轮讨论，我们最终决定将庞大的单体应用一分为四：机票预订服务、租车服务、酒店预订服务、和支付服务。服务各自使用自己的数据库，并通过 HTTP 协议通信。负责各服务的团队根据市场需求按照自己的开发节奏发版上线。如今我们面临新的挑战：如何保证最初三个服务的预订都完成才能满足一个成功的旅游行程， 否则不能成行的业务规则？现在服务有各自的边界，而且数据库选型也不尽相同，通过数据库保证数据一致性的方案已不可行。</p> \n <p><img src=\"/assets/f1a152a2a4a84d135fafb08525f0f9ce.png\" alt=\"\"></p> \n <h3 id=\"Sagas\"><a href=\"#Sagas\" class=\"headerlink\" title=\"Sagas\"></a>Sagas</h3>\n <p>幸运的是我们在互联网找到一篇精彩的论文，文中提出的数据一致性解决方案 Saga 恰好满足我们的业务要求。</p> \n <blockquote> \n  <p>Saga 是一个长活事务，可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。</p> \n </blockquote> \n <p>在我们的业务场景下，一个行程规划的事务就是一个 Saga，其中包含四个子事务：机票预订、租车、酒店预订、和支付。</p> \n <p><img src=\"/assets/fc69ade8b2ec344c0d6f53fbec302a37.png\" alt=\"\"></p> \n <p>Chris Richardson 在他的文章 Pattern: Saga 中对 Saga 有所描述。 Caitie McCaffrey 也在她的演讲中提到如何在微软的 光晕4 游戏中如何应用 saga 解决数据一致性问题。</p> \n <h4 id=\"Saga-的运行原理\"><a href=\"#Saga-的运行原理\" class=\"headerlink\" title=\"Saga 的运行原理\"></a>Saga 的运行原理</h4>\n <blockquote> \n  <p>Saga 中的事务相互关联，应作为（非原子）单位执行。任何未完全执行的 Saga 是不满足要求的，如果发生，必须得到补偿。要修正未完全执行的部分，每个 saga 子交易 T1 应提供对应补偿事务 C1</p> \n </blockquote> \n <p>我们根据上述规则定义以下事务及其相应的事务补偿： </p> \n <table> \n  <thead> \n   <tr> \n    <th>服务</th> \n    <th>事务</th> \n    <th>补偿</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>机票预订</td> \n    <td>预订机票</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>租车</td> \n    <td>租车</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>酒店预订</td> \n    <td>预订房间</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>支付</td> \n    <td>支付</td> \n    <td>退款</td> \n   </tr> \n  </tbody> \n </table> \n <pre><code>当每个 saga 子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1, 那么 saga 系统可以保证\n\n子事务序列 T1, T2, …, Tn 得以完成 (最佳情况)\n或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成\n</code></pre>\n <p>换句话说，通过上述定义的事务/补偿，saga 保证满足以下业务规则：</p> \n <ul> \n  <li>所有的预订都被执行成功，如果任何一个失败，都会被取消</li> \n  <li>如果最后一步付款失败，所有预订也将被取消</li> \n </ul> \n <h4 id=\"Saga-的恢复方式\"><a href=\"#Saga-的恢复方式\" class=\"headerlink\" title=\"Saga 的恢复方式\"></a>Saga 的恢复方式</h4>\n <p>原论文中描述了两种类型的 Saga 恢复方式：</p> \n <blockquote> \n  <p>向后恢复 补偿所有已完成的事务，如果任一子事务失败<br>向前恢复 重试失败的事务，假设每个子事务最终都会成功</p> \n </blockquote> \n <p>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。</p> \n <p>理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机，网络可能会失败，甚至数据中心也可能会停电。在这种情况下我们能做些什么？最后的手段是提供回退措施，比如人工干预。</p> \n <h4 id=\"使用-Saga-的条件\"><a href=\"#使用-Saga-的条件\" class=\"headerlink\" title=\"使用 Saga 的条件\"></a>使用 Saga 的条件</h4>\n <p>Saga 看起来很有希望满足我们的需求。所有长活事务都可以这样做吗？这里有一些限制：</p> \n <ul> \n  <li>Saga 只允许两个层次的嵌套，顶级的 Saga 和简单子事务 </li> \n  <li>在外层，全原子性不能得到满足。也就是说，sagas 可能会看到其他 sagas 的部分结果</li> \n  <li>每个子事务应该是独立的原子行为</li> \n  <li>在我们的业务场景下，航班预订、租车、酒店预订和付款是自然独立的行为，而且每个事务都可以用对应服务的数据库保证原子操作。</li> \n </ul> \n <p>我们在行程规划事务层面也不需要原子性。一个用户可以预订最后一张机票，而后由于信用卡余额不足而被取消。同时另一个用户可能开始会看到已无余票，接着由于前者预订被取消，最后一张机票被释放，而抢到最后一个座位并完成行程规划。</p> \n <p>补偿也有需考虑的事项：</p> \n <ul> \n  <li>补偿事务从语义角度撤消了事务 Ti 的行为，但未必能将数据库返回到执行 Ti 时的状态。（例如，如果事务触发导弹发射，则可能无法撤消此操作）</li> \n </ul> \n <p>但这对我们的业务来说不是问题。其实难以撤消的行为也有可能被补偿。例如，发送电邮的事务可以通过发送解释问题的另一封电邮来补偿。</p> \n <p>现在我们有了通过 Saga 来解决数据一致性问题的方案。它允许我们成功地执行所有事务，或在任何事务失败的情况下，补偿已成功的事务。虽然 Saga 不提供 ACID 保证，但仍适用于许多数据最终一致性的场景。那我们如何设计一个 Saga 系统？</p> \n <h4 id=\"Saga-Log\"><a href=\"#Saga-Log\" class=\"headerlink\" title=\"Saga Log\"></a>Saga Log</h4>\n <p>Saga 保证所有的子事务都得以完成或补偿，但 Saga 系统本身也可能会崩溃。Saga 崩溃时可能处于以下几个状态：</p> \n <ul> \n  <li>Saga 收到事务请求，但尚未开始。因子事务对应的微服务状态未被 Saga 修改，我们什么也不需要做。</li> \n  <li>一些子事务已经完成。重启后，Saga 必须接着上次完成的事务恢复。</li> \n  <li>子事务已开始，但尚未完成。由于远程服务可能已完成事务，也可能事务失败，甚至服务请求超时，saga 只能重新发起之前未确认完成的子事务。这意味着子事务必须幂等。</li> \n  <li>子事务失败，其补偿事务尚未开始。Saga 必须在重启后执行对应补偿事务。</li> \n  <li>补偿事务已开始但尚未完成。解决方案与上一个相同。这意味着补偿事务也必须是幂等的。</li> \n  <li>所有子事务或补偿事务均已完成，与第一种情况相同。</li> \n </ul> \n <p>为了恢复到上述状态，我们必须追踪子事务及补偿事务的每一步。我们决定通过事件的方式达到以上要求，并将以下事件保存在名为 saga log 的持久存储中：</p> \n <ul> \n  <li>Saga started event 保存整个 saga 请求，其中包括多个事务/补偿请求</li> \n  <li>Transaction started event 保存对应事务请求</li> \n  <li>Transaction ended event 保存对应事务请求及其回复</li> \n  <li>Transaction aborted event 保存对应事务请求和失败的原因</li> \n  <li>Transaction compensated event 保存对应补偿请求及其回复</li> \n  <li>Saga ended event 标志着 saga 事务请求的结束，不需要保存任何内容</li> \n </ul> \n <p><img src=\"/assets/66ae7b320e502c13f4a21a08baa61ead.png\" alt=\"\"></p> \n <p>通过将这些事件持久化在 saga log 中，我们可以将 saga 恢复到上述任何状态。</p> \n <p>由于 Saga 只需要做事件的持久化，而事件内容以 JSON 的形式存储，Saga log 的实现非常灵活，数据库（SQL 或 NoSQL），持久消息队列，甚至普通文件可以用作事件存储，当然有些能更快得帮 saga 恢复状态。</p> \n <h4 id=\"Saga-请求的数据结构\"><a href=\"#Saga-请求的数据结构\" class=\"headerlink\" title=\"Saga 请求的数据结构\"></a>Saga 请求的数据结构</h4>\n <p>在我们的业务场景下，航班预订、租车、和酒店预订没有依赖关系，可以并行处理，但对于我们的客户来说，只在所有预订成功后一次付费更加友好。那么这四个服务的事务关系可以用下图表示：</p> \n <p><img src=\"/assets/918b4d0d912c6cdb8ee0690acf303950.png\" alt=\"\"></p> \n <p>将行程规划请求的数据结构实现为有向非循环图恰好合适。图的根是 saga 启动任务，叶是 saga 结束任务。</p> \n <p><img src=\"/assets/c62a633865fd31b25688523cb5f4093f.png\" alt=\"\"></p> \n <h4 id=\"Parallel-Saga\"><a href=\"#Parallel-Saga\" class=\"headerlink\" title=\"Parallel Saga\"></a>Parallel Saga</h4>\n <p>如上所述，航班预订，租车和酒店预订可以并行处理。但是这样做会造成另一个问题：如果航班预订失败，而租车正在处理怎么办？我们不能一直等待租车服务回应，因为不知道需要等多久。</p> \n <p>最好的办法是再次发送租车请求，获得回应，以便我们能够继续补偿操作。但如果租车服务永不回应，我们可能需要采取回退措施，比如手动干预。</p> \n <p>超时的预订请求可能最后仍被租车服务收到，这时服务已经处理了相同的预订和取消请求。</p> \n <p><img src=\"/assets/b683af658000f43b34c7d99d6be060ca.png\" alt=\"\"></p> \n <p>因此，服务的实现必须保证补偿请求执行以后，再次收到的对应事务请求无效。 Caitie McCaffrey 在她的演讲 Distributed Sagas: A Protocol for Coordinating MicroServices 中把这个称为可交换的补偿请求 (commutative compensating request)。</p> \n <h4 id=\"ACID-and-Saga\"><a href=\"#ACID-and-Saga\" class=\"headerlink\" title=\"ACID and Saga\"></a>ACID and Saga</h4>\n <p>ACID 是具有以下属性的一致性模型：</p> \n <ul> \n  <li>原子性（Atomicity）</li> \n  <li>一致性（Consistency）</li> \n  <li>隔离性（Isolation）</li> \n  <li>持久性（Durability）</li> \n </ul> \n <p>Saga 不提供 ACID 保证，因为原子性和隔离性不能得到满足。原论文描述如下：</p> \n <blockquote> \n  <p>full atomicity is not provided. That is, sagas may view the partial results of other sagas</p> \n </blockquote> \n <p>通过 saga log，saga 可以保证一致性和持久性。</p> \n <h4 id=\"Saga-架构\"><a href=\"#Saga-架构\" class=\"headerlink\" title=\"Saga 架构\"></a>Saga 架构</h4>\n <p>最后，我们的 Saga 架构如下：</p> \n <p><img src=\"/assets/44bd3121a8b6d720704e2d8b363ea2ce.png\" alt=\"\"></p> \n <ul> \n  <li>Saga Execution Component 解析请求 JSON 并构建请求图</li> \n  <li>TaskRunner 用任务队列确保请求的执行顺序</li> \n  <li>TaskConsumer 处理 Saga 任务，将事件写入 saga log，并将请求发送到远程服务</li> \n </ul> \n <p>在上文中，我谈到了 ServiceComb 下的 Saga 是怎么设计的。 然而，业界还有其他数据一致性解决方案，如 <strong>两阶段提交（2PC）</strong> 和 <strong>Try-Confirm / Cancel（TCC）</strong>。那 saga 相比之下有什么特别？</p> \n <h3 id=\"两阶段提交-Two-Phase-Commit-2PC\"><a href=\"#两阶段提交-Two-Phase-Commit-2PC\" class=\"headerlink\" title=\"两阶段提交 Two-Phase Commit (2PC)\"></a>两阶段提交 Two-Phase Commit (2PC)</h3>\n <blockquote> \n  <p>两阶段提交协议是一种分布式算法，用于协调参与分布式原子事务的所有进程，以保证他们均完成提交或中止（回滚）事务。</p> \n </blockquote> \n <p>2PC 包含两个阶段：</p> \n <ul> \n  <li>投票阶段 协调器向所有服务发起投票请求，服务回答 yes 或 no。如果有任何服务回复 no 以拒绝或超时，协调器则在下一阶段发送中止消息。</li> \n </ul> \n <p><img src=\"/assets/b8624ace7c31f49016bde30abf444af0.png\" alt=\"\"> </p> \n <ul> \n  <li>决定阶段 如果所有服务都回复 yes，协调器则向服务发送 commit 消息，接着服务告知事务完成或失败。如果任何服务提交失败， 协调器将启动额外的步骤以中止该事务。</li> \n </ul> \n <p><img src=\"/assets/f29111544bc473085109d3d04788be44.png\" alt=\"\"></p> \n <p>在投票阶段结束之后与决策阶段结束之前，服务处于不确定状态，因为他们不确定交易是否继续进行。当服务处于不确定状态并与协调器失去连接时，它只能选择等待协调器的恢复，或者咨询其他在确定状态下的服务来得知协调器的决定。在最坏的情况下，n 个处于不确定状态的服务向其他 n-1 个服务咨询将产生 O(n2) 个消息。</p> \n <p>另外，2PC 是一个阻塞协议。服务在投票后需要等待协调器的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度高，2PC 不能适应随着事务涉及的服务数量增加而扩展的需要。</p> \n <h3 id=\"Try-Confirm-Cancel-TCC\"><a href=\"#Try-Confirm-Cancel-TCC\" class=\"headerlink\" title=\"Try-Confirm/Cancel (TCC)\"></a>Try-Confirm/Cancel (TCC)</h3>\n <p>TCC 也是补偿型事务模式，支持两阶段的商业模型。</p> \n <ul> \n  <li>尝试阶段 将服务置于待处理状态。例如，收到尝试请求时，航班预订服务将为客户预留一个座位，并在数据库插入客户预订记录，将记录设为预留状态。如果任何服务失败或超时，协调器将在下一阶段发送取消请求。</li> \n </ul> \n <p><img src=\"/assets/b09bbf2e8d332c163934ce165eab883e.png\" alt=\"\"></p> \n <ul> \n  <li>确认阶段 将服务设为确认状态。确认请求将确认客户预订的座位，这时服务已可向客户收取机票费用。数据库中的客户预订记录也会被更新为确认状态。如果任何服务无法确认或超时，协调器将重试确认请求直到成功，或在重试了一定次数后采取回退措施，比如人工干预。 </li> \n </ul> \n <p><img src=\"/assets/1e14e4ad4804835734389a7a427ba9c3.png\" alt=\"\"></p> \n <p>与 saga 相比，TCC 的优势在于，尝试阶段将服务转为待处理状态而不是最终状态，这使得设计相应的取消操作轻而易举。</p> \n <p>例如，电邮服务的尝试请求可将邮件标记为准备发送，并且仅在确认后发送邮件，其相应的取消请求只需将邮件标记为已废弃。但如果使用 saga，事务将发送电子邮件，及其相应的补偿事务可能需要发送另一封电子邮件作出解释。</p> \n <p>TCC 的缺点是其两阶段协议需要设计额外的服务待处理状态，以及额外的接口来处理尝试请求。另外，TCC 处理事务请求所花费的时间可能是 saga 的两倍，因为 TCC 需要与每个服务进行两次通信，并且其确认阶段只能在收到所有服务对尝试请求的响应后开始。</p> \n <h3 id=\"事件驱动的架构\"><a href=\"#事件驱动的架构\" class=\"headerlink\" title=\"事件驱动的架构\"></a>事件驱动的架构</h3>\n <p>和 TCC 一样，在事件驱动的架构中，长活事务涉及的每个服务都需要支持额外的待处理状态。接收到事务请求的服务会在其数据库中插入一条新的记录，将该记录状态设为待处理并发送一个新的事件给事务序列中的下一个服务。</p> \n <p>因为在插入记录后服务可能崩溃，我们无法确定是否新事件已发送，所以每个服务还需要额外的事件表来跟踪当前长活事务处于哪一步。</p> \n <p><img src=\"/assets/a94dc9b0b1b2195f9cff27ea3056fd5d.png\" alt=\"\"></p> \n <p>一旦长活事务中的最后一个服务完成其子事务，它将通知它在事务中的前一个服务。接收到完成事件的服务将其在数据库中的记录状态设为完成。</p> \n <p><img src=\"/assets/204d8d1b2939d66cfb9752219ad70920.png\" alt=\"\"></p> \n <p>如果仔细比较，事件驱动的架构就像非集中式的基于事件的 TCC 实现。如果去掉待处理状态而直接把服务记录设为最终状态，这个架构就像非集中式的基于事件的 saga 实现。去中心化能达到服务自治，但也造成了服务之间更紧密的的耦合。假设新的业务需求在服务 B 和 C 之间的增加了新的流程 D。在事件驱动架构下，服务 B 和 C 必须改动代码以适应新的流程 D。</p> \n <p><img src=\"/assets/3f46ba9b45f867c33993cdb81871bfc9.png\" alt=\"\"> </p> \n <p>Saga 则正好相反，所有这些耦合都在 saga 系统中，当在长活事务中添加新流程时，现有服务不需要任何改动。</p> \n <h3 id=\"集中式与非集中式实现\"><a href=\"#集中式与非集中式实现\" class=\"headerlink\" title=\"集中式与非集中式实现\"></a>集中式与非集中式实现</h3>\n <p>这个 Saga 系列的文章讨论的都是集中式的 saga 设计。但 saga 也可用非集中式的方案来实现。那么非集中式的版本有什么不同？</p> \n <p>非集中式 saga 没有专职的协调器。启动下一个服务调用的服务就是当前的协调器。例如：</p> \n <ul> \n  <li>服务 A 收到要求服务 A，B 和 C 之间的数据一致性的事务请求。</li> \n  <li>A 完成其子事务，并将请求传递给事务中的下一个服务，服务 B.</li> \n  <li>B 完成其子事务，并将请求传递给 C，依此类推。</li> \n  <li>如果 C 处理请求失败，B 有责任启动补偿事务，并要求 A 回滚。 </li> \n </ul> \n <p><img src=\"/assets/1a7a9de881f2665697337a03fb1a5c6f.png\" alt=\"\"></p> \n <p>与集中式相比，非集中式的实现具有服务自治的优势。但每个服务都需要包含数据一致性协议，并提供其所需的额外持久化设施。</p> \n <p>我们更倾向于自治的业务服务，但服务还关联很多应用的复杂性，如数据一致性，服务监控和消息传递，将这些棘手问题集中处理，能将业务服务从应用的复杂性中释放，专注于处理复杂的业务，因此我们采用了集中式的 saga 设计。</p> \n <p>另外，随着长活事务中涉及的服务数量增长，服务之间的关系变得越来越难理解。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>本文将 saga 与其他数据一致性解决方案进行了比较。Saga 比两阶段提交更易扩展。在事务可补偿的情况下，相比 TCC，saga 对业务逻辑几乎没有改动的需要，而且性能更高。集中式的 saga 设计解耦了服务与数据一致性逻辑及其持久化设施，并使排查事务中的问题更容易。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(159,12,'如何拆分服务',1,'www.funtl.com/assets/d8a0f183c602fd4e0411771d6f325cfd.jpg',1,'<div class=\"col-sm-12\"> \n <p>如今，市场环境纷繁复杂，瞬息万变，现代企业为了更好地生存，需要有极强的适应能力。<strong>快速而轻松地迎接改变，成为了一个优质企业的特征之一</strong>，同时企业还要求技术团队构建更科学的架构，搭建成本更低的平台，这就使得这些团队越来越倾向于使用微服务架构来应对以上要求。</p> \n <p>微服务的做法有利于软件组件和数据的分散化，将一个整体分解成更小、更容易改变的部分，<strong>分散仅帮助团队加快工程进度，而不会牺牲系统的安全性</strong>。要想让这种架构工作得很好，需要改变工作方式。</p> \n <p>微服务架构的设计，其实是为了使团队能够在执行工作的人之间分配决策权力，向更多成员直接推行决策权，允许他们以更自由的方式生产。微服务架构使用正确的话，将产生更好和更快的变化。但是如果你的架构错误，那么一系列坏的决定可能会降低转化率，甚至会损害你的业务。</p> \n <p><img src=\"/assets/d8a0f183c602fd4e0411771d6f325cfd.jpg\" alt=\"\"></p> \n <p>我们讲决策权分配，即是说微服务架构的拆分实际上就是在寻求正确的权力下放战略。这是一个进化过程，需要不断地进行分析和调整。而如何正确的拆分微服务架构，我认为可以重点从以下三个方面考虑：</p> \n <h3 id=\"1-我们应该做哪些决定？\"><a href=\"#1-我们应该做哪些决定？\" class=\"headerlink\" title=\"1. 我们应该做哪些决定？\"></a>1. 我们应该做哪些决定？</h3>\n <p>设计微服务系统不仅仅是改变组件大小，架构中涉及创建和更改服务的所有领域都有一定的作用。在这里总结了以下九个方面，作为拆分微服务架构时所做决定的参考：</p> \n <ul> \n  <li>生命周期：什么时候创建或停止服务？我们什么时候需要将它们分开？</li> \n  <li>服务实现：我们应该在每个服务中使用哪些工具、语言和架构？</li> \n  <li>系统架构：服务如何引导他人？开发人员如何了解？</li> \n  <li>数据架构：服务之间如何共享数据？</li> \n  <li>变更过程：什么时候可以改变服务？部署和 QA 的工具和过程？</li> \n  <li>团队管理：谁在哪个团队服务？每个团队负责什么？团队成员做了什么？</li> \n  <li>人事管理：人员如何被雇用和解雇？员工如何激励和奖励？</li> \n  <li>安全管理：我们如何降低安全事故的风险？需要做些什么来改善整个系统的安全性？</li> \n  <li>采购过程：可以购买什么软件？使用开源软件需要哪些保护？</li> \n </ul> \n <h3 id=\"2-涉及到哪些人？\"><a href=\"#2-涉及到哪些人？\" class=\"headerlink\" title=\"2. 涉及到哪些人？\"></a>2. 涉及到哪些人？</h3>\n <p>不得不承认，一个员工做出的一些决定对他们的公司来说可能是非常有影响力的。一个很典型的现象是，公司试图对内部的决策者增加控制，以便将风险降至最低，从而导致决策权集中化。例如，在过去的几年中，苹果以拥有一个高度集中的设计团队而闻名，少数的人做出产品设计的大部分决策。</p> \n <p>集中发生是因为正确的人需要做出最重要的决定。通常，<strong>“正确的人”是具有天赋，专业知识和经验的组合</strong>，使我们能够相信他们做出最好的决定，我们可以称这些人为我们的“明星决策者”。但实际上，公司的“明星决策者”数量有限，大多数团队只有几颗“明星”。</p> \n <p>微服务改变了这种少数人行使决策权的现象，同时更容易应对错误的决策。如果一个团队在微服务工作时作出错误的决定，其错误的波及范围会很小，容错率变高。当系统的更改变得便宜和容易时，团队可以快速改进先前的决策，使他们能够更快地获得最佳决策。</p> \n <p><img src=\"/assets/28ac7af07ba332c29e9a0d91030b0af1.png\" alt=\"\"></p> \n <h3 id=\"3-谁拥有哪一部分？\"><a href=\"#3-谁拥有哪一部分？\" class=\"headerlink\" title=\"3. 谁拥有哪一部分？\"></a>3. 谁拥有哪一部分？</h3>\n <p>决策基于选择，而选择又基于领域知识。决策不应该立即执行，它需要一个过程，需要高度专业的技能或知识来实现。</p> \n <p>管理专家亨利•明茨伯格（Henry Mintzberg）为我们提供了一个很好的模式，其中概述了决策过程的步骤：</p> \n <ul> \n  <li>研究与信息采集</li> \n  <li>生成选择</li> \n  <li>做出选择</li> \n  <li>授权的选择</li> \n  <li>执行和实施</li> \n </ul> \n <p>所有这一切的关键，是在采用决策分权化时，不需要绝对。每个步骤都可以独立集中或分散化，在平衡效率和安全性时，可以获得更大的灵活性。如今，集中选择与非集中选择相结合，也是现在很多大公司常见的模式。</p> \n <p>当人们谈论微服务架构时，权力下放过程的选择、授权和执行部分相互协作、快速、规模化地移动，这些都降低了变化来临时对整体系统产生的负面影响。它是提高变革速度的有效途径，但不要忘记，你的成员特点、团队协调，以及所有的系统、工具和工作环境同样重要。</p> \n <p>你必须了解如何做出决策，如何改进流程，这才是迎接变化的好方法。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(160,12,'Spring MVC 启动流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 <code>web.xml</code> 文件中给 Spring MVC 的 Servlet 配置了 <code>load-on-startup</code>，所以程序启动的时候会初始化 Spring MVC，在 <code>HttpServletBean</code> 中将配置的 <code>contextConfigLocation</code> 属性设置到 Servlet 中，然后在 <code>FrameworkServlet</code> 中创建了 <code>WebApplicationContext</code>，<code>DispatcherServlet</code> 根据 <code>contextConfigLocation</code> 配置的 <code>classpath</code> 下的 xml 文件初始化了 Spring MVC 总的组件。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(161,12,'微服务的安全',1,'www.funtl.com/assets/201804100306001.png',1,'<div class=\"col-sm-12\"> \n <p>OAuth 是一个关于授权的开放网络标准，它允许第三方网站在用户授权的前提下访问用户在服务商那里存储的各种信息。实际上，OAuth 2.0 允许用户提供一个令牌给第三方网站，一个令牌对应一个特定的第三方网站，同时该令牌只能在特定的时间内访问特定的资源。用户在客户端使用用户名和密码在用户中心获得授权，然后客户端在访问应用是附上 Token 令牌。此时，应用接收到客户端的 Token 令牌到用户中心进行认证。</p> \n <p><img src=\"/assets/201804100306001.png\" alt=\"\"></p> \n <p>一般情况下，access token 会添加到 HTTP Header 的 Authorization 参数中使用，其中经常使用到的是 Bearer Token 与 Mac Token。其中，Bearer Token 适用于安全的网络下 API 授权。MAC Token 适用于不安全的网络下 API 授权。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(162,12,'如何应对微服务的链式调用异常',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>一般情况下，每个微服务之间是独立的，如果某个服务宕机，只会影响到当前服务，而不会对整个业务系统产生影响。但是，服务端可能会在多个微服务之间产生一条链式调用，并把整合后的信息返回给客户端。在调用过程中，如果某个服务宕机或者网络不稳定可能造成整个请求失败。因此，为了应对微服务的链式调用异常，我们需要在设计微服务调用链时不宜过长，以免客户端长时间等待，以及中间环节出现错误造成整个请求失败。此外，可以考虑使用消息队列进行业务解耦，并且使用缓存避免微服务的链式调用从而提高该接口的可用性。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:32','2018-12-19 15:45:32'),
(163,12,'Session 分布式方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"基于-nfs-net-filesystem-的-Session-共享\"><a href=\"#基于-nfs-net-filesystem-的-Session-共享\" class=\"headerlink\" title=\"基于 nfs(net filesystem) 的 Session 共享\"></a>基于 nfs(net filesystem) 的 Session 共享</h3>\n <p>将共享服务器目录 mount 各服务器的本地 session 目录，session 读写受共享服务器 io 限制，<strong>不能满足高并发</strong>。</p> \n <h3 id=\"基于关系数据库的-Session-共享\"><a href=\"#基于关系数据库的-Session-共享\" class=\"headerlink\" title=\"基于关系数据库的 Session 共享\"></a>基于关系数据库的 Session 共享</h3>\n <p>这种方案普遍使用。使用关系数据库存储 session 数据，对于 mysql 数据库，建议使用 heap 引擎。这种方案性能取决于数据库的性能，在高并发下容易造成表锁（虽然可以采用行锁的存储引擎，性能会下降），并且需要自己实现 session 过期淘汰机制。</p> \n <h3 id=\"基于-Cookie-的-Session-共享\"><a href=\"#基于-Cookie-的-Session-共享\" class=\"headerlink\" title=\"基于 Cookie 的 Session 共享\"></a>基于 Cookie 的 Session 共享</h3>\n <p>这种方案也在大型互联网中普遍使用，将用户的 session 加密序列化后以 cookie 的方式保存在网站根域名下（比如 taobao.com），当用户访问所有二级域名站点式，浏览器会传递所有匹配的根域名的 cookie 信息，这样实现了用户 cookie 化 session 的多服务共享。此方案能够节省大量服务器资源，缺点是存储的信息长度受到 http 协议限制；cookie 的信息还需要做加密解密；请求任何资源时都会将 cookie 附加到 http 头上传到服务器，占用了一定带宽。</p> \n <h3 id=\"基于-Web-容器的-Session-机制\"><a href=\"#基于-Web-容器的-Session-机制\" class=\"headerlink\" title=\"基于 Web 容器的 Session 机制\"></a>基于 Web 容器的 Session 机制</h3>\n <p>利用容器机制，通过配置即可实现。</p> \n <h3 id=\"基于-Zookeeper-的分布式-Session-存储\"><a href=\"#基于-Zookeeper-的分布式-Session-存储\" class=\"headerlink\" title=\"基于 Zookeeper 的分布式 Session 存储\"></a>基于 Zookeeper 的分布式 Session 存储</h3>\n <h3 id=\"基于-Redis-Memcached-的-Session-共享存储\"><a href=\"#基于-Redis-Memcached-的-Session-共享存储\" class=\"headerlink\" title=\"基于 Redis/Memcached 的 Session 共享存储\"></a>基于 Redis/Memcached 的 Session 共享存储</h3>\n <p>这些 key/value 非关系存储有较高的性能，轻松达到 2000 左右的 qps，内置的过期机制正好满足 session 的自动实效特性。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:33','2018-12-19 15:45:33'),
(164,12,'谈谈业务中使用分布式的场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先，需要了解系统为什么使用分布式。</p> \n <p>随着互联网的发展，传统单工程项目的很多性能瓶颈越发凸显，性能瓶颈可以有几个方面：</p> \n <ol> \n  <li>应用服务层：随着用户量的增加，并发量增加，单项目难以承受如此大的并发请求导致的性能瓶颈。</li> \n  <li>底层数据库层：随着业务的发展，数据库压力越来越大，导致的性能瓶颈。</li> \n </ol> \n <h3 id=\"场景1：应用系统集群的-Session-共享\"><a href=\"#场景1：应用系统集群的-Session-共享\" class=\"headerlink\" title=\"场景1：应用系统集群的 Session 共享\"></a>场景1：应用系统集群的 Session 共享</h3>\n <p>应用系统集群最简单的就是服务器集群，比如：Tomcat 集群。应用系统集群的时候，比较凸显的问题是 Session 共享，Session 共享我们一是可以通过服务器插件来解决。另外一种也可以通过 Redis 等中间件实现。</p> \n <h3 id=\"场景2：应用系统的服务化拆分\"><a href=\"#场景2：应用系统的服务化拆分\" class=\"headerlink\" title=\"场景2：应用系统的服务化拆分\"></a>场景2：应用系统的服务化拆分</h3>\n <p>服务化拆分，是目前非常火热的一种方式。现在都在提微服务。通过对传统项目进行服务化拆分，达到服务独立解耦，单服务又可以横向扩容。服务化拆分遇到的经典问题就是分布式事务问题。目前，比较常用的分布式事务解决方案有几种：消息最终一致性、TCC 补偿型事务等。</p> \n <h3 id=\"场景3：底层数据库的压力分摊\"><a href=\"#场景3：底层数据库的压力分摊\" class=\"headerlink\" title=\"场景3：底层数据库的压力分摊\"></a>场景3：底层数据库的压力分摊</h3>\n <p>如果系统的性能压力出现在数据库，那我们就可以读写分离、分库分表等方案进行解决。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:33','2018-12-19 15:45:33'),
(165,12,'说说最终一致性的实现方案',1,'www.funtl.com/assets/006kbv1Jgw1f31xaggg0bj30cq09mq3h.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"问题的起源\"><a href=\"#问题的起源\" class=\"headerlink\" title=\"问题的起源\"></a>问题的起源</h3>\n <p>在电商等业务中，系统一般由多个独立的服务组成，如何解决分布式调用时候数据的一致性？ </p> \n <p>具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。</p> \n <p>在分布式系统来说，如果不想牺牲一致性，CAP 理论告诉我们只能放弃可用性，这显然不能接受。为了便于讨论问题，先简单介绍下数据一致性的基础理论。</p> \n <h4 id=\"强一致\"><a href=\"#强一致\" class=\"headerlink\" title=\"强一致\"></a>强一致</h4>\n <p>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</p> \n <h4 id=\"弱一致性\"><a href=\"#弱一致性\" class=\"headerlink\" title=\"弱一致性\"></a>弱一致性</h4>\n <p>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</p> \n <h4 id=\"最终一致性\"><a href=\"#最终一致性\" class=\"headerlink\" title=\"最终一致性\"></a>最终一致性</h4>\n <p>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。</p> \n <p>在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别，群友的讨论分成以下 6 种解决方案。</p> \n <h3 id=\"1-规避分布式事务——业务整合\"><a href=\"#1-规避分布式事务——业务整合\" class=\"headerlink\" title=\"1. 规避分布式事务——业务整合\"></a>1. 规避分布式事务——业务整合</h3>\n <p>业务整合方案主要采用将接口整合到本地执行的方法。拿问题场景来说，则可以将服务 A、B、C 整合为一个服务 D 给业务，这个服务 D 再通过转换为本地事务的方式，比如服务 D 包含本地服务和服务 E，而服务 E 是本地服务 A ~ C 的整合。</p> \n <p>优点：解决（规避）了分布式事务。</p> \n <p>缺点：显而易见，把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。</p> \n <p>由于这个方法存在明显缺点，<strong>通常不建议使用</strong>。</p> \n <h3 id=\"2-经典方案-eBay-模式\"><a href=\"#2-经典方案-eBay-模式\" class=\"headerlink\" title=\"2. 经典方案 - eBay 模式\"></a>2. 经典方案 - eBay 模式</h3>\n <p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p> \n <p><strong>消息日志方案的核心是保证服务接口的幂等性。</strong></p> \n <p>考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。</p> \n <p>eBay 方式的主要思路如下。</p> \n <h4 id=\"BASE：一种-ACID-的替代方案\"><a href=\"#BASE：一种-ACID-的替代方案\" class=\"headerlink\" title=\"BASE：一种 ACID 的替代方案\"></a>BASE：一种 ACID 的替代方案</h4>\n <p>此方案是 eBay 的架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章，是一篇解释 BASE 原则，或者说最终一致性的经典文章。文中讨论了 BASE 与 ACID 原则在保证数据一致性的基本差异。</p> \n <p>如果 ACID 为分区的数据库提供一致性的选择，那么如何实现可用性呢？</p> \n <h4 id=\"BASE-basically-available-soft-state-eventually-consistent\"><a href=\"#BASE-basically-available-soft-state-eventually-consistent\" class=\"headerlink\" title=\"BASE (basically available, soft state, eventually consistent)\"></a>BASE (basically available, soft state, eventually consistent)</h4>\n <p>BASE 的可用性是通过 <strong>支持局部故障</strong> 而不是系统全局故障来实现的。下面是一个简单的例子：如果将用户分区在 5 个数据库服务器上，BASE 设计鼓励类似的处理方式，一个用户数据库的故障只影响这台特定主机那 20% 的用户。这里不涉及任何魔法，不过它确实可以带来更高的可感知的系统可用性。</p> \n <p>文章中描述了一个最常见的场景，如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。这两个表属于不同的远程服务，所以就涉及到分布式事务一致性的问题</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xaggg0bj30cq09mq3h.jpg\" alt=\"\"></p> \n <p>文中提出了一个经典的解决方法，将主要修改操作以及更新用户表的消息放在 <strong>一个本地事务</strong> 来完成。同时为了避免重复消费用户表消息带来的问题，达到多次重试的幂等性，<strong>增加一个更新记录表 updates_applied</strong> 来记录已经处理过的消息。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xaq6ex2j30ct082wev.jpg\" alt=\"\"></p> \n <p>系统的执行伪代码如下：</p> \n <pre><code>Begin transaction\n    Insert into transaction(id, selller_id, buyer_id, amount);\n    Queue message \"update user(\'seller\', selller_id, amount)\";\n    Queue message \"update user(\'buyer\', buyer_id, amount)\";\nEnd transaction\n\nFor each message in queue\n    Peek message\n    Begin transaction\n        Select count(*) as processed where trans_id = message.trans_id\n            and balance = message.balance and user_id = message.user_id\n        if processed == 0\n            if message.balance == \"seller\"\n                Update user set amt_sold = amt_sold + message.amount\n                    where id = message.id;\n\n            Else\n                Update user set amt_bought = amt_bought + message.amount\n                    where id = message.id\n\n            End if\n\n        Insert int updates_applied\n            (message.trans_id, message.balance, message.user_id);\n        End if\n    End transaction\n\n    if transaction successful\n        Remove message from queue\n    End if\nEnd for\n</code></pre>\n <p>基于以上方法，在第一阶段，通过本地的数据库的事务保障，增加了 transaction 表及消息队列 。</p> \n <p>在第二阶段，分别读出消息队列（但不删除），通过判断更新记录表 updates_applied 来检测相关记录是否被执行，未被执行的记录会修改 user 表，然后增加一条操作记录到 updates_applied，事务执行成功之后再删除队列。</p> \n <p>通过以上方法，达到了分布式系统的最终一致性。进一步了解 eBay 的方案可以参考文末链接。</p> \n <h3 id=\"3-去哪儿网分布式事务方案\"><a href=\"#3-去哪儿网分布式事务方案\" class=\"headerlink\" title=\"3. 去哪儿网分布式事务方案\"></a>3. 去哪儿网分布式事务方案</h3>\n <p>随着业务规模不断地扩大，电商网站一般都要面临拆分之路。就是将原来一个单体应用拆分成多个不同职责的子系统。比如以前可能将面向用户、客户和运营的功能都放在一个系统里，现在拆分为订单中心、代理商管理、运营系统、报价中心、库存管理等多个子系统。</p> \n <p><strong>拆分首先要面临的是什么呢？</strong></p> \n <p>最开始的单体应用所有功能都在一起，存储也在一起。比如运营要取消某个订单，那直接去更新订单表状态，然后更新库存表就 ok 了。因为是单体应用，库在一起，这些都可以在一个事务里，由关系数据库来保证一致性。</p> \n <p>但拆分之后就不同了，不同的子系统都有自己的存储。比如订单中心就只管理自己的订单库，而库存管理也有自己的库。那么运营系统取消订单的时候就是通过接口调用等方式来调用订单中心和库存管理的服务了，而不是直接去操作库。这就涉及一个『分布式事务』的问题。 </p> \n <p>分布式事务有两种解决方式</p> \n <h4 id=\"优先使用异步消息\"><a href=\"#优先使用异步消息\" class=\"headerlink\" title=\"优先使用异步消息\"></a>优先使用异步消息</h4>\n <p>上文已经说过，使用异步消息 Consumer 端需要实现幂等。</p> \n <p>幂等有两种方式，<strong>一种方式是业务逻辑保证幂等</strong>。比如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息则说明消息重复了，直接作为消息成功处理。</p> \n <p><strong>另外一种方式如果业务逻辑无法保证幂等，则要增加一个去重表或者类似的实现</strong>。对于 producer 端在业务数据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务里。发消息的时候消息并不立即发出，而是向消息库插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送消息如果成功则将消息库里的消息删除，如果遇到消息队列服务异常或网络问题，消息没有成功发出那么消息就留在这里了，会有另外一个服务不断地将这些消息扫出重新发送。</p> \n <h4 id=\"有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\"><a href=\"#有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\" class=\"headerlink\" title=\"有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\"></a>有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果</h4>\n <p>这种情况的实现方式其实和上面类似，每个参与方的本地业务库的同实例上面放一个事务记录库。</p> \n <p>比如 A 同步调用 B，C。A 本地事务成功的时候更新本地事务记录状态，B 和 C 同样。如果有一次 A 调用 B 失败了，这个失败可能是 B 真的失败了，也可能是调用超时，实际 B 成功。则由一个中心服务对比三方的事务记录表，做一个最终决定。假设现在三方的事务记录是 A 成功，B 失败，C 成功。那么最终决定有两种方式，根据具体场景：</p> \n <ul> \n  <li>重试 B，直到 B 成功，事务记录表里记录了各项调用参数等信息；</li> \n  <li>执行 A 和 B 的补偿操作(一种可行的补偿方式是回滚)。</li> \n </ul> \n <p>对 b 场景做一个特殊说明：比如 B 是扣库存服务，在第一次调用的时候因为某种原因失败了，但是重试的时候库存已经变为 0，无法重试成功，这个时候只有回滚 A 和 C 了。</p> \n <p>那么可能有人觉得在业务库的同实例里放消息库或事务记录库，会对业务侵入，业务还要关心这个库，是否一个合理的设计？</p> \n <p>实际上可以依靠运维的手段来简化开发的侵入，我们的方法是让 DBA 在公司所有 MySQL 实例上预初始化这个库，通过框架层（消息的客户端或事务 RPC 框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要直接访问这个库。</p> \n <p>总结起来，其实两种方式的根本原理是类似的，也就是<strong>将分布式事务转换为多个本地事务，然后依靠重试等方式达到最终一致性。</strong></p> \n <h3 id=\"4-蘑菇街交易创建过程中的分布式一致性方案\"><a href=\"#4-蘑菇街交易创建过程中的分布式一致性方案\" class=\"headerlink\" title=\"4. 蘑菇街交易创建过程中的分布式一致性方案\"></a>4. 蘑菇街交易创建过程中的分布式一致性方案</h3>\n <h4 id=\"交易创建的一般性流程\"><a href=\"#交易创建的一般性流程\" class=\"headerlink\" title=\"交易创建的一般性流程\"></a>交易创建的一般性流程</h4>\n <p>我们把交易创建流程抽象出一系列可扩展的功能点，每个功能点都可以有多个实现（具体的实现之间有组合/互斥关系）。把各个功能点按照一定流程串起来，就完成了交易创建的过程。 </p> \n <p><img src=\"/assets/006kbv1Jgw1f31xdryziuj30i008d0tu.jpg\" alt=\"\"></p> \n <h4 id=\"面临的问题\"><a href=\"#面临的问题\" class=\"headerlink\" title=\"面临的问题\"></a>面临的问题</h4>\n <p>每个功能点的实现都可能会依赖外部服务。那么如何保证各个服务之间的数据是一致的呢？比如锁定优惠券服务调用超时了，不能确定到底有没有锁券成功，该如何处理？再比如锁券成功了，但是扣减库存失败了，该如何处理？</p> \n <h4 id=\"方案选型\"><a href=\"#方案选型\" class=\"headerlink\" title=\"方案选型\"></a>方案选型</h4>\n <p>服务依赖过多，会带来管理复杂性增加和稳定性风险增大的问题。试想如果我们强依赖 10 个服务，9 个都执行成功了，最后一个执行失败了，那么是不是前面 9 个都要回滚掉？这个成本还是非常高的。</p> \n <p>所以在拆分大的流程为多个小的本地事务的前提下，对于非实时、非强一致性的关联业务写入，在本地事务执行成功后，我们选择发消息通知、关联事务异步化执行的方案。</p> \n <p><strong>消息通知往往不能保证 100% 成功；且消息通知后，接收方业务是否能执行成功还是未知数。前者问题可以通过重试解决；后者可以选用事务消息来保证。</strong></p> \n <p>但是事务消息框架本身会给业务代码带来侵入性和复杂性，所以我们选择<strong>基于 DB 事件变化通知到 MQ 的方式</strong>做系统间解耦，通过订阅方消费 MQ 消息时的 ACK 机制，保证消息一定消费成功，达到最终一致性。由于消息可能会被重发，消息订阅方业务逻辑处理要做好幂等保证。</p> \n <p>所以目前只剩下需要实时同步做、有强一致性要求的业务场景了。在交易创建过程中，锁券和扣减库存是这样的两个典型场景。</p> \n <p>要保证多个系统间数据一致，乍一看，必须要引入分布式事务框架才能解决。但引入非常重的类似二阶段提交分布式事务框架会带来复杂性的急剧上升；在电商领域，绝对的强一致是过于理想化的，我们可以选择准实时的最终一致性。</p> \n <p>我们在交易创建流程中，<strong>首先创建一个不可见订单</strong>，然后在同步调用锁券和扣减库存时，针对调用异常（失败或者超时），发出废单消息到MQ。如果消息发送失败，本地会做时间阶梯式的异步重试；优惠券系统和库存系统收到消息后，会进行判断是否需要做业务回滚，这样就准实时地保证了多个本地事务的最终一致性。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xeajfqkj30680i2wez.jpg\" alt=\"\"></p> \n <h3 id=\"5-支付宝及蚂蚁金融云的分布式服务-DTS-方案\"><a href=\"#5-支付宝及蚂蚁金融云的分布式服务-DTS-方案\" class=\"headerlink\" title=\"5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案\"></a>5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案</h3>\n <p>业界常用的还有支付宝的一种 xts 方案，由支付宝在 2PC 的基础上改进而来。主要思路如下，大部分信息引用自官方网站。</p> \n <h4 id=\"分布式事务服务简介\"><a href=\"#分布式事务服务简介\" class=\"headerlink\" title=\"分布式事务服务简介\"></a>分布式事务服务简介</h4>\n <p>分布式事务服务 (Distributed Transaction Service, DTS) 是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。DTS 从架构上分为 xts-client 和 xts-server 两部分，前者是一个嵌入客户端应用的 JAR 包，主要负责事务数据的写入和处理；后者是一个独立的系统，主要负责异常事务的恢复。</p> \n <h4 id=\"核心特性\"><a href=\"#核心特性\" class=\"headerlink\" title=\"核心特性\"></a>核心特性</h4>\n <p>传统关系型数据库的事务模型必须遵守 ACID 原则。在单数据库模式下，ACID 模型能有效保障数据的完整性，但是在大规模分布式环境下，一个业务往往会跨越多个数据库，如何保证这多个数据库之间的数据一致性，需要其他行之有效的策略。在 JavaEE 规范中使用 2PC (2 Phase Commit, 两阶段提交) 来处理跨 DB 环境下的事务问题，但是 2PC 是反可伸缩模式，也就是说，在事务处理过程中，参与者需要一直持有资源直到整个分布式事务结束。这样，当业务规模达到千万级以上时，2PC 的局限性就越来越明显，系统可伸缩性会变得很差。基于此，我们采用 BASE 的思想实现了一套类似 2PC 的分布式事务方案，这就是 DTS。DTS在充分保障分布式环境下高可用性、高可靠性的同时兼顾数据一致性的要求，其最大的特点是保证数据最终一致 (Eventually consistent)。</p> \n <p>简单的说，DTS 框架有如下特性：</p> \n <ul> \n  <li><p>最终一致：事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。</p> </li> \n  <li><p>协议简单：DTS 定义了类似 2PC 的标准两阶段接口，业务系统只需要实现对应的接口就可以使用 DTS 的事务功能。</p> </li> \n  <li><p>与 RPC 服务协议无关：在 SOA 架构下，一个或多个 DB 操作往往被包装成一个一个的 Service，Service 与 Service 之间通过 RPC 协议通信。DTS 框架构建在 SOA 架构上，与底层协议无关。</p> </li> \n  <li><p>与底层事务实现无关： DTS 是一个抽象的基于 Service 层的概念，与底层事务实现无关，也就是说在 DTS 的范围内，无论是关系型数据库 MySQL，Oracle，还是 KV 存储 MemCache，或者列存数据库 HBase，只要将对其的操作包装成 DTS 的参与者，就可以接入到 DTS 事务范围内。</p> </li> \n </ul> \n <p>以下是分布式事务框架的流程图</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xfuizhpj30a70b7q3x.jpg\" alt=\"\"></p> \n <h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4>\n <ul> \n  <li><p>一个完整的业务活动由一个主业务服务与若干从业务服务组成。</p> </li> \n  <li><p>主业务服务负责发起并完成整个业务活动。</p> </li> \n  <li><p>从业务服务提供 TCC 型业务操作。</p> </li> \n  <li><p>业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在活动提交时确认所有的两阶段事务的 confirm 操作，在业务活动取消时调用所有两阶段事务的 cancel 操作。”</p> </li> \n </ul> \n <h4 id=\"与-2PC-协议比较\"><a href=\"#与-2PC-协议比较\" class=\"headerlink\" title=\"与 2PC 协议比较\"></a>与 2PC 协议比较</h4>\n <ul> \n  <li><p>没有单独的 Prepare 阶段，降低协议成本</p> </li> \n  <li><p>系统故障容忍度高，恢复简单</p> </li> \n </ul> \n <h3 id=\"6-农信网数据一致性方案\"><a href=\"#6-农信网数据一致性方案\" class=\"headerlink\" title=\"6. 农信网数据一致性方案\"></a>6. 农信网数据一致性方案</h3>\n <h4 id=\"电商业务\"><a href=\"#电商业务\" class=\"headerlink\" title=\"电商业务\"></a>电商业务</h4>\n <p>公司的支付部门，通过接入其它第三方支付系统来提供支付服务给业务部门，支付服务是一个基于 Dubbo 的 RPC 服务。</p> \n <p>对于业务部门来说，电商部门的订单支付，需要调用</p> \n <ul> \n  <li><p>支付平台的支付接口来处理订单；</p> </li> \n  <li><p>同时需要调用积分中心的接口，按照业务规则，给用户增加积分。</p> </li> \n </ul> \n <p>从业务规则上需要同时保证业务数据的实时性和一致性，也就是支付成功必须加积分。</p> \n <p>我们采用的方式是同步调用，首先处理本地事务业务。考虑到积分业务比较单一且业务影响低于支付，由积分平台提供增加与回撤接口。</p> \n <p>具体的流程是先调用积分平台增加用户积分，再调用支付平台进行支付处理，如果处理失败，catch 方法调用积分平台的回撤方法，将本次处理的积分订单回撤。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xgmb4wrj30hl09rgmn.jpg\" alt=\"\"></p> \n <h4 id=\"用户信息变更\"><a href=\"#用户信息变更\" class=\"headerlink\" title=\"用户信息变更\"></a>用户信息变更</h4>\n <p>公司的用户信息，统一由用户中心维护，而用户信息的变更需要同步给各业务子系统，业务子系统再根据变更内容，处理各自业务。用户中心作为 MQ 的 producer，添加通知给 MQ。APP Server 订阅该消息，同步本地数据信息，再处理相关业务比如 APP 退出下线等。</p> \n <p>我们采用异步消息通知机制，目前主要使用 ActiveMQ，基于 Virtual Topic 的订阅方式，保证单个业务集群订阅的单次消费。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xhl94fyj30hu08qt9j.jpg\" alt=\"\"></p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>分布式服务对衍生的配套系统要求比较多，特别是我们基于消息、日志的最终一致性方案，需要考虑消息的积压、消费情况、监控、报警等。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:34','2018-12-19 15:45:34'),
(166,12,'对于快速追踪与定位问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在微服务复杂的链式调用中，我们会比单体架构更难以追踪与定位问题。因此，在设计的时候，需要特别注意。一种比较好的方案是，当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。其中，code 字段用来表示某类错误的错误码，在微服务中应该加上“{biz_name}/”前缀以便于定位错误发生在哪个业务系统上。我们来看一个案例，假设“用户中心”某个接口没有权限获取资源而出现错误，我们的业务系统可以响应“UC/AUTH_DENIED”，并且通过自动生成的 UUID 值的 request_id 字段，在日志系统中获得错误的详细信息。</p> \n <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n</code></pre>\n <p>此外，我们需要在记录日志时，标记出错误来源以及错误详情便于更好地分析与定位问题。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:34','2018-12-19 15:45:34'),
(167,12,'集群与负载均衡的算法与实现',1,'www.funtl.com/assets/e58ab31f70ef56e074051ed24fa4e56ec19decce.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3>\n <p>什么是负载均衡呢？用户输入的流量通过负载均衡器按照某种负载均衡算法把流量均匀的分散到后端的多个服务器上，接收到请求的服务器可以独立的响应请求，达到负载分担的目的。从应用场景上来说，常见的负载均衡模型有全局负载均衡和集群内负载均衡，从产品形态角度来说，又可以分为硬件负载均衡和软件负载均衡。全局负载均衡一般通过DNS实现，通过将一个域名解析到不同VIP，来实现不同的region调度能力；硬件负载均衡器常见的有F5、A10、Array，它们的优缺点都比较明显，优点是功能强大，有专门的售后服务团队，性能比较好，缺点是缺少定制的灵活性，维护成本较高；现在的互联网更多的思路是通过软件负载均衡来实现，这样可以满足各种定制化需求，常见的软件负载均衡有 LVS、Nginx、Haproxy。</p> \n <p><img src=\"/assets/e58ab31f70ef56e074051ed24fa4e56ec19decce.png\" alt=\"\"></p> \n <p>阿里云高性能负载均衡使用 LVS 和 Tengine，我们在一个 region 区分不同的机房,每个机房都有 LVS 集群和 Tengine 集群，对于用户配置的四层监听，LVS 后面会直接挂载用户 ECS，七层用户监听 ECS 则挂载在 Tengine 上，四层监听的流量直接由 LVS 转发到 ECS，而 7 层监听的流量会经过 LVS 到 Tenigine 再到用户 ECS。每一个 region 里都会有多个可用区，达到主备容灾目的，每一个集群里都有多台设备，第一是为了提升性能，第二也是基于容灾考虑。</p> \n <p><img src=\"/assets/fc98cdbdb5e1c6f3f2bba08642b14aa5b95191cb.png\" alt=\"\"></p> \n <p>图为高性能负载均衡控制管理概要图，SLB 产品也有 SDN 概念，转发和控制是分离的，用户所有配置通过控制台先到控制器，通过集中控制器转换将用户配置推送到不同设备上，每台设备上都有 Agent 接收控制器下发的需求，通过本地转换成 LVS 和 Tengine 能够识别的配置，这个过程支持热配置，不影响用户转发，不需要 reload 才能使新配置生效。</p> \n <h3 id=\"LVS\"><a href=\"#LVS\" class=\"headerlink\" title=\"LVS\"></a>LVS</h3>\n <h4 id=\"LVS-支持的三种模式\"><a href=\"#LVS-支持的三种模式\" class=\"headerlink\" title=\"LVS 支持的三种模式\"></a>LVS 支持的三种模式</h4>\n <p><img src=\"/assets/bc742829577c79b6040b743e07d176e8d815e512.png\" alt=\"\"></p> \n <p>早期 LVS 支持三种模式，<strong>DR 模式</strong>、<strong>TUN 模式</strong>和 <strong>NAT 模式</strong>。</p> \n <h5 id=\"DR-模式\"><a href=\"#DR-模式\" class=\"headerlink\" title=\"DR 模式\"></a>DR 模式</h5>\n <p>DR 模式经过 LVS 之后，LVS 会将 MAC 地址更改、封装 MAC 头，内层 IP 报文不动，报文经过 LVS 负载均衡查找到 RS 之后，将源 MAC 头改成自己的，目的 MAC 改成 RS 地址，MAC 寻址是在二层网络里，对网络部署有一定的限定，在大规模分布式集群部署里，这种模式的灵活性没有办法满足需求；</p> \n <h5 id=\"TUN-模式\"><a href=\"#TUN-模式\" class=\"headerlink\" title=\"TUN 模式\"></a>TUN 模式</h5>\n <p>TUN 模式走在 LVS 之后，LVS 会在原有报文基础上封装 IP 头，到了后端 RS 之后，RS 需要解开 IP 报文封装，才能拿到原始报文，不管是 DR 模式还是 TUN 模式，后端 RS 都可以看到真实客户源 IP，目的 IP 是自己的 VIP，VIP 在 RS 设备上需要配置，这样可以直接绕过 LVS 返回给用户，TUN 模式问题在于需要在后端 ECS 上配置解封装模块，在 Linux 上已经支持这种模块，但是 Windows 上还没有提供支持，所以会对用户系统镜像选择有限定。</p> \n <h5 id=\"NAT-模式\"><a href=\"#NAT-模式\" class=\"headerlink\" title=\"NAT 模式\"></a>NAT 模式</h5>\n <p>NAT 模式用户访问的是 VIP，LVS 查找完后会将目的 IP 做 DNAT 转换，选择出 RS 地址，因为客户端的 IP 没变，在回包的时候直接向公网真实客户端 IP 去路由，NAT 的约束是因为 LVS 做了 DNAT 转换，所以回包需要走 LVS，把报文头转换回去，由于 ECS 看到的是客户端真实的源地址，我们需要在用户 ECS 上配置路由，将到 ECS 的默认路由指向 LVS 上，这对用户场景也做了限制。</p> \n <h4 id=\"LVS-基于-NetFilter-框架实现\"><a href=\"#LVS-基于-NetFilter-框架实现\" class=\"headerlink\" title=\"LVS 基于 NetFilter 框架实现\"></a>LVS 基于 NetFilter 框架实现</h4>\n <p><img src=\"/assets/43e30887518af02f3c95557141b905fabeec779f.png\" alt=\"\"></p> \n <p>NetFilter 是 Linux 提供的网络开放平台，基于平台可以开发自己的业务功能模块，早期好多安全厂商都是基于 NetFilter 做一些业务模型实现，这种模型比较灵活，但通用模型里更多的是兼容性考虑，路径会非常长；而且通用模型中没办法发挥多核特性，目前 CPU 的发展更多是向横向扩展，我们经常见到多路服务器，每路上有多少核，早期通用模型对多核支持并不是特别友善，在多核设计上有些欠缺，导致我们在通用模型上做一些应用开发时的扩展性是有限的，随着核的数量越来越多，性能不增反降。</p> \n <h4 id=\"LVS-的改进\"><a href=\"#LVS-的改进\" class=\"headerlink\" title=\"LVS 的改进\"></a>LVS 的改进</h4>\n <p><img src=\"/assets/f2111dd6c11e8dd6ffb32a4a2156361d461e0ebf.png\" alt=\"\"></p> \n <p>早期模式的各种限制制约了我们的发展，所以我们首先做了 FullNAT，相比原来的 NAT 方式，FullNAT 多了 SNAT 属性，将客户端的原 IP 地址作了转换；其次，我们在并行化上做了处理，充分利用多核实现性能线性提升；然后是快速路径，我们在做网络转发模型时很容易想到设计快速路径和慢速路径，慢速路径更多是解决首包如何通过设备问题，可能需要查ACL或路由，需要判断许多和策略相关的东西，后面所有报文都可以通过快速路径转发出去；还有指令相关优化，利用因特尔特殊指令提升性能；另外针对多核架构，NUMA 多节点内存访问，通过访问 Local 节点内存可能获得更好的延迟表现。</p> \n <p><img src=\"/assets/b8d1657ff0cfc1ff091443c345a3a7da1f602150.png\" alt=\"\"></p> \n <p>客户端进来 IP 首先访问 LVS 的 VIP，原 IP 是客户端的，目的 IP 是 LVS 的 VIP，经过 FullNAT 转换后，原 IP 变成 LVS 的 Local 地址，目的地址是 LVS 选择出来的 RS 地址，这样在 RS 回包时比较容易，只要路由可达，报文一定会交到 LVS 上，不需要在 RS 上做特殊的配置。右面就是 DNAT + SNAT 转换，报文就可以通过 LVS 转发回客户端，这种方式主要带来应用场景部署灵活性选择。</p> \n <p><img src=\"/assets/77941914a0f64ecc7fee32dd248a2df6bac00309.png\" alt=\"\"></p> \n <p>通过并行化实现对 LVS 性能的改善，性能没有办法得到线性提升更多的是因为每条路径都需要访问全局资源，就会不可避免引入锁的开箱，另外，同一条链接上的报文可能分散在不同的核上，大家去访问全局资源时也会导致 cache 的丢失。所以我们通过 RSS 技术把同一个五源组报文扔到同一个 CPU 上处理，保证入方向的所有相同连接上的报文都能交给相同 CPU 处理，每个核在转发出去时都用当前 CPU 上的 Local 地址，通过设置一些 fdir 规则，报文回来时后端 RS 访问的目的地址就是对应 CPU 上的 local 地址，可以交到指定的 CPU 上去处理，这样一条连接上左右方向报文都可以交给同一个 CPU 处理，将流在不同的 CPU 隔离开；另外，我们把所有配置资源包括动态缓存资源在每个 CPU 上作了拷贝，将资源局部化，这使整个流从进入 LVS 到转发出去访问的资源都是固定在一个核上的本地资源，使性能达到最大化，实现线性提升。</p> \n <p>改进后的 LVS 表现如下：</p> \n <ul> \n  <li>出于对容灾和性能提升的考虑，我们做了集群化部署，每个 region 有不同机房，每个机房有多个调度单元，每个单元有多台 LVS 设备；</li> \n  <li>每台 LVS 经过优化后，都能达到更高性能，大容量，单台 LVS 可以达到 <strong>4000W PPS</strong>，<strong>600W CPS</strong>、单个 group 可以到达 <strong>1亿</strong> 并发；</li> \n  <li>支持 region、IDC、集群和应用级的高可用；</li> \n  <li>实现了防攻击功能，并在原版 LVS 上提供了更丰富的功能，可以基于各个维度做管理控制，精确的统计，流量的分析等。</li> \n </ul> \n <h3 id=\"Tengine\"><a href=\"#Tengine\" class=\"headerlink\" title=\"Tengine\"></a>Tengine</h3>\n <p><img src=\"/assets/db1900a027c4c7f66e2560edfaa56ec69437d942.png\" alt=\"\"></p> \n <p>Tengine 在应用过程中也遇到了各种问题，最严重的就是性能问题，我们发现随着 CPU 数量越来越多，QPS 值并没有线性提升；Nginx 本身是多 worker 模型，每个 worker 是单进程模式，多 worker 架构做 CPU 亲和，内部基于事件驱动的模型，其本身已经提供了很高的性能，单核 Nginx 可以跑到 <strong>1W5～2W QPS</strong>。Nginx 往下第一层是 socket API，socket 往下有一层 VFS，再往下是 TCP、IP，socket 层比较薄，经过量化的分析和评估，性能开销最大的是 TCP 协议栈和 VFS 部分，因为同步开销大，我们发现横向扩展不行，对此，我们做了一些优化。</p> \n <p>七层反向代理的路径更长，处理更复杂，所以它的性能比 LVS 低很多，我们比较关注单机和集群的性能，集群性能可以靠堆设备去解决，单机如果不提升，成本会一直增加，从性能角度来看，有以下的优化思路和方向：</p> \n <ul> \n  <li>基于 Kernel 做开发，比如优化协议栈；</li> \n  <li>基于 AliSocket 的优化，AliSocket 是阿里研发的高性能 TCP 协议栈平台，底层是 DPDK，它将资源做了局部化处理，报文分发不同核处理，性能非常出色；</li> \n  <li>HTTPS 业务越来越多，流量逐步递增，我们采用硬件加速卡方式做一些加解密的性能提升，还有 HTTPS 的会话复用；</li> \n  <li>基于 Web 传输层的性能优化</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:34','2018-12-19 15:45:34'),
(168,12,'你如何对需求原型进行理解和拆分',1,'www.funtl.com/assets/f7lRMoelw72Xzm1JGXtA.png',1,'<div class=\"col-sm-12\"> \n <p>某公司的产品面试，面试前该公司让面试者做一道笔试题，笔试题目为：</p> \n <blockquote> \n  <p>针对以下需求提供一个解决方案：在卡牛-信用卡管家APP里面，我们的用户需要一个寻找 附近银行网点/ATM 的功能：</p> \n  <ol> \n   <li>请交付你针对这个需求，设计的 Axure 原型界面的解决方案</li> \n   <li>在原型里面标明业务规则和你对这个需求的分析思考过程（脑图、流程图等等）</li> \n  </ol> \n </blockquote> \n <p>通过本道题目，将讲述为某产品添加一个功能需求，从策划到上线将会走那些流程。</p> \n <p>在一家小型的创业公司，从项目的需求——项目的落实——项目的上线，他们大致会走这样的流程：<code>产品策划</code> – <code>UI设计</code> – <code>研发评审</code> – <code>测试评审</code> – <code>研发阶段</code> – <code>测试阶段</code> – <code>上线</code>。结合那个面试题，详细的讲述产品策划这块，简要的描述一下后续几个流程。</p> \n <p><img src=\"/assets/f7lRMoelw72Xzm1JGXtA.png\" alt=\"\"></p> \n <p>根据以上笔试题，我们可以得知：卡牛-信用卡管家 APP 的用户反馈得知，用户希望在卡牛 APP 有一个可以寻找 附近银行网点／ATM的功能。</p> \n <h3 id=\"产品策划\"><a href=\"#产品策划\" class=\"headerlink\" title=\"产品策划\"></a>产品策划</h3>\n <p>在产品策划中，首先是获取产品需求、然后对产品需求进行筛选、评估。获取产品需求主要来源可以分为<strong>内部渠道和外部渠道。外部渠道的来源于“用户反馈、用户调研、竞品分析、市场、合作伙伴”；内部渠道的来源于“公司战略、产品经理本身、产品数据分析、其他部门的反馈”</strong>。</p> \n <p>当获取到产品需求时，接下就会进行需求评估，<strong>需求评估将会利用以下方法：客户满意度、马斯洛需求、重要紧急四项型、调研强制排序、维度评分排序</strong>。</p> \n <p><strong>维度需求排序的话，一般的排序：企业的发展战略、产品的定位、需求价值度（企业价值、用户价值等）、核心用户占有比例、需求频率的程度等方面</strong>。在这种情况下，一般产品部门都会把所有需求都写在需求评估表中，然后对需求进行评估，如图。在创业型公司来说，大部分的需求一般都是公司战略层次的需求（正所谓老板需求）。</p> \n <p><img src=\"/assets/nEr2nG1D50mXOrfwUUM8.png\" alt=\"\"></p> \n <p>有时候在产品需求的前面，会有一次产品需求调研，这是为了进一步确认此<strong>产品需求的必要性</strong>。在创业型公司来说，一般都是直接省去，直接确定产品需求，然后开始落实。</p> \n <p>当需求确定后，我们进入<strong>产品需求功能的落实</strong>（也就是将产品需求画出来，然后去研发）。在笔试题中已经确定了产品需求，所以我们只需要考虑产品功能如何落实。</p> \n <p>产品功能的落实，<strong>一般会走以下流程：竞品分析（产品功能调研）—绘制流程图—产品原型图的制作—产品部门内部评审</strong>。</p> \n <p>现在我们需要对卡牛 APP 中开发一个“寻找附近银行网点／ATM的功能”。</p> \n <h4 id=\"产品功能调研\"><a href=\"#产品功能调研\" class=\"headerlink\" title=\"产品功能调研\"></a>产品功能调研</h4>\n <ol> \n  <li>挑选竞品。几款地图 APP——百度地图、高德地图</li> \n  <li>分析竞品的功能。在进行功能性调研中，我们需要探讨他们功能的入口、功能的逻辑、及他们功能有哪些值得借鉴学习的地方。</li> \n  <li>创想差异化／专属特色功能。</li> \n </ol> \n <p>以下调研的结果：</p> \n <ol> \n  <li>根据卡牛产品现有的功能和框架，将入口配置“信用卡—我的”功能区域中。</li> \n  <li>在附近-银行页面中，我们可以提供了银行的基本信息，包括（营业厅／ATM名称、具体地点位置、电话号码、距离）。</li> \n  <li>为了增加用户黏性，可以设置“评价服务功能”，时刻了解到该银行的服务情况。</li> \n  <li>开设特色服务功能，在卡牛中设置银行排队预约功能。这个功能的创想主要是来源生活中的观察和留意，大家可以回忆自己平日去银行办理业务时，都需要进行长时间的排队，而且预约的地点只能在规定的银行预约排队，整个体验下来是不是特别低效。</li> \n </ol> \n <h4 id=\"绘制流程图和原型图\"><a href=\"#绘制流程图和原型图\" class=\"headerlink\" title=\"绘制流程图和原型图\"></a>绘制流程图和原型图</h4>\n <p>在绘制流程图的过程中，团子建议大家<strong>不要先急着绘制流程图，先用思维导图绘制一些产品功能的模块，哪些功能需要展现到那些页面，那个区域包括那些信息，理顺思路，然后绘制流程图</strong>，如图。</p> \n <p>画流程是一个锻炼逻辑的活，以下是我画产品功能的逻辑图，分三大块：附近主流程、评价流程、预约流程。大家可以借鉴参考一下。</p> \n <h5 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h5>\n <p><img src=\"/assets/ONXZIubgzBvcy84Xx4ed.png\" alt=\"\"></p> \n <h5 id=\"主流程图——附近\"><a href=\"#主流程图——附近\" class=\"headerlink\" title=\"主流程图——附近\"></a>主流程图——附近</h5>\n <p><img src=\"/assets/QjCZNjWkPmo1kJh4ilC8.png\" alt=\"\"></p> \n <h5 id=\"流程图——评价\"><a href=\"#流程图——评价\" class=\"headerlink\" title=\"流程图——评价\"></a>流程图——评价</h5>\n <p><img src=\"/assets/z6gJbfOvbGobGWS8TAb5.png\" alt=\"\"></p> \n <h5 id=\"流程图——预约\"><a href=\"#流程图——预约\" class=\"headerlink\" title=\"流程图——预约\"></a>流程图——预约</h5>\n <p><img src=\"/assets/6kbBXwoXLkuzcCnodwrL.png\" alt=\"\"></p> \n <h4 id=\"原型交互\"><a href=\"#原型交互\" class=\"headerlink\" title=\"原型交互\"></a>原型交互</h4>\n <p>在原型交互的过程中，有些公司需要你在产品原型图上做动态交互，有些公司只需要你在产品原型图上做好交互标明。对此评价一下没做交互动态和做了交互动态的优缺点。</p> \n <p><img src=\"/assets/KVQx3NfESBUeBz4EzHr5.jpg\" alt=\"\"></p> \n <h5 id=\"整体原型图\"><a href=\"#整体原型图\" class=\"headerlink\" title=\"整体原型图\"></a>整体原型图</h5>\n <p><img src=\"/assets/Il1UYXXpYvxzH6lAlabI.png\" alt=\"\"></p> \n <h5 id=\"交互原型图\"><a href=\"#交互原型图\" class=\"headerlink\" title=\"交互原型图\"></a>交互原型图</h5>\n <p><img src=\"/assets/NNOPJZI0E53bdkhe9gGG.png\" alt=\"\"></p> \n <p><img src=\"/assets/TBUwHwDcwQZzJGcdgcM9.png\" alt=\"\"></p> \n <p><img src=\"/assets/rTWtwz6hiWhpUyGJN4eI.png\" alt=\"\"></p> \n <h4 id=\"搜集产品部门内部意见\"><a href=\"#搜集产品部门内部意见\" class=\"headerlink\" title=\"搜集产品部门内部意见\"></a>搜集产品部门内部意见</h4>\n <p>完成原型图的绘制，产品策划也就完成了 90% 的工作，随后就是产品部门的审核，这一项工作将会召集产品部、运营部、UI部门进行讨论和点评，对产品原型图进行进一步优化，此刻你需要搜集其他同事及其他部门的意见，然后收集回来进行整理，筛选出可以优化的需求。</p> \n <h3 id=\"UI设计\"><a href=\"#UI设计\" class=\"headerlink\" title=\"UI设计\"></a>UI设计</h3>\n <p>当面对一般 UI 时，如果你对一般的 UI 说“我需要你帮我设计一款简洁、大气、稳重严肃、不需要太多的色彩的页面”，此时 UI 会一面懵逼，他会反问你一句：“你到告诉我啥叫简洁、大气、稳重严肃”。</p> \n <p>面对公司这样的 UI 时，<strong>最好的解决方式就是自己去找素材，然后找到你喜欢的素材发给 UI</strong>，对着 UI 说“我就要这种风格”。此时 UI 就不会怼你，他就会照着这个做。</p> \n <h3 id=\"研发评审\"><a href=\"#研发评审\" class=\"headerlink\" title=\"研发评审\"></a>研发评审</h3>\n <p>完成以上工作流程之后，在此就会召开研发测试需求评审，这块主要是对此<strong>需求进行排期和了解制作此需求所需要花的时间、此产品需求的可用性</strong>。</p> \n <p>作为产品狗，需要了解目前整个产品的大致动态和产品后期迭代的内容，对此该功能应放在那期迭代中。了解研发部门的情况，确定了研发的时间。</p> \n <h3 id=\"测试评审\"><a href=\"#测试评审\" class=\"headerlink\" title=\"测试评审\"></a>测试评审</h3>\n <p>接下来到了测试评审，在研发中这是一个很重要的环节，需要对<strong>理想期的产品原型图测试和规划</strong>，等到时候研发开发完成了后，需要测试部门进行测试，测试部门会对照理想型的产品图与测试版产品进行比较，写下测试日志文档，为后期的产品功能迭代做好铺垫和准备。因此测试人员会在前期与产品人员进行一次详细的讨论，关于产品原型图的事项，在讨论的过程中<strong>需要对每一个细节和动态进行说明</strong>，所以产品在此要多和测试交流沟通，时刻传达信息给测试人员，做好同步信息。</p> \n <h3 id=\"研发阶段\"><a href=\"#研发阶段\" class=\"headerlink\" title=\"研发阶段\"></a>研发阶段</h3>\n <p>在产品研发过程中，测试和研发是一起进行的。有时候研发要改动产品原型图的需求，研发首先会通知产品，他们要对需求进行改动，一般的改动大概就是“<strong>砍需求、改动态（为什么研发不喜欢看高保证原型）</strong>”，所以产品需要对改动的需求进行快速决策。研发这边改需求，此时产品就要和测试那边沟通，将信息传达给测试。<strong>工作信息要进行时刻同步</strong>。</p> \n <h3 id=\"测试阶段\"><a href=\"#测试阶段\" class=\"headerlink\" title=\"测试阶段\"></a>测试阶段</h3>\n <p>当研发完成初稿后，会提交转测邮件，测试部门会接收此文档进行测试，如有问题，就会将产品测试的 BUG 进行整理，让研发继续修补 BUG，研发修好后，在会进行转测，直到可以上线为止。如果功能越复杂，一般会走好几个来回。</p> \n <p>有人会问，为什么要在研发测试的过程中，平凡发邮件。其实这样是为了进行<strong>权责分明</strong>，同时可以进行工作上的同步。</p> \n <h3 id=\"上线\"><a href=\"#上线\" class=\"headerlink\" title=\"上线\"></a>上线</h3>\n <p>当测试完成后就到了，负责人就要对产品进行申请，发布提交上线邮件将公布给全公司，然后完成了产品的上线。此时是产品狗最幸福的时刻。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:34','2018-12-19 15:45:34'),
(169,12,'说说你对功能性需求的理解',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"用户需求\"><a href=\"#用户需求\" class=\"headerlink\" title=\"用户需求\"></a>用户需求</h3>\n <p>是从某一类用户的视角看他使用这个软件的需求。比如，作为用户你用淘宝，找东西，拍货，付款，你有怎样的需求。作为卖家，你用淘宝怎么收款，发货，管理订单。这就是一个个的 <code>use case</code> 或者 <code>user story</code>。 所以写 <code>user story</code> ， 开头第一句就是 <code>As a xxx</code>. 这都是从个人视角去看需求的。</p> \n <h3 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h3>\n <p>你整理完不同视角的需求，就要一个更高层面，更全局话的角度看需求。就要把这些需求串联起来。特别是把全局的流程梳理出来。从个人角度，是看不到全局的流程的。但是要想把业务梳理清楚，特别是数据流。就需要这种全局视角下的梳理。我们才清楚 <code>use case/user story</code> 是在什么场景下。 特别是有时候，不同的用户的需求可能存在冲突。通过这种全局性的业务需求梳理，可以去发现潜在冲突，并平衡需求。</p> \n <h3 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h3>\n <p>就是把具体的用户需求，变成软件的功能要求。比如客户要把交通事故照片通过 APP 发给保险公司。这是用户需求。 那么功能需求就是在这个模块下，要具有提交报险事故照片功能，上传现场照片。如果再具体下去，就是界面交互图。现在互联网公司一提产品管理，需求设计，基本就是 UX。需求过于碎片化。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:34','2018-12-19 15:45:34'),
(170,12,'说说你对非功能性需求的理解',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>非功能性需求是指依一些条件判断系统运作情形或其特性，而不是针对系统特定行为的需求。包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(171,12,'分布式锁的场景与实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3>\n <p>首先，我们看这样一个场景：客户下单的时候，我们调用库存中心进行减库存，那我们一般的操作都是：</p> \n <pre><code>update store set num = $num where id = $id\n</code></pre>\n <p>这种通过设置库存的修改方式，我们知道在并发量高的时候会存在数据库的丢失更新，比如 a, b 当前两个事务，查询出来的库存都是 5，a 买了 3 个单子要把库存设置为 2，而 b 买了 1 个单子要把库存设置为 4，那这个时候就会出现 a 会覆盖 b 的更新，所以我们更多的都是会加个条件：</p> \n <pre><code>update store set num = $num where id = $id and num = $query_num\n</code></pre>\n <p>即乐观锁的方式来处理，当然也可以通过版本号来处理乐观锁，都是一样的，但是这是更新一个表，如果我们牵扯到多个表呢，我们希望和这个单子关联的所有的表同一时间只能被一个线程来处理更新，多个线程按照不同的顺序去更新同一个单子关联的不同数据，出现死锁的概率比较大。对于非敏感的数据，我们也没有必要去都加乐观锁处理，我们的服务都是多机器部署的，要保证多进程多线程同时只能有一个进程的一个线程去处理，这个时候我们就需要用到分布式锁。分布式锁的实现方式有很多，我们今天分别通过数据库，Zookeeper, Redis 以及 Tair 的实现逻辑。</p> \n <h3 id=\"数据库实现\"><a href=\"#数据库实现\" class=\"headerlink\" title=\"数据库实现\"></a>数据库实现</h3>\n <h4 id=\"加-xx-锁\"><a href=\"#加-xx-锁\" class=\"headerlink\" title=\"加 xx 锁\"></a>加 xx 锁</h4>\n <p>更新一个单子关联的所有的数据，先查询出这个单子，并加上排他锁，在进行一系列的更新操作</p> \n <pre><code>begin transaction；\nselect ...for update；\ndoSomething()；\ncommit();\n</code></pre>\n <p>这种处理主要依靠排他锁来阻塞其他线程，不过这个需要注意几点：</p> \n <ol> \n  <li>查询的数据一定要在数据库里存在，如果不存在的话，数据库会加 gap 锁，而 gap 锁之间是兼容的，这种如果两个线程都加了gap 锁，另一个再更新的话会出现死锁。不过一般能更新的数据都是存在的</li> \n  <li>后续的处理流程需要尽可能的时间短，即在更新的时候提前准备好数据，保证事务处理的时间足够的短，流程足够的短，因为开启事务是一直占着连接的，如果流程比较长会消耗过多的数据库连接的</li> \n </ol> \n <h4 id=\"唯一键\"><a href=\"#唯一键\" class=\"headerlink\" title=\"唯一键\"></a>唯一键</h4>\n <p>通过在一张表里创建唯一键来获取锁，比如执行 saveStore 这个方法</p> \n <pre><code>insert table lock_store (\'method_name\') values($method_name)\n</code></pre>\n <p>其中 <code>method_name</code> 是个唯一键，通过这种方式也可以做到，解锁的时候直接删除改行记录就行。不过这种方式，锁就不会是阻塞式的，因为插入数据是立马可以得到返回结果的。</p> \n <p>那针对以上数据库实现的两种分布式锁，存在什么样的优缺点呢？</p> \n <h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4>\n <p>简单，方便，快速实现</p> \n <h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>\n <ul> \n  <li>基于数据库，开销比较大，性能可能会存在影响</li> \n  <li>基于数据库的当前读来实现，数据库会在底层做优化，可能用到索引，可能不用到索引，这个依赖于查询计划的分析</li> \n </ul> \n <h3 id=\"Zookeeper-实现\"><a href=\"#Zookeeper-实现\" class=\"headerlink\" title=\"Zookeeper 实现\"></a>Zookeeper 实现</h3>\n <h4 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h4>\n <ol> \n  <li>先有一个锁跟节点，lockRootNode，这可以是一个永久的节点</li> \n  <li>客户端获取锁，先在 lockRootNode 下创建一个顺序的瞬时节点，保证客户端断开连接，节点也自动删除</li> \n  <li>调用 lockRootNode 父节点的 getChildren() 方法，获取所有的节点，并从小到大排序，如果创建的最小的节点是当前节点，则返回 true,获取锁成功，否则，关注比自己序号小的节点的释放动作(exist watch)，这样可以保证每一个客户端只需要关注一个节点，不需要关注所有的节点，避免羊群效应。</li> \n  <li>如果有节点释放操作，重复步骤 3</li> \n </ol> \n <h4 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h4>\n <p>只需要删除步骤 2 中创建的节点即可</p> \n <p>使用 Zookeeper 的分布式锁存在什么样的优缺点呢？</p> \n <h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4>\n <ul> \n  <li>客户端如果出现宕机故障的话，锁可以马上释放</li> \n  <li>可以实现阻塞式锁，通过 watcher 监听，实现起来也比较简单</li> \n  <li>集群模式，稳定性比较高</li> \n </ul> \n <h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>\n <ul> \n  <li>一旦网络有任何的抖动，Zookeeper 就会认为客户端已经宕机，就会断掉连接，其他客户端就可以获取到锁。当然 Zookeeper 有重试机制，这个就比较依赖于其重试机制的策略了</li> \n  <li>性能上不如缓存</li> \n </ul> \n <h3 id=\"Redis-实现\"><a href=\"#Redis-实现\" class=\"headerlink\" title=\"Redis 实现\"></a>Redis 实现</h3>\n <p>我们先举个例子，比如现在我要更新产品的信息，产品的唯一键就是 productId</p> \n <h4 id=\"简单实现-1\"><a href=\"#简单实现-1\" class=\"headerlink\" title=\"简单实现 1\"></a>简单实现 1</h4>\n <pre><code>public boolean lock(String key, V v, int expireTime){\n        int retry = 0;\n        //获取锁失败最多尝试10次\n        while (retry &lt; failRetryTimes){\n            //获取锁\n            Boolean result = redis.setNx(key, v, expireTime);\n            if (result){\n                return true;\n            }\n\n            try {\n                //获取锁失败间隔一段时间重试\n                TimeUnit.MILLISECONDS.sleep(sleepInterval);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return false;\n            }\n\n        }\n\n        return false;\n    }\n    public boolean unlock(String key){\n        return redis.delete(key);\n    }\n    public static void main(String[] args) {\n        Integer productId = 324324;\n        RedisLock&lt;Integer&gt; redisLock = new RedisLock&lt;Integer&gt;();\n        redisLock.lock(productId+\"\", productId, 1000);\n    }\n}\n</code></pre>\n <p>这是一个简单的实现，存在的问题：</p> \n <ol> \n  <li>可能会导致当前线程的锁误被其他线程释放，比如 a 线程获取到了锁正在执行，但是由于内部流程处理超时或者 gc 导致锁过期，这个时候b线程获取到了锁，a 和 b 线程处理的是同一个 productId，b还在处理的过程中，这个时候 a 处理完了，a 去释放锁，可能就会导致 a 把 b 获取的锁释放了。</li> \n  <li>不能实现可重入</li> \n  <li>客户端如果第一次已经设置成功，但是由于超时返回失败，此后客户端尝试会一直失败</li> \n </ol> \n <p>针对以上问题我们改进下：</p> \n <ol> \n  <li>v 传 requestId，然后我们在释放锁的时候判断一下，如果是当前 requestId，那就可以释放，否则不允许释放</li> \n  <li>加入 count 的锁计数，在获取锁的时候查询一次，如果是当前线程已经持有的锁，那锁技术加 1，直接返回 true</li> \n </ol> \n <h4 id=\"简单实现-2\"><a href=\"#简单实现-2\" class=\"headerlink\" title=\"简单实现 2\"></a>简单实现 2</h4>\n <pre><code>private static volatile int count = 0;\npublic boolean lock(String key, V v, int expireTime){\n    int retry = 0;\n    //获取锁失败最多尝试10次\n    while (retry &lt; failRetryTimes){\n        //1.先获取锁,如果是当前线程已经持有，则直接返回\n        //2.防止后面设置锁超时，其实是设置成功，而网络超时导致客户端返回失败，所以获取锁之前需要查询一下\n        V value = redis.get(key);\n        //如果当前锁存在，并且属于当前线程持有，则锁计数+1，直接返回\n        if (null != value &amp;&amp; value.equals(v)){\n            count ++;\n            return true;\n        }\n\n        //如果锁已经被持有了，那需要等待锁的释放\n        if (value == null || count &lt;= 0){\n            //获取锁\n            Boolean result = redis.setNx(key, v, expireTime);\n            if (result){\n                count = 1;\n                return true;\n            }\n        }\n\n        try {\n            //获取锁失败间隔一段时间重试\n            TimeUnit.MILLISECONDS.sleep(sleepInterval);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n\n    }\n\n    return false;\n}\npublic boolean unlock(String key, String requestId){\n    String value = redis.get(key);\n    if (Strings.isNullOrEmpty(value)){\n        count = 0;\n        return true;\n    }\n    //判断当前锁的持有者是否是当前线程，如果是的话释放锁，不是的话返回false\n    if (value.equals(requestId)){\n        if (count &gt; 1){\n            count -- ;\n            return true;\n        }\n\n        boolean delete = redis.delete(key);\n        if (delete){\n            count = 0;\n        }\n        return delete;\n    }\n\n    return false;\n}\npublic static void main(String[] args) {\n    Integer productId = 324324;\n    RedisLock&lt;String&gt; redisLock = new RedisLock&lt;String&gt;();\n    String requestId = UUID.randomUUID().toString();\n    redisLock.lock(productId+\"\", requestId, 1000);\n}\n</code></pre>\n <p>这种实现基本解决了误释放和可重入的问题，这里说明几点：</p> \n <ol> \n  <li>引入 count 实现重入的话，看业务需要，并且在释放锁的时候，其实也可以直接就把锁删除了，一次释放搞定，不需要在通过 count 数量释放多次，看业务需要吧</li> \n  <li>关于要考虑设置锁超时，所以需要在设置锁的时候查询一次，可能会有性能的考量，看具体业务吧</li> \n  <li>目前获取锁失败的等待时间是在代码里面设置的，可以提出来，修改下等待的逻辑即可</li> \n </ol> \n <h4 id=\"错误实现\"><a href=\"#错误实现\" class=\"headerlink\" title=\"错误实现\"></a>错误实现</h4>\n <p>获取到锁之后要检查下锁的过期时间，如果锁过期了要重新设置下时间,大致代码如下：</p> \n <pre><code>public boolean tryLock2(String key, int expireTime){\n    long expires = System.currentTimeMillis() + expireTime;\n\n    // 获取锁\n    Boolean result = redis.setNx(key, expires, expireTime);\n    if (result){\n        return true;\n    }\n\n    V value = redis.get(key);\n    if (value != null &amp;&amp; (Long)value &lt; System.currentTimeMillis()){\n        // 锁已经过期\n        String oldValue = redis.getSet(key, expireTime);\n        if (oldValue != null &amp;&amp; oldValue.equals(value)){\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre>\n <p>这种实现存在的问题，过度依赖当前服务器的时间了，如果在大量的并发请求下，都判断出了锁过期，而这个时候再去设置锁的时候，最终是会只有一个线程，但是可能会导致不同服务器根据自身不同的时间覆盖掉最终获取锁的那个线程设置的时间。</p> \n <h3 id=\"Tair-实现\"><a href=\"#Tair-实现\" class=\"headerlink\" title=\"Tair 实现\"></a>Tair 实现</h3>\n <p>通过 Tair 来实现分布式锁和 Redis 的实现核心差不多，不过 Tair 有个很方便的 api，感觉是实现分布式锁的最佳配置，就是 Put api 调用的时候需要传入一个 version，就和数据库的乐观锁一样，修改数据之后，版本会自动累加，如果传入的版本和当前数据版本不一致，就不允许修改。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(172,12,'你针对产品提出哪些交互和改进意见',1,'www.funtl.com/assets/f0fcd6e5-874f-4894-9e0c-39fb1574c6de.jpg',1,'<div class=\"col-sm-12\"> \n <blockquote> \n  <p>过度设计，一般是说过度满足用户需求的设计。用户想要 A，你给了他 ABCDE，结果 BCDE 全部用不上。既让用户选择困难，又浪费了团队开发时间。</p> \n </blockquote> \n <p>即使是有经验的设计师，有时也容易陷入自己的「小循环」中难以自拔，过度追求一些体验的完美，或者需求的满足，而导致最终的实际使用体验下降，或者偏离产品设计初衷的悲剧结果。</p> \n <h3 id=\"过度追求精准\"><a href=\"#过度追求精准\" class=\"headerlink\" title=\"过度追求精准\"></a>过度追求精准</h3>\n <h4 id=\"例1：我们都知道载入内容时需要-loading-状态，如下图：\"><a href=\"#例1：我们都知道载入内容时需要-loading-状态，如下图：\" class=\"headerlink\" title=\"例1：我们都知道载入内容时需要 loading 状态，如下图：\"></a>例1：我们都知道载入内容时需要 loading 状态，如下图：</h4>\n <p><img src=\"/assets/f0fcd6e5-874f-4894-9e0c-39fb1574c6de.jpg\" alt=\"\"></p> \n <p>现实的业务场景中，需要加载的内容往往不只一个。如下图：虽然图表比较多，但排列整齐有序，所以看上去还是比较舒适的。</p> \n <p><img src=\"/assets/6759f77b-6cfb-4b29-9eb7-66252f5e8d27.jpg\" alt=\"\"></p> \n <p>再来看第三张：这样的 loading，是你想要的吗？</p> \n <p><img src=\"/assets/780646e1-86ff-4479-999a-01268f83213c.jpg\" alt=\"\"></p> \n <p>这是一个曾真实存在过的业务场景图，仪表盘中的图表排版是用户自行构建的。大部分仪表盘中的图表都不少于 5 张，且大小不一。每张图表中的数据来源于不同的数据模型，模型大小会影响加载速度，所以加载速度有快有慢，再加上网速等一些客观原因，有时就是会出现参差不齐一片 loading 的场景，而且出现的频率还不低。</p> \n <p>这时，就不应该过于追求每张图表与其 loading 状态一一对应。用户需要的是反馈，虽然精准提示了反馈来自于哪张图表，但如果界面展示反而让用户烦躁和混乱，那就得不偿失了。</p> \n <p>比较合理的做法是，把局部 loading 设计成全局 loading，起到反馈作用就可以了。如图：虽然牺牲了一点精确性，但在体验上用户会更容易接受。</p> \n <p><img src=\"/assets/88cfa64c-41be-4911-9309-09f5050f63f3.jpg\" alt=\"\"></p> \n <h4 id=\"例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\"><a href=\"#例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\" class=\"headerlink\" title=\"例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\"></a>例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向</h4>\n <p><img src=\"/assets/a1344109-2ef8-46e7-94b7-c5f619189506.jpg\" alt=\"\"></p> \n <p>纵向的列表筛选器，相信大部分人都能理解。如下图：当你勾选了需要筛选的内容时，相对应的内容就会被展示。</p> \n <p><img src=\"/assets/8f0a71ee-44cc-4996-be6b-b36e109d4122.jpg\" alt=\"\"></p> \n <p>好了，现在来想象一下，横向是什么？是这样的：</p> \n <p><img src=\"/assets/1c320f4a-e8eb-4f75-9986-4223227b0caf.jpg\" alt=\"\"></p> \n <p>会发现，横向的列表筛选器比较难理解，甚至之前根本没有看到过，仅仅从文案很难联想到最终的展示形式。横向和纵向，从文案上来说是一个精准的表达，同样的功能，只是方向发生了改变，所以你不能说他错。但用户理解不了，就得换个设计思维。</p> \n <p>重新从用户的使用场景着手，大部分用户习惯将横向列表筛选器和图表搭配在一起这么使用：</p> \n <p><img src=\"/assets/7f4136e0-c0b3-4672-926f-90a64dc4bb9c.jpg\" alt=\"\"></p> \n <p>这非常像一个导航，切换导航就是筛选的过程。最终，我们把设置面板改成了下图：「列表」和「导航」。虽然从含义上不如前者精准，但对用户来说，看到文案能够直观地联想到最终展现形式，体验上会更友好。</p> \n <p><img src=\"/assets/d597677f-fdcd-45f8-9241-ef37a443b8df.jpg\" alt=\"\"></p> \n <h3 id=\"死板遵循设计法则\"><a href=\"#死板遵循设计法则\" class=\"headerlink\" title=\"死板遵循设计法则\"></a>死板遵循设计法则</h3>\n <p>几乎所有的设计师，在入门时都会接触设计法则，设计法则为我们提供设计规范和评判标准，运用这些法则，能让我们在设计时更得心应手，在阐述自己的方案时也会更有底气。但所有的法则都不能盲目的遵守，得根据不同的场景灵活运用。</p> \n <p>尼而森可用性原则中有一条叫做，一致性原则。同一用语、功能、操作需要保持一致。 这可以帮助我们的产品看起来更加统一和规范，但一些设计师会机械的执行这条原则。如下图：这是一个数据格式的设定弹窗，通过点击 btn，能够激活该面板。</p> \n <p><img src=\"/assets/d1a5ebb5-c5d0-4dac-ae00-9d90fa3210eb.jpg\" alt=\"\"></p> \n <p>在另一个界面，也有数据格式的设置，为了遵循操作方式一致，设计成了这样，如图：</p> \n <p><img src=\"/assets/dc2d1135-86cf-4315-9d8c-34a5060cd7d0.jpg\" alt=\"\"></p> \n <p>细看后是否觉得有些地方比较违和？虽然都是通过点击操作激活设置弹窗，但表单中的链接一般不会孤零零的出现在某一个条目中。其次，在弹窗中应该尽量避免再出现一层弹窗，所以设置入口放在这里，是不合适的。</p> \n <p><img src=\"/assets/065f380e-5446-471c-abda-735d11c53662.jpg\" alt=\"\"></p> \n <p>修改一下，这样看上去是不是顺眼多了？</p> \n <p>虽然操作方式没有完全统一，但弹窗和下拉菜单面板中的内容布局是一致的。除此之外，下拉框和上一个表单条目也保持了形式统一，整体更和谐。灵活而不机械的运用设计法则，才能将其作用发挥到最大。</p> \n <h3 id=\"过度假设用户行为\"><a href=\"#过度假设用户行为\" class=\"headerlink\" title=\"过度假设用户行为\"></a>过度假设用户行为</h3>\n <p>在设计的过程中，经常会走着走着就进入了一个误区。「用户可能会如何操作，所以我们应该….」这样的想法经常会伴随着大量的竞品参考愈演愈烈，竞品如果有的，而自己没有就会觉得似乎少了什么。</p> \n <p>举个例子：渐变色的设置面板。有的色板是如下图这样的，类型、方向、角度、透明度、亮度等等，一眼看过去十分专业。</p> \n <p><img src=\"/assets/56e64473-aa07-42ae-b10d-d17bb6abb6a4.jpg\" alt=\"\"></p> \n <p>并不是每一个颜色设置场景都需要使用到渐变色板，相对于一般的纯色色板，它的使用门槛更高。对于这类设置较多的模块，有时我们并不能确定是所有内容全部提供还是只提供其中最常用的一部分，毕竟每一个功能似乎都有需求，难以舍弃。再加上设计迭代周期短，没有足够的时间做一次完整的可用性测试，来研究和验证用户到底想要哪些功能，所以就会陷入纠结。</p> \n <p>可以试着先将所有的内容归类，同类组合，视觉上精简内容，内容一旦形成区块就比较容易区分出优先级，优先级低的内容暂时先不放出来。如图：</p> \n <p><img src=\"/assets/d55ba135-b8b6-4478-af61-c154cc3e7a57.jpg\" alt=\"\"></p> \n <p>建议刚开始选择较为简单的方案，同时留出可扩展的空间。如果简单的设计方案已经能满足用户了，就不用盲目做加法。如果根据后期的可用性测试验证用户还有新的需求，再逐步添加。不要一下子就把用户行为想得太复杂，设计太多，吃力还不讨好。</p> \n <h3 id=\"过多展示内在业务逻辑\"><a href=\"#过多展示内在业务逻辑\" class=\"headerlink\" title=\"过多展示内在业务逻辑\"></a>过多展示内在业务逻辑</h3>\n <p>To b 产品往往业务属性较强，内部逻辑比较复杂，概念定义也多。如图：</p> \n <p><img src=\"/assets/4e2160f2-0fca-4c40-b402-8912376ccbcd.jpg\" alt=\"\"></p> \n <p>报告设置针对的是全局的内容，页面设置针对的是当前页的内容。由于技术是按照两个入口实现该功能的，逻辑上也清晰，所以设计时两个入口都暴露给了用户。但经过可用性测试，这两者的概念区别对用户来说都需要一定的理解时间，首次选择时也容易疑惑。其实这些定义产品内部分清就足够了，不需要额外暴露给用户。</p> \n <p><img src=\"/assets/84531c2b-f7a2-4b0f-8310-540fcac304b4.jpg\" alt=\"\"></p> \n <p>把两个概念合二为一，直接进入当前页面设置，如果有需要，再勾选应用到全局，用户不需要在不同的入口之间犹豫选择，体验上会好很多。</p> \n <h3 id=\"过于把用户当「小白」\"><a href=\"#过于把用户当「小白」\" class=\"headerlink\" title=\"过于把用户当「小白」\"></a>过于把用户当「小白」</h3>\n <p>产品设计中经常会强调，把「用户当小白」，但这更多适合 to c 类产品，to c 产品的操作流程更有规律性，做好引导或者在操作过程中自然的提示，的确能够帮助用户更快上手。</p> \n <p>而 to b 类产品，尤其是工具类产品，使用者本身是有一定的专业基础的，再加上操作频繁，形式多样，想要预判用户的下一步操作并不容易。如果老抱着一种我要去教用户使用的想法，每一步都去提示、引导，只会不停打断操作流程，降低用户体验。</p> \n <p>对于工具类的 to b 产品，与其不断提醒，造成大量提示文案，不如在一些复杂概念或者复杂操作旁提供帮助，供用户自己查阅学习。</p> \n <p>例如：提供搜索入口帮助用户快速定位到问题。</p> \n <p><img src=\"/assets/28155d54-6ff7-4abf-8ead-a209b6b7fab1.jpg\" alt=\"\"></p> \n <p>如果注释框难以解释清楚复杂问题，可以直接提供帮助手册的链接，点击跳转到新页面查看详细说明。</p> \n <p><img src=\"/assets/ba2f83ec-27f7-4121-b58f-13be143353a2.jpg\" alt=\"\"></p> \n <p>对于有一定专业基础的用户来说，提供工具书，当他遇到问题时自行查阅，比强制性的手把手教往往作用更大。</p> \n <h3 id=\"盲目满足用户需求\"><a href=\"#盲目满足用户需求\" class=\"headerlink\" title=\"盲目满足用户需求\"></a>盲目满足用户需求</h3>\n <p>参与过用户访谈和可用性测试的设计师可能会有一个体会，经常会出现「希望马上把这个用户提出的问题解决掉」的心理，「这个用户提出的问题很有价值，一定要记录下来」，「那个用户提出的抱怨确实忽略了，马上去改」。</p> \n <p>这其实是对用户的声音缺乏筛选，很多用户并不是产品人员，对于一些设计的考虑是缺乏理性的，只是片面的在抱怨一些主观意见，夹杂了很多个人的喜好。「我不喜欢这个设计，感觉怪怪的」，「这个icon我看不懂，不知道什么意思」。如果不加筛选的就听取意见，很容易就被上面的问题牵着鼻子走，造成不必要的过度设计。不仅会增加开发成本，还会丧失自己最初的设计原则。</p> \n <p>在听取用户的声音时，一定要保持冷静和理智的头脑，推演一遍真实的使用场景，判断出哪些问题是普遍存在的，哪些问题只是个人主观偏好，哪些问题改动成本小、见效快，哪些改动牵一发而动全身。不要过度满足用户需求。</p> \n <h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3>\n <p>设计不足，显得粗糙，设计过度，显得花哨。刚刚好的精妙设计与这两者的差别往往就在一念之间。对于度的把握，是需要设计师不断积累和总结才能有所提升的，注意尽量不要用自己的标准来衡量大部份用户。当一个方案考虑过多时，需要暂时重新思考，检查思维有没有陷入死胡同或者越跑越偏。想出一个解决方案时，尽量不要直接下定论，可以多与他人讨论，观察别人是否能直观、迅速地理解设计。如果没有，不要第一时间去争论和捍卫自己的方案，应该询问别人哪里觉得违和，然后不断调整和完善，慢慢找到最恰到好处的设计。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(173,12,'你如何理解用户痛点',1,'www.funtl.com/assets/QQ20150819154634.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是用户“痛点”\"><a href=\"#什么是用户“痛点”\" class=\"headerlink\" title=\"什么是用户“痛点”\"></a>什么是用户“痛点”</h3>\n <p><img src=\"/assets/QQ20150819154634.jpg\" alt=\"\"></p> \n <p><strong>本文讲的“痛点”，就是指让目标用户付出某种行动的最大阻碍。</strong></p> \n <p>比如在美图秀秀之前，大部分图像处理软件（比如 PS）都专注于提高处理图像的性能，这个时候，让用户使用图像处理软件的最大阻碍是什么呢？</p> \n <p>我想可能并不是图像处理的性能——对大多数人来说，PS 的性能已经足够好</p> \n <p><strong>这时，让用户使用图像处理软件最大的阻碍可能是易用性，因此“易用性”可能就是痛点，而抓住这一痛点，专注于提高易用性的美图秀秀就取得了初期成功。</strong></p> \n <p>好了，那么如何像当初的美图秀秀一样发现用户的痛点呢？</p> \n <p><strong>其实，只要你具备了基础信息，画一张图就够了。</strong></p> \n <p><strong>首先，画一个横向的箭头，把用户使用图像处理软件的全过程：</strong></p> \n <p><img src=\"/assets/QQ20150819154645.jpg\" alt=\"\"></p> \n <p>上面应该是一个正常用户使用图像处理软件的全部过程：先下载，然后学会怎么用，然后使用它做图片。</p> \n <p><strong>然后，你需要找出在每个阶段，影响用户行为的关键因素有哪些？</strong></p> \n <p><img src=\"/assets/QQ20150819154656.jpg\" alt=\"\"></p> \n <p>一般来说，可能影响用户行为的因素有：</p> \n <ul> \n  <li><strong>性能/效用：</strong> 这东西能不能达到我想要的效果？</li> \n  <li><strong>形象：</strong> 是不是符合我个人形象的？</li> \n  <li><strong>可靠：</strong> 是否存在风险？是否用起来不稳定？</li> \n  <li><strong>容易：</strong> 做出该行为是否很容易、不需要思考？</li> \n  <li><strong>价格：</strong> 做出该行为花钱多不多？</li> \n </ul> \n <p><strong>接着，你先把过去市场上产品聚焦点描成“橙色”：</strong></p> \n <p><img src=\"/assets/QQ20150819154835.jpg\" alt=\"\"></p> \n <p>如果具备行业的了解，你就会发现：过去，以 PS 为主的图像处理软件专注于提高性能和可靠性，同时能够帮助它的使用者塑造“专家”的积极形象。</p> \n <p>这个时候，你就需要问自己这样一个问题：</p> \n <blockquote> \n  <p>在图中的15块方格内，阻碍用户的最大因素是什么？（也就是痛点）</p> \n </blockquote> \n <p>你就会发现：下载、学习和使用 3 个过程都不够容易，而且在下载过程，往往需要付出价格。</p> \n <p><strong>然后，你就可以定位用户痛点了：</strong></p> \n <p><img src=\"/assets/QQ20150819154845.jpg\" alt=\"\"></p> \n <p><strong>为什么我们需要不停地寻找痛点？</strong></p> \n <p><strong>因为用户需求和行业都在不断变化，过去被所有人“想当然”认为是痛点的属性，很快可能就不再是痛点，而这时在大多数厂商一窝蜂聚焦于“曾经的痛点”时，你挖掘了新痛点，就可能逆流而上。</strong></p> \n <p>大多数人的思维是“基于原有的问题，我的解决方案是对的吗？”——“如何比别人更好地提高性能？”</p> \n <p>而“寻找痛点”则是考虑“我是否提出了正确的问题？”——“提高性能是不是一个好问题？如果不是，应该问什么新问题？”</p> \n <p><strong>所以，寻找用户痛点的过程，往往意味着“提出新的问题”，而不是“原有问题提出正确的解决方案。”</strong></p> \n <p>如何寻找？你可以用上面讲过的方法，画出用户的整张“痛点定位图”，寻找对用户的最大障碍来源。</p> \n <h3 id=\"纵向寻找\"><a href=\"#纵向寻找\" class=\"headerlink\" title=\"纵向寻找\"></a>纵向寻找</h3>\n <p><strong>在同一个过程中，纵向寻找阻碍用户的最大因素。</strong></p> \n <p>比如过去的胰岛素（病人买回家自己注射，用来治疗糖尿病）市场，大部分公司的聚焦点在于使用过程中的“性能”和“风险”，致力于研发更高纯度、更高稳定性的胰岛素产品。</p> \n <p>这在过去是合理的，因为比起纯度 10% 的胰岛素，纯度 50% 的胰岛素显然更能解决病人问题。</p> \n <p>但是随着大部分知名品牌胰岛素纯度都提高到 99% 以上，继续提高 0.1 个百分点的纯度虽然耗费巨额资金，但是对消费者的使用却影响甚微。</p> \n <p>这个时候，同类品牌都加入了胰岛素纯度的竞争（类似现在手机轻薄、屏幕等竞争），而 Novo Nordisk 却重新问自己这个问题：</p> \n <p><strong>此时，阻碍消费者使用最大的因素是什么？</strong></p> \n <p>然后它发现其实并不是“性能”和“风险”，而是“形象”和“容易程度”。</p> \n <ul> \n  <li><strong>形象：</strong> 胰岛素消费者其实都不想让别人知道他们是糖尿病。</li> \n  <li><strong>容易：</strong> 过去的注射器非常麻烦，需要提前消毒并且注射。</li> \n </ul> \n <p><strong>所以他们转变了战略的聚焦点，不再花费大量精力提高纯度和稳定性，而是帮助消费者提升形象和容易程度。</strong></p> \n <p><img src=\"/assets/QQ20150819154856.jpg\" alt=\"\"></p> \n <p>最终，他们研发出了这种“笔形”的胰岛素，不容易被识别，帮患者遮盖了“糖尿病人”的形象，同时不需要用针注射，提高了使用的容易程度。</p> \n <p><img src=\"/assets/QQ20150819154906.jpg\" alt=\"\"></p> \n <p>所以，纵向寻找痛点，你需要先找出影响某个环节的全部因素，然后看哪个因素是消费者现在的最大阻碍。</p> \n <h3 id=\"横向寻找\"><a href=\"#横向寻找\" class=\"headerlink\" title=\"横向寻找\"></a>横向寻找</h3>\n <p><strong>你还可以横向寻找：如果所有的竞争者都在关注用户的“使用”阶段，那么我可能应该看看其他阶段有没有痛点机会。</strong></p> \n <p>比如汽车行业，用户前后经过了购买、使用、修理、抛弃（转售）这几个环节。</p> \n <p>而在大众甲壳虫之前，欧洲所有的汽车公司几乎都聚焦于用户的“使用环节”。为用户造出性能越来越好、也越来越让人有面子的汽车。</p> \n <p><img src=\"/assets/QQ20150819154921.jpg\" alt=\"\"></p> \n <p>而甲壳虫却发现：这并不是当时对用户的最大障碍。因此适当降低了在使用阶段“效用”和“形象”上的投入，转而优化所有阶段的容易程度，同时提高使用阶段的适用性（适应更多的路面情况）。</p> \n <p><img src=\"/assets/QQ20150819154930.jpg\" alt=\"\"></p> \n <p>因此大众造出的甲壳虫外观常年不变，也不能让开车的人更有面子，但是容易买到（销售渠道）、容易驾驶、维修方便（因为使用了标准化配件）同时容易转售（因为样子常年不变）。</p> \n <p>再比如，70 年代在美国主打性价比的汽车品牌，在痛点定位图上是这样的：</p> \n <p><img src=\"/assets/QQ20150819154939.jpg\" alt=\"\"></p> \n <p>这个时候如果问：<strong>价格敏感用户的最大阻碍是什么？</strong></p> \n <p>就会发现这个关键阻碍并不发生在“购买阶段”，而是发生在“使用阶段”——因为石油危机，不论买的车多便宜，高昂的油价让人“买得起开不起”。</p> \n <p>所以，主打省油的日系车大举进入美国市场，大获成功。</p> \n <p><img src=\"/assets/QQ20150819154948.jpg\" alt=\"\"></p> \n <p>所以，寻找痛点时，可以问自己：<strong>消费者用我的产品分为哪几个阶段？现在哪个阶段是他们的关键障碍？</strong></p> \n <p>比如过去中国的手机市场是渠道为王，手机厂商几乎一半的利润分给了渠道商。通过大量的渠道，手机厂商提供了购买的便利性：</p> \n <blockquote> \n  <p>“消费者随时随地都能买到手机，可以拿在手上一一比较，而且可以当场买走，不用等待。”</p> \n </blockquote> \n <p>那么同样是1000-2000价位的手机，消费者的主要障碍发生在什么阶段呢？</p> \n <p>其实很容易发现，<strong>主要障碍发生在使用阶段（2000的手机性能太差），而不是购买阶段（想要很便利地买到）</strong>。</p> \n <p>所以这就是最初的小米手机，大部分厂商努力的重点在渠道（“购买阶段”），小米的努力重点在产品性能（“使用阶段”）。</p> \n <p><img src=\"/assets/QQ20150819155001.jpg\" alt=\"\"></p> \n <p><strong>不光可以用于寻找产品痛点，还可以用于文案痛点</strong></p> \n <p>比如肯德基搞过一个在线优惠活动，文案如下：</p> \n <p><img src=\"/assets/QQ20150819155026.jpg\" alt=\"\"></p> \n <p>如何分析这个广告呢？</p> \n <p><strong>首先我们先列出消费的行动过程：先看到文案，然后参加活动。</strong></p> \n <p><img src=\"/assets/QQ20150819155044.jpg\" alt=\"\"></p> \n <p><strong>然后找出每个阶段的主要驱动因素，比如：有兴趣、很容易做到等。</strong></p> \n <p>就会发现这个文案的聚焦点在于：提高活动的吸引力，让人产生兴趣（比如足够的优惠）。</p> \n <p><img src=\"/assets/QQ20150819155055.jpg\" alt=\"\"></p> \n <p><strong>但是如果问：现在限制消费者参加活动的关键因素是什么？</strong></p> \n <p>答案应该是：整个过程太复杂，不够容易。</p> \n <p><img src=\"/assets/QQ20150819155104.jpg\" alt=\"\"></p> \n <p><strong>这就意味着：刺激人参加活动，痛点应该是“降低复杂性”，如果不降低复杂性，一味提高奖励可能也没有作用。</strong></p> \n <p>灵活运用方法，还可以换一种方式，分析文案的有效性。</p> \n <p><strong>比如这个公益广告文案“真正的男人，不需要海豹鞭”。</strong></p> \n <p><img src=\"/assets/QQ20150819155114.jpg\" alt=\"\"></p> \n <p>首先，我们先看人认知这一广告信息的过程：</p> \n <ul> \n  <li><strong>注意：</strong> 注意到这个信息，激发了头脑的相关联想。比如看到“壮阳”联想到“性”等印象。</li> \n  <li><strong>理解：</strong> 理解这个信息的意思。</li> \n  <li><strong>信服：</strong> 信服刚刚所理解的信息。</li> \n  <li><strong>刺激行动：</strong> 因为信任这个信息而改变了行动。</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155122.jpg\" alt=\"\"></p> \n <p><strong>然后我们在纵向写上广告想要让人接受的信息。</strong></p> \n <p>比如“真正的男人不需要海豹鞭”实际上包含 2 层信息：</p> \n <ul> \n  <li>海豹鞭被认为可以壮阳</li> \n  <li>吃海豹鞭的不是真男人</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155130.jpg\" alt=\"\"></p> \n <p>然后把这个广告产生的所有影响涂成橙色，就会发现是这样的：</p> \n <p><img src=\"/assets/QQ20150819155139.jpg\" alt=\"\"></p> \n <p>用海豹鞭不是真男人”这个信息缺乏说服力，基本上只是引起了注意并且让人理解。</p> \n <p><strong>然而，通过隐含“海豹鞭被认为可以壮阳”这个信息，让很多本来没听说过海豹鞭的人，第一次知道了海豹鞭可以壮阳，并且更加信服</strong>（否则怎么会打广告说不要吃呢）。</p> \n <p>所以，这个文案很可能会起到反面效果——为海豹鞭打了广告。</p> \n <p>毕竟，如果是海豹鞭销售公司的广告文案，估计也可以这么写：</p> \n <blockquote> \n  <p>真正的男人不需要海豹鞭<br>但，如果你没有他们那么强<br>请联系我们购买：XXXX.com</p> \n </blockquote> \n <p>这也是为什么自杀相关的新闻曝光后，自杀的人会变多。</p> \n <p>总之，既然文案是为了改变用户的行为，那么设计文案的时候也要分析：</p> \n <p><strong>限制用户改变行为的关键障碍是什么？</strong></p> \n <h3 id=\"改变用户的某个习惯\"><a href=\"#改变用户的某个习惯\" class=\"headerlink\" title=\"改变用户的某个习惯\"></a>改变用户的某个习惯</h3>\n <p>除了产品设计、文案设计，其实几乎任何一种涉及改变的活动，都需要分析痛点，找到影响对方的关键障碍。</p> \n <p>比如假设你想帮助人戒烟，那么首先列出吸烟的全部过程：</p> \n <p><img src=\"/assets/QQ20150819155150.jpg\" alt=\"\"></p> \n <p>然后列出每个过程对应的影响因素，比如：</p> \n <ul> \n  <li><strong>效用：</strong> 给人带来正面体验</li> \n  <li><strong>形象：</strong> 提升形象</li> \n  <li><strong>风险：</strong> 是否有风险</li> \n  <li><strong>容易：</strong> 过程是否容易做</li> \n  <li><strong>价格：</strong> 是否需要花费很大成本</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155200.jpg\" alt=\"\"></p> \n <p>找到了这个矩阵，你就会发现过去几乎所有的戒烟干预方式，都聚焦于“吸烟”这个过程，而且是“吸烟”的风险这个过程：</p> \n <p>（强调：吸烟有害健康）</p> \n <p><img src=\"/assets/QQ20150819155212.jpg\" alt=\"\"></p> \n <p>比如这个创意广告：</p> \n <p><img src=\"/assets/QQ20150819155219.jpg\" alt=\"\"></p> \n <p>而其实可以有效干预的痛点有很多：</p> \n <p><img src=\"/assets/QQ20150819155228.jpg\" alt=\"\"></p> \n <p>比如降低送烟的形象，想办法让送烟变成一种丢脸的行为。</p> \n <p>比如降低吸烟的效用，让大众相信吸烟其实并不会提高注意力，等。</p> \n <p><img src=\"/assets/QQ20150819155236.jpg\" alt=\"\"></p> \n <p><strong>甚至，构思这篇文章本身，李叫兽也在定位痛点：</strong></p> \n <p>我的目标是让读者更多地学会如何定位用户的痛点。</p> \n <p><strong>首先，我列出了定位用户痛点的过程：</strong></p> \n <p>收集信息、了解哪些感受可以改变行为（心理学理论）、综合利用信息和理论。</p> \n <p><strong>然后每个过程，都需要让读者“想要”这样做，并且“容易”做到（讲技巧）</strong></p> \n <p>最终，我发现读者看文章只有 3 分钟时间，不可能把所有的心理学理论概括清楚，也讲不完用户调查方法。而且发现大部分人的关键问题并不是信息或者知识太少，而是没有巧妙地利用这些知识。</p> \n <p><strong>所以把这篇文章解决的痛点定位成了最右下角的一部分：</strong></p> \n <p><img src=\"/assets/QQ20150819155245.jpg\" alt=\"\"></p> \n <h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3>\n <p>很多人没有找到用户的痛点，并不是因为欠缺信息（比如不知道用户怎么想的），而是没有有效地利用已有信息。</p> \n <p>而如果你重新思考自己已经知道的，分析用户的每个动作过程，就会发现：痛点更容易找到！</p> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(174,12,'说说你在项目中使用过的 UML 图',1,'www.funtl.com/assets/1004000.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3>\n <p>在 OOA 与 OOD 大行其道的今天，UML 在系统分析与设计中得到了广泛的采用。而在 UML 的 9 种图中，类图是最重要也是使用最普遍的图之一。但是，在与一些朋友，特别是初学者的聊天当中，我发现很多朋友对类图的作用及使用方法存在一定的误解和困惑。希望本文能在一定程度上帮助这些朋友更好的认识和使用类图。</p> \n <h3 id=\"A-vs-D\"><a href=\"#A-vs-D\" class=\"headerlink\" title=\"A vs D\"></a>A vs D</h3>\n <p>要想正确认识与使用类图，我们首先要正确认识两个概念——“A”和“D”。</p> \n <p>A是Analyse的缩写，即我们所说的“分析”；而D是Design的缩写，即“设计”。一般来说，一个系统在编码前，都要经过分析与设计两个步骤。而对这两个概念认识的模糊不清，正是导致很多朋友无法正确使用类图的原因。</p> \n <p>分析，我对其的解释是：根据用户的需求，做出一系列与业务领域相关而和计算机技术无关的整理与识别。</p> \n <p>很多朋友有个错误的认识，认为软件开发工作一定要由懂计算机的人完成，不懂计算机的人怎么能进行软件开发呢？当然，对于设计和编码等工作，当然是这样，但是唯有“分析”这一工作，可以由完全不懂计算机的人来进行，甚至从某种程度上说，不懂计算机的人更适合做软件分析师的工作。因为想要把分析做好，一定要仅与业务相关，而抛开具体技术。一个满脑子计算机技术的程序员去做分析时，很容易想到编码、实现、平台、数据库设计等具体细节，这种思维形式恰恰成为做好分析的最大障碍。此为误解一：只有懂计算机技术的人才能做系统分析师。我现在所在的研究所（北京航空航天大学计算机学院软件工程研究所）曾经接过一个日本项目，当时日方那边派来一个系统分析师对计算机就完全是外行，而是一个领域专家，但是他很好的完成了系统分析的工作。</p> \n <p>另外一个误解就是UML图，特别是类图，就是给开发人员用的。很多人觉得UML是计算机业内专业语言，不懂计算机的怎么能用它呢？用了做什么呢？但是很多不懂计算机的系统分析师在进行分析工作时，也在使用UML图，而类图就是其中一种。一般情况下，分析师在进行分析时，确实会绘制一套类图。但是，它所画的类图不管是从视角还是作用，与设计师所做的类图是不同的，具体将在下面介绍。此为误解二：只有计算机人士才使用UML图。</p> \n <p>分析说完了，下面说设计。与分析不同，我对设计的解释是：根据分析材料与技术平台，确定软件系统的架构结构、编码方式及一切与具体技术有关的宏观问题。</p> \n <p>这里可以看到，设计与分析不同，它必须由计算机方面的人来完成，因为它和具体技术是息息相关的。而且，设计师在进行设计时，也会绘制一套类图。</p> \n <p>到这里，我们明确了，原来软件在分析与设计两个阶段各自会绘制一套类图，而且是由分析师和设计师两个不同的角色绘制的。那么这两套类图有什么异同呢？下面将解释这个问题。</p> \n <h3 id=\"领域类图-vs-实现类图\"><a href=\"#领域类图-vs-实现类图\" class=\"headerlink\" title=\"领域类图 vs 实现类图\"></a>领域类图 vs 实现类图</h3>\n <p>上文提到，在软件分析与设计过程中，会由两种角色产生两套类图。一般情况下，分析师绘制的类图叫做“领域类图”，而设计师绘制的类图叫做“实现类图”。这里要声明，这两个名词是我的习惯性叫法，并不是大家都认同的通用叫法。下面，我对这两种类图给出我的定义：</p> \n <p>领域类图：产生于分析阶段，由系统分析师绘制，主要作用是描述业务实体的静态结构，包括业务实体、各个业务实体所具有的业务属性及业务操作、业务实体之间具有的关系。</p> \n <p>虽然这个类图也叫“类图”，但是说实话，它和编程中的“类”实在是没啥关系，因为最后的系统中可能根本没有类和它们对应，而且很多最后系统中的类如控制类和界面类这套类图中也没有。也就是说这套图和具体技术无关，也不是画给程序员看的，它只是表达业务领域中的一个静态结构。下面给个例子：</p> \n <p><img src=\"/assets/1004000.jpg\" alt=\"\"></p> \n <p>这是一个选课系统的简单领域分析类图。可以看到，主要实体有教师、学生、课程和开课安排。每个实体标注了其在业务上具有的属性和方法。而且图中还标明了实体间的关系。</p> \n <p>但是，最终系统中可能没有一个学生类和其对应。因为最终系统中有哪些类、各个类有什么属性、方法依赖于所选择的平台和架构。例如，如果使用了 Struts2，则会存在很多 Action 类，而使用了 ASP.NET MVC，则会有很多 Controller 类等，所以，领域类图只于业务有关，和具体实现及编码等计算机技术无关。</p> \n <p><strong>下面该说说实现类图了：</strong></p> \n <p>现类图：产生于设计阶段，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码。它包括系统中所有有必要指明的实体类、控制类、界面类及与具体平台有关的所有技术性信息。</p> \n <p>就像上面的领域类图，如果你把它交给程序员编码，我想程序员会疯掉，因为它没有提供任何编码的依据。假如我们使用的是.NET平台分层架构，并使用ASP.NET MVC，则设计师应该在实现类图中绘制出所有的实体类、数据访问类、业务逻辑类和界面类，界面类又分为视图类、控制器类等等，还要表示出IoC和Aop等信息，并明确指出各个类的属性、方法，不能有遗漏，因为最终程序员实现程序的依据就是实现类图。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>最后，我们总结一下本文的要点：</p> \n <ol> \n  <li>软件分析与设计是编码前的两个阶段，其中分析仅与业务有关，而与技术无关。设计以分析为基础，主要与具体技术有关。</li> \n  <li>分析阶段由分析师绘制领域类图，设计阶段由设计师绘制实现类图。</li> \n  <li>领域类图表示系统的静态领域结构，其中的类不与最终程序中的类对应；设计类图表示系统的技术架构，是程序员的编码依据，其中的类与系统中的类对应。</li> \n  <li>领域类图中类的属性与操作仅关注与业务相关的部分，实现类图中的属性与操作要包括最终需要实现的全部方法与操作。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(175,12,'你如何考虑组件化',1,'www.funtl.com/assets/组件化.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"组件化与模块化\"><a href=\"#组件化与模块化\" class=\"headerlink\" title=\"组件化与模块化\"></a>组件化与模块化</h3>\n <p>首先来谈两个前端和移动端比较常见的词：<code>组件化</code> 和 <code>模块化</code></p> \n <p>首先，可以肯定的是，组件化和模块化的中心思想都是 <code>分而治之</code>。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</p> \n <p><img src=\"/assets/组件化.jpg\" alt=\"\"></p> \n <h4 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h4>\n <p>组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是 <strong>减少耦合</strong>。</p> \n <blockquote> \n  <p>一个独立的组件可以是一个软件包、WEB 服务、WEB 资源或者是封装了一些函数的模块。这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。</p> \n </blockquote> \n <h4 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h4>\n <p>模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。将一个大的系统模块化之后，每个模块都可以被高度复用。</p> \n <h4 id=\"模块化和组件化的区别\"><a href=\"#模块化和组件化的区别\" class=\"headerlink\" title=\"模块化和组件化的区别\"></a>模块化和组件化的区别</h4>\n <p>从上面的定义中可以看出，组件化和模块化的意思差不多，主要思想都是分而治之。只是一个把拆分之后的每个片段叫做组件、另一个把拆分之后的片段叫做模块。那么这两种拆分在拆分方式上是不是有什么不同的？</p> \n <p>关于组件化和模块化的区别，我在网上看了好多资料，也没有人能给出准确的回答。其实没有准确回答的原因也比较明显，那就是大多数时候我们真的不需要严格的区分这两个名字。我们要学习的是其中的解耦和分治的思想和目的。</p> \n <p>从另外一个角度来讲，如果真的要区分一下组件化和模块化的话，那么可以认为这两种分而治之的目的稍有区别：</p> \n <ul> \n  <li>模块化的目的是为了 <code>重用</code>，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。</li> \n  <li>组件化的目的是为了 <code>解耦</code>，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:35','2018-12-19 15:45:35'),
(176,12,'微服务如何进行数据库管理',1,'www.funtl.com/assets/201705272.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"分布式数据管理之痛点\"><a href=\"#分布式数据管理之痛点\" class=\"headerlink\" title=\"分布式数据管理之痛点\"></a>分布式数据管理之痛点</h3>\n <p>为了确保微服务之间松耦合，每个服务都有自己的数据库, 有的是关系型数据库(SQL)，有的是非关系型数据库(NoSQL)。开发企业事务往往牵涉到多个服务，要想做到多个服务数据的一致性并非易事，同样，在多个服务之间进行数据查询也充满挑战。我们以一个在线 B2B 商店为例，客户服务包括了客户的各种信息，例如可用信用等。管理订单，提供订单服务，则需要验证某个新订单与客户的信用限制没有冲突。在单体应用中，订单服务只需要使用传统事务交易就可以一次性检查可用信用和创建订单。相反微服务架构下，订单和客户表分别是相应服务的私有表，如下图所示：</p> \n <p><img src=\"/assets/201705272.jpg\" alt=\"\"></p> \n <p>订单服务不能直接访问客户表，只能通过客户服务发布的 API 来访问或者使用分布式事务, 也就是众所周知的两阶段提交 (2PC)来访问客户表，2PC 意义图如下所示：</p> \n <p><img src=\"/assets/201705273.jpg\" alt=\"\"></p> \n <p>这里存在两个挑战：</p> \n <ol> \n  <li>第一个挑战是 2PC 除要求数据库本身支持外，还要求服务的数据库类型需要保持一致。但是现在的微服务架构中，每个服务的数据库类型可能是不一样的，有的可能是 MySQL 数据库，有的也可能是 NoSQL 数据库;</li> \n  <li>第二个挑战是如何实现从多个服务中查询数据。假设应用程序需要显示一个客户和他最近的订单。如果订单服务提供用于检索客户订单的 API，那么应用程序端可以通过 JOIN 方式来检索此数据，即应用程序首选从客户服务检索客户，并从订单服务检索客户的订单。然而，如果订单服务仅支持通过其主键查找订单(也许它使用仅支持基于主键的检索的 NoSQL 数据库)， 在这种情况下，就没有方法来检索查询所需的数据。</li> \n </ol> \n <p>为解决这两大痛点，就需要我们使用到分步式数据管理了。</p> \n <h3 id=\"分布式数据管理之举措\"><a href=\"#分布式数据管理之举措\" class=\"headerlink\" title=\"分布式数据管理之举措\"></a>分布式数据管理之举措</h3>\n <p>在介绍分布式数据管理(CRUD)解决方案之前，有必要介绍下 CAP 原理和最终一致性相关概念。</p> \n <h3 id=\"CAP-原理-CAP-Theorem\"><a href=\"#CAP-原理-CAP-Theorem\" class=\"headerlink\" title=\"CAP 原理(CAP Theorem)\"></a>CAP 原理(CAP Theorem)</h3>\n <p>在足球比赛里，一个球员在一场比赛中进三个球，称之为帽子戏法(Hat-trick)。在分布式数据系统中，也有一个帽子原理(CAP Theorem)，不过此帽子非彼帽子。CAP 原理中，有三个要素：</p> \n <p>1) 一致性(C onsistency)<br>2) 可用性(A vailability)<br>3) 分区容忍性(P artition tolerance)</p> \n <p>CAP 原理指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p> \n <p>因此在进行分布式架构设计时，必须做出取舍。而对于分布式数据系统，分区容忍性是基本要求 ，否则就失去了价值，因此设计分布式数据系统，就是在一致性和可用性之间取一个平衡。</p> \n <p>对于大多数 WEB 应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是目前多数分布式数据库产品的方向。</p> \n <p>当然，牺牲一致性，并不是完全不管数据的一致性，否则数据是混乱的，那么系统可用性再高分布式再好也没有了价值。</p> \n <p>牺牲一致性，只是不再要求关系型数 据库中的强一致性，而是只要系统能达到最终一致性即可，考虑到客户体验，这个最终一致的时间窗口，要尽可能的对用户透明，也就是需要保障“用户感知到的一致性”。</p> \n <p>通常是通过数据的多份异步复制来实现系统的高可用和数据的最终一致性的，“用户感知到的一致性”的时间窗口则 取决于数据复制到一致状态的时间。</p> \n <h3 id=\"最终一致性-eventually-consistent\"><a href=\"#最终一致性-eventually-consistent\" class=\"headerlink\" title=\"最终一致性(eventually consistent)\"></a>最终一致性(eventually consistent)</h3>\n <p>对于一致性，可以分为从客户端和服务端两个不同的视角。</p> \n <p>从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。</p> \n <p>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p> \n <p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p> \n <p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p> \n <p>对于关系型数据库，要求更新过的数据能被后续的 访问都能看到，这是强一致性 ;如果能容忍后续的部分或者全部访问不到，则是弱一致性 ; 如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p> \n <p>从服务端角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。</p> \n <p>那么问题来了，如何实现数据的最终一致性呢?答案就在事件驱动架构。</p> \n <h3 id=\"事件驱动架构简介\"><a href=\"#事件驱动架构简介\" class=\"headerlink\" title=\"事件驱动架构简介\"></a>事件驱动架构简介</h3>\n <p>Chris Richardson 作为微服务架构设计领域的权威，给出了分布式数据管理的最佳解决方案。</p> \n <p>对于大多数应用而言，要实现微服务的分布式数据管理，需要采用事件驱动架构(event-driven architecture)。</p> \n <p>在事件驱动架构中，当某件重要事情发生时，微服务会发布一个事件，例如更新一个业务实体。</p> \n <p>当订阅这些事件的微服务接收此事件时，就可以更新自己的业务实体，也可能会引发更多的事件发布，让其他相关服务进行数据更新，最终实现分布式数据最终一致性。</p> \n <p>可以使用事件来实现跨多服务的业务交易。交易一般由一系列步骤构成，每一步骤都由一个更新业务实体的微服务和发布激活下一步骤的事件构成。</p> \n <h4 id=\"事件驱动示例-1\"><a href=\"#事件驱动示例-1\" class=\"headerlink\" title=\"事件驱动示例 1\"></a>事件驱动示例 1</h4>\n <p>下图展现如何使用事件驱动方法，在创建订单时检查信用可用度，微服务之间通过消息代理(Messsage Broker)来交换事件。</p> \n <ul> \n  <li>订单服务创建一个带有 NEW 状态的 Order (订单)，发布了一个“Order Created Event(创建订单)”的事件。</li> \n </ul> \n <p><img src=\"/assets/201705274.jpg\" alt=\"\"></p> \n <ul> \n  <li>客户服务消费 Order Created Event 事件，为此订单预留信用，发布“Credit Reserved Event(信用预留)”事件。</li> \n </ul> \n <p><img src=\"/assets/201705275.jpg\" alt=\"\"></p> \n <ul> \n  <li>订单服务消费 Credit Reserved Event，改变订单的状态为 OPEN。</li> \n </ul> \n <p><img src=\"/assets/201705276.jpg\" alt=\"\"></p> \n <h4 id=\"事件驱动示例-2\"><a href=\"#事件驱动示例-2\" class=\"headerlink\" title=\"事件驱动示例 2\"></a>事件驱动示例 2</h4>\n <p>下图展现如何使用事件驱动方法，在创建订单时触发支付业务的数据更新，微服务之间通过消息代理(Messsage Broker)来交换事件。</p> \n <ul> \n  <li>订单服务创建一个待支付的订单，发布一个“创建订单”的事件。</li> \n </ul> \n <p><img src=\"/assets/201705277.jpg\" alt=\"\"></p> \n <ul> \n  <li>支付服务消费“创建订单”事件，支付完成后发布一个“支付完成”事件。</li> \n </ul> \n <p><img src=\"/assets/201705278.jpg\" alt=\"\"></p> \n <ul> \n  <li>订单服务消费“支付完成”事件，订单状态更新为待出库。</li> \n </ul> \n <p><img src=\"/assets/201705279.jpg\" alt=\"\"></p> \n <h3 id=\"事件驱动架构之分布式数据更新\"><a href=\"#事件驱动架构之分布式数据更新\" class=\"headerlink\" title=\"事件驱动架构之分布式数据更新\"></a>事件驱动架构之分布式数据更新</h3>\n <p>上节通过示例概要介绍了通过事件驱动方式，实现了分布式数据最终一致性保证。纵观微服务架构下的事件驱动业务处理逻辑，其核心要点在于，可靠的事件投递和避免事件的重复消费。</p> \n <p>可靠事件投递有以下两个特性：</p> \n <p>1) 每个服务原子性的完成业务操作和发布事件;<br>2) 消息代理确保事件投递至少一次(at least once);</p> \n <p>而避免事件重复消费则要求消费事件的服务实现幂等性，比如支付服务不能因为重复收到事件而多次支付。</p> \n <p>BTW：当前流行的消息队列如Kafka等，都已经实现了事件的持久化和at least once的投递模式，所以可靠事件投递的第二条特性已经满足，这里就不展开。接下来章节讲重点讲述如何实现可靠事件投递的第一条特性和避免事件重复消费，即服务的业务操作和发布事件的原子性和避免消费者重复消费事件要求服务实现幂等性。</p> \n <h4 id=\"如何实现事件投递操作原子性\"><a href=\"#如何实现事件投递操作原子性\" class=\"headerlink\" title=\"如何实现事件投递操作原子性?\"></a>如何实现事件投递操作原子性?</h4>\n <p>事件驱动架构会碰到数据库更新和发布事件原子性问题。例如，订单服务必须向 ORDER 表插入一行，然后发布 Order Created event，这两个操作需要原子性。比如更新数据库后，服务瘫了(crashes)造成事件未能发布，系统变成不一致状态。那么如何实现服务的业务操作和发布事件的原子性呢?</p> \n <ul> \n  <li><strong>使用本地事务发布事件</strong></li> \n </ul> \n <p>获得原子性的一个方法是将服务的业务操作和发布事件放在一个本地数据库事务里，也就是说，需要在本地建立一个 EVENT 表，此表在存储业务实体数据库中起到消息列表功能。当应用发起一个(本地)数据库交易，更新业务实体状态时，会向 EVENT 表中插入一个事件，然后提交此次交易。另外一个独立应用进程或者线程查询此 EVENT 表，向消息代理发布事件，然后使用本地交易标志此事件为已发布，如下图所示：</p> \n <p><img src=\"/assets/2017052710.jpg\" alt=\"\"></p> \n <p>订单服务向 ORDER 表插入一行，然后向 EVENT 表中插入 Order Created event，事件发布线程或者进程查询 EVENT 表，请求未发布事件，发布他们，然后更新 EVENT 表标志此事件为已发布。</p> \n <p>此方法也是优缺点都有。优点是可以确保事件发布不依赖于 2PC，应用发布业务层级事件而不需要推断他们发生了什么;而缺点在于此方法由于开发人员必须牢记发布事件，因此有可能出现错误。</p> \n <ul> \n  <li><strong>使用事件源</strong></li> \n </ul> \n <p>Event sourcing (事件源)通过使用以事件中心的数据存储方式来保证业务实体的一致性。事件源保存了每个业务实体所有状态变化的事件，而不是存储实体当前的状态。应用可以通过重放事件来重建实体现在的状态。只要业务实体发生变化，新事件就会添加到事件表中。因为保存事件是单一操作，因此肯定是原子性的。</p> \n <p>为了理解事件源工作方式，考虑以事件实体作为一个例子说明。传统方式中，每个订单映射为 ORDER 表中一行。但是对于事件源方式，订单服务以事件状态改变方式存储一个订单：创建的，已批准的，已发货的，取消的;每个事件包括足够信息来重建订单的状态。</p> \n <p><img src=\"/assets/2017052711.jpg\" alt=\"\"></p> \n <p>事件源方法有很多优点：解决了事件驱动架构关键问题，使得业务实体更新和事件发布原子化，但是也存在缺点，因为是持久化事件而不是对象，导致数据查询时，必须使用 Command Query Responsibility Segregation (CQRS) 来完成查询业务，从开发角度看，存在一定挑战。</p> \n <h4 id=\"如何避免事件重复消费\"><a href=\"#如何避免事件重复消费\" class=\"headerlink\" title=\"如何避免事件重复消费?\"></a>如何避免事件重复消费?</h4>\n <p>要避免事件重复消费，需要消费事件的服务实现服务幂等，因为存在重试和错误补偿机制，不可避免的在系统中存在重复收到消息的场景，服务幂等能提高数据的一致性。在编程中,一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，因此需要开发人员在功能设计实现时，需要特别注意服务的幂等性。</p> \n <h3 id=\"事件驱动架构之分布式数据查询\"><a href=\"#事件驱动架构之分布式数据查询\" class=\"headerlink\" title=\"事件驱动架构之分布式数据查询\"></a>事件驱动架构之分布式数据查询</h3>\n <p>微服务架构下，由于分布式数据库的存在，导致在执行用户业务数据查询时，通常需要跨多个微服务数据库进行数据查询，也就是分布式数据查询。那么问题来了，由于每个微服务的数据都是私有化的，只能通过各自的REST接口获取，如果负责业务查询的功能模块，通过调用各个微服务的REST接口来分别获取基础数据，然后在内存中再进行业务数据拼装后，再返回给用户。该方法无论从程序设计或是查询性能角度看，都不是一个很好的方法。那么如何解决微服务架构下的分布式数据查询问题呢? 在给出解决方案之前，需要读者首先了解下物化视图和命令查询职责分离等相关概念。</p> \n <h4 id=\"什么是物化视图-merialized-views\"><a href=\"#什么是物化视图-merialized-views\" class=\"headerlink\" title=\"什么是物化视图(merialized views)?\"></a>什么是物化视图(merialized views)?</h4>\n <p>物化视图是包括一个查询结果的数据库对像，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照。这个基本上就说出了物化视图的本质，它是一组查询的结果，这样势必为将来再次需要这组数据时大大提高查询性能。物化视图有两种刷新模式 ON DEMAND 和 ON COMMIT，用户可根据实际情况进行设置。</p> \n <p>物化视图对于应用层是透明的，不需要有任何的改动，终端用户甚至都感觉不到底层是用的物化视图。总之，使用物化视图的目的一个是提高查询性能，另一个是由于物化视图包含的数据是远程数据库的数据快照或拷贝，微服务可通过物化视图和命令查询职责分离(CQRS)技术(参见以下章节)实现分布式数据查询。</p> \n <h4 id=\"什么是命令查询职责分离-CQRS\"><a href=\"#什么是命令查询职责分离-CQRS\" class=\"headerlink\" title=\"什么是命令查询职责分离(CQRS)?\"></a>什么是命令查询职责分离(CQRS)?</h4>\n <p>在常用的单体应用架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题;另外更重要的是，在微服务架构下，通常需要跨多个微服务数据库来查询数据，此时，我们可借助命令查询职责分离(CQRS)来有效解决这些问题。</p> \n <p>CQRS 使用分离的接口将数据查询操作(Queries)和数据修改操作(Commands)分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了。使用 CQRS 分离了读写职责之后，可以对数据进行读写分离操作来改进性能，同时提高可扩展性和安全。如下图：</p> \n <p><img src=\"/assets/2017052712.jpg\" alt=\"\"></p> \n <p>主数据库处理 CUD，从库处理 R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成 ReportingDatabase，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。</p> \n <p><img src=\"/assets/2017052713.jpg\" alt=\"\"></p> \n <p>使用 ReportingDatabase 的一些优点通常可以使得查询变得更加简单高效：</p> \n <ul> \n  <li>ReportingDatabase 的结构和数据表会针对常用的查询请求进行设计。</li> \n  <li>ReportingDatabase 数据库通常会去正规化，存储一些冗余而减少必要的 Join 等联合查询操作，使得查询简化和高效，一些在主数据库中用不到的数据信息，在 ReportingDatabase 可以不用存储。</li> \n  <li>可以对 ReportingDatabase 重构优化，而不用去改变操作数据库。</li> \n  <li>对 ReportingDatabase 数据库的查询不会给操作数据库带来任何压力。</li> \n  <li>可以针对不同的查询请求建立不同的 ReportingDatabase 库。</li> \n </ul> \n <h4 id=\"如何实现事件驱动架构下的数据查询服务\"><a href=\"#如何实现事件驱动架构下的数据查询服务\" class=\"headerlink\" title=\"如何实现事件驱动架构下的数据查询服务?\"></a>如何实现事件驱动架构下的数据查询服务?</h4>\n <p>事件驱动不仅可以用于分布式数据一致性保证，还可以借助物化视图和命令查询职责分离技术，使用事件来维护不同微服务拥有数据预连接(pre-join)的物化视图，从而实现微服务架构下的分布式数据查询。维护物化视图的服务订阅了相关事件并在事件发生时更新物化视图。例如，客户订单视图更新服务(维护客户订单视图)会订阅由客户服务和订单服务发布的事件(您还可以使用事件来维护由多个微服务拥有的数据组成的物化视图。</p> \n <p><img src=\"/assets/2017052714.jpg\" alt=\"\"></p> \n <p>例如上图中间的 “客户订单视图更新”服务，主要负责客户订单视图的更新。该服务订阅了客户服务和订单服务发布的事件。当“客户订单视图更新”服务收到了上图左侧的客户或者订单更新事件，则会触发更新客户订单物化视图数据集。这里可以使用文档数据库(例如 MongoDB )来实现客户订单视图，为每个用户存储一个文档。而上图右侧的客户订单视图查询服务负责响应对客户以及最近订单(通过查询客户订单视图数据集)的查询。</p> \n <p>总之，上图所示业务逻辑，用到了事件驱动、物化视图和命令查询职责分离等技术，有效解决了微服务架构下分布式数据查询的问题。</p> \n <h3 id=\"事件驱动架构优缺点\"><a href=\"#事件驱动架构优缺点\" class=\"headerlink\" title=\"事件驱动架构优缺点\"></a>事件驱动架构优缺点</h3>\n <p>事件驱动架构既有优点也有缺点，此架构可以实现跨多个服务的事务实现，且提供最终数据一致性，并且使得服务能够自动维护查询视图;而缺点在于编程模式比传统基于事务的交易模式更加复杂，必须实现补偿事务以便从应用程序级故障中恢复，例如，如果信用检查不成功则必须取消订单;另外，应用必须应对不一致的数据，比如当应用读取未更新的最终视图时也会遇见数据不一致问题。另外一个缺点在于订阅者必须检测和忽略冗余事件，避免事件重复消费。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>在微服务架构中，每个微服务都有自己私有的数据集。不同微服务可能使用不同的SQL或者NoSQL数据库。尽管数据库架构有很强的优势，但是也面对数据分布式管理的挑战。第一个挑战就是如何在多服务之间维护业务数据一致性;第二个挑战是如何从多服务环境中获取一致性数据。</p> \n <p>最佳解决办法是采用事件驱动架构。其中碰到的一个挑战是如何原子性的更新状态和发布事件。有几种方法可以解决此问题，包括将数据库视为消息队列和事件源等。</p> \n <p>从目前技术应用范围和成熟度看，推荐使用第一种方式(本地事务发布事件)，来实现事件投递原子化，即可靠事件投递。</p> \n <h3 id=\"重要提醒\"><a href=\"#重要提醒\" class=\"headerlink\" title=\"重要提醒\"></a>重要提醒</h3>\n <p>数据一致性是微服务架构设计中唯恐避之不及却又不得不考虑的话题。通过保证事件驱动实现最终数据的一致性，此方案的优劣，也不能简单的一言而概之，而是应该根据场景定夺，适合的才是最好的。另外，我们在对微服务进行业务划分的时候就尽可能的避免“可能会产生一致性问题”的设计。如果这种设计过多，也许是时候考虑改改设计了。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:36','2018-12-19 15:45:36'),
(177,12,'你如何划分领域边界',1,'www.funtl.com/assets/201112241000166739.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"【领域驱动设计】浅谈聚合的划分与设计\"><a href=\"#【领域驱动设计】浅谈聚合的划分与设计\" class=\"headerlink\" title=\"【领域驱动设计】浅谈聚合的划分与设计\"></a>【领域驱动设计】浅谈聚合的划分与设计</h3>\n <p>聚合以及聚合根是领域驱动设计中的重要概念，根据定义，聚合是针对数据变化可以考虑成一个单元的一组相关的对象。聚合使用边界将内部和外部的对象划分开来。每个聚合有一个根。这个根是一个实体，并且它是外部可以访问的唯一的对象。根可以保持对任意聚合对象的引用，并且其他的对象可以持有任意其他的对象，但一个外部对象只能持有根对象的引用。如果边界内有其他的实体，那些实体的标识符是本地化的，只在聚合内有意义（参见《领域驱动设计-精简版》第42页）。从定义上看，貌似针对特定上下文的领域模型来讲，聚合的划分与设计并不那么困难，但事实却并非如此。在本文中，我将大致总结一下自己的经验，同时也欢迎关注领域驱动设计的朋友能够提出自己的见解。</p> \n <h3 id=\"聚合划分与设计其实与并发和事务性并不矛盾\"><a href=\"#聚合划分与设计其实与并发和事务性并不矛盾\" class=\"headerlink\" title=\"聚合划分与设计其实与并发和事务性并不矛盾\"></a>聚合划分与设计其实与并发和事务性并不矛盾</h3>\n <p>首先需要了解的是，合理地划分和设计聚合，并不会产生任何并发和事务性问题。我们所讨论的文章中之所以第一个设计方案会出现并发和事务性问题，就是因为它的聚合设计本身就不合理。这其实在本文一开始就明确了这个问题：聚合是针对数据变化可以考虑成一个单元的一组相关的对象。因此，必须承认对于一个聚合，其中包含的所有对象必须“同生死，共存亡”，基于聚合的数据操作应该就是原子操作，基础结构机制需要保证以聚合为单位的数据一致性。换句话说，聚合在数据一致性方面的表现，应该与基础结构机制所保证的并发和事务的正确性是等价的。数据访问时出现的事务失效现象，其实是源于聚合的不合理划分。比如，在《Effective Aggregate Design》一文中的例子里，事实上 Product 并不一定要依赖于 Release 才能存在，因此，在 Product 的聚合中，就不应该包含对 Release 的引用，然而相反，Release 是没法脱离 Product 而单独存在的，因为如果是这样的话，Release 也就失去了本身的含义，所以，Release 可以定义成一个聚合，而 Product 则是这个聚合中的一个实体。</p> \n <p>至此，我们可以得知，聚合的划分和设计必须依赖对通用语言、领域概念和模型的正确把握。接下来再让我们看两个我们经常遇到的例子：销售订单和论坛主题。</p> \n <h3 id=\"两个例子：销售订单（Sales-Order）-订单明细（Sales-Line）-vs-论坛主题（Post）-回复（Reply）\"><a href=\"#两个例子：销售订单（Sales-Order）-订单明细（Sales-Line）-vs-论坛主题（Post）-回复（Reply）\" class=\"headerlink\" title=\"两个例子：销售订单（Sales Order）/订单明细（Sales Line） vs. 论坛主题（Post）/回复（Reply）\"></a>两个例子：销售订单（Sales Order）/订单明细（Sales Line） vs. 论坛主题（Post）/回复（Reply）</h3>\n <p>很多网友会在这两个领域的建模上感到纠结，如果我们从数据库设计上考虑（以数据库驱动的开发方式进行思考），两者非常相似，都是主从表结构，都是1对多（1:N）的关系：一个销售订单对应多条订单明细，一个论坛主题对应多条回复。但如果我们用领域驱动的思想来考虑这个问题，我们会发现，这是两个截然不同的例子！两个例子中实体之间的关系完全不同。</p> \n <p>首先分析销售订单（Sales Order）/订单明细（Sales Line）：对于一张销售订单来说，订单明细是不可缺少的，否则就不成其为销售订单。试想，一张订单没有包含任何购买的货品信息，这意味着什么？因此，销售订单和订单明细之间的关系是一种固定的不可变（invariant）的关系，就像《领域驱动设计》一书中所讲的汽车与车轮之间的关系那样，汽车少了轮子就不成其为汽车了。反过来看，订单明细也离不开销售订单，这很简单，因为很明细订单明细是描述销售订单的一个不可或缺的部分。于是，在这个例子中，我们有一个聚合根为销售订单，其中包含一条或多条订单明细的聚合，聚合及其实体间的关系可以用下图表示：</p> \n <p><img src=\"/assets/201112241000166739.png\" alt=\"\"></p> \n <p>对于论坛主题（Post）/回复（Reply）之间的关系，情况却完全不同。论坛的主题是可以脱离回复单独存在的（一个主题可以没有任何人对其进行回复），而回复却不能脱离主题（没有主题的回复是没有意义的）。鉴于这样的事实，实际上在主题与回复这部分模型中，存在两个聚合：第一个聚合是以主题（Post）为聚合根，且仅包含其本身一个对象的聚合；另一个聚合是以回复（Reply）为聚合根，其中包含了对主题（Post）的引用的聚合。其关系可以如下表示：</p> \n <p><img src=\"/assets/201112241000175966.png\" alt=\"\"></p> \n <p>这样的设计，会让有些朋友感到不适应，原因是我们无法直接从Post实体获得其下所有的Reply实体，那么对于“通过给定的Post，获得与它相关的所有Reply信息”这样的用例，在实现上就不那么直接。此时，我们需要在应用层，通过Reply的仓储来获得，比如：</p> \n <pre><code>public IEnumerable&lt;ReplyDataObject&gt; GetRepliesForPost(Guid postId)\n{\n    using (IRepositoryContext context = IoCFactory.GetService&lt;IRepositoryContext&gt;();\n    {\n        ISpecification&lt;Reply&gt; spec = Specification&lt;Reply&gt;.Eval(r =&gt; r.Post.Id == postId);\n        IRepository&lt;Reply&gt; replyRepository = context.GetRepository&lt;Reply&gt;();\n        IEnumerable&lt;Reply&gt; replies = replyRepository.FindAll(spec);\n        List&lt;ReplyDataObject&gt; result = new List&lt;ReplyDataObject&gt;();\n        if (replies != null)\n        {\n                replies.ToList().ForEach(r =&gt; result.Add(DataObjectMapper.MapToDataObject(r));\n        }\n        return result;\n    }\n}\n</code></pre>\n <p>这部分内容牵涉到了应用层，或许你会觉得，这样做是不是把业务逻辑迁移到了应用层，导致领域模型失血。其实不然，在这里，应用层并没有参与任何业务逻辑，从仓储读取领域对象以及将领域对象转换成数据传输对象（DTO），这些并不属于业务逻辑的范畴：因为从领域模型和业务逻辑的角度看，它们并不能知道什么是仓储、什么是规约、什么是数据传输对象。应用层在这里起到了任务协调、数据转换等作用。不仅如此，应用层甚至还可以包含业务规则引擎以及工作流的实现（workflow）。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:36','2018-12-19 15:45:36'),
(178,12,'你如何进行领域建模',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"运用四色建模法进行领域分析\"><a href=\"#运用四色建模法进行领域分析\" class=\"headerlink\" title=\"运用四色建模法进行领域分析\"></a>运用四色建模法进行领域分析</h3>\n <p>领域建模有很多种方法，对于同样的问题域使用不同的建模手段得到的模型可能也不尽相同。于是我经常听到这样一个问题：怎么才能保证建模的正确性？</p> \n <p>这听起来是个合理的质疑，但实际上却不是那么有道理。首先我们需要明白建模的目的是什么？如果仅仅是为了描画问题，那么并没有什么对错之分——仅仅是立场和角度的差别；而如果是为了企业业务系统而进行建模，那么这个问题应该变为：如何保证模型能够支撑企业的运营？</p> \n <p><strong>我想用下面这个例子来简要的回答一下这个问题。</strong></p> \n <p>在开始分析和建模之前，我们需要知道企业业务系统的目的是什么；而企业业务系统的目的往往跟决策者或者管理的诉求相关。我们现在需要移情到一位管理者身上，看看他的诉求到底是什么。</p> \n <p>现在假想你是一家在线电子书店的 COO。突然有一天，有一位顾客向你投诉，说他订购的书少了一本，并且价钱算错了，他多给了钱。在你承诺理赔之前，你需要核对一下这位顾客说的是否属实。那么这个时候你需要知道什么样的信息才能做出准确的判断呢？</p> \n <p>简单来说，你需要知道这位顾客订购了那些书籍，付了多少钱以及书店到底为这个顾客递送了那些书籍。不幸的是，由于科技不够发达，你无法直接驾驶时间机器回到从前去亲眼看看发生了那些事。但幸运的是，你并不需要这么做，你只需要看看这位顾客的订单，和网银的支付记录以及你们书店交给EMS的快递单存根，就应该知道这些信息了。</p> \n <p>你找到了订单和 EMS 快递存根。发现这位顾客是在三天前订购的书，而你们在前天就已经将书邮寄出去了。并在订单上看到这位顾客一共订购了7本书，但是在EMS的快递存根上，并没有任何书籍的信息，只有地址，包裹号，邮费和重量什么的信息。这时候你觉得应该去询问一下配送部门，看看他们做了什么。</p> \n <p>在配送部门你根据包裹号查到了那个包裹的信息，果然里面只有6本书。同时你在包裹部门发现了一张延期交货单。上面说明由于缺货，这位顾客另外一本书正在等待发货。</p> \n <p>那么剩下的问题就是支付问题了，从网银的记录上看，客户不含邮费一共支付了132.5。订单上显示的价钱也是132.5，显然这位顾客并没有多付钱。</p> \n <p>为了保证准确，你重新从网站上选了这7本书，想看看是否也会是这个价钱。但你却意外的发现，一共只需要128.3。仔细辨认后，你发现有一本图书现在是促销。那么现在的问题是，促销到底是什么时候开始的？</p> \n <p>你到了市场部，市场部给了你一份近期促销计划。你发现那本书是昨天才开始促销的，也就是说在那位顾客在下订单的时候，促销还没有开始。</p> \n <p>这个时候，你觉得应该给你的顾客打一个电话致歉，商讨如何后续邮寄的问题，并向他说明促销的事情。</p> \n <p>你是否觉得这个 COO 当得有点累呢？这当然是虚构的。但是从这故事里面我们看到什么呢？</p> \n <p><strong>任何的业务事件都会以某种数据的形式留下足迹</strong></p> \n <p>我们对于事件的追溯可以通过对数据的追溯来完成。正如上面这个故事里，你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度的还原当时事情发生的场景。当我们把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰的推测出这个在过往的一段时间内到底发生了那些事情。</p> \n <p>那么为什么这些数据形成的链条能够成帮助我们追溯业务的营运呢？</p> \n <p>因为这些数据并不是随便挑选的。如果我们回顾一下你作为COO检查这个疏漏的过程，你首先选择了订单和EMS快递存根，换句话说，如果订单出现差错，或者EMS快递存根上说明你的确邮寄了7本书，那么这个疏漏的责任并不在你。所以这两个订单实际上这个你这个企业法律责任的起点和终点。</p> \n <p>当你确定这个疏漏的责任在你之后，你选择审查一些<strong>流程执行的结果</strong>，比如包裹存根。从而验证一些主要的业务流程执行的结果是否正确。换句话讲，这些数据是<strong>支撑你运营体系的关键流程的执行结果</strong>。</p> \n <p>正是由于这些数据是流程执行的结果，它们才使我们可以在不了解流程细节的前提下，对某些突发事件进行追述和分析。</p> \n <p>除了上面那个极端的例子（投诉），对于任何一笔正常的经济往来，我们都需要知道：</p> \n <ol> \n  <li>如果我付出一笔资金，那么我的权益是什么？</li> \n  <li>如果我收到一笔资金，那么我的义务是什么？</li> \n </ol> \n <p>而这些问题都需要业务系统捕捉到相应的足迹才能够回答。所以企业的业务系统主要的目的之一，就是记录这些足迹，并将这些足迹形成一条有效的追溯链。</p> \n <p>而作为业务分析师的你，则应该知道那些事件在运营上是需要追溯的，这些事件都留下了什么足迹。</p> \n <p>这些足迹通常都具有一个有意思的特性，即它们都是时标性对象（moment-interval）。发现这些时标性对象就是建模的起点。对于这些时标性对象稍加整理，我们就得到了整个领域模型的骨干：</p> \n <p>在得到骨干之后，我们需要丰富这个模型，使它可以更好的描述业务概念。这时候，我们需要补充一些实体对象。通常实体对象有三类：人，地点， 物（party/place/thing）。</p> \n <p>在这个基础上，我们可以进一步抽象这些实体事如果参与到各种不同的流程中去的，这时候，我们就需要用到角色（role）：</p> \n <p>最后再把一些需要描述的信息放入描述对象（description）。</p> \n <p>我们就得了应用四色建模方法（color modeling）建立的一套领域模型。</p> \n <p><strong>简要回顾一下上面的过程，不难发现我们建模的次序和重点：</strong></p> \n <ol> \n  <li>首先以满足管理和运营的需要为前提，寻找需要追溯的事件。</li> \n  <li>根据这些需要追溯，寻找足迹以及相应的时标性对象。</li> \n  <li>寻找时标对象周围的人／事／物</li> \n  <li>从中抽象角色</li> \n  <li>把一些信息用描述对象补足。</li> \n </ol> \n <p>由于在第一步中，我们就将管理和运营目标做为建模的出发点。因此，整套模型实际上是围绕这些“如何有效地追踪这些目标”而建立的，这样的模型可以保证模型支撑企业的运营。</p> \n <h3 id=\"四色建模法\"><a href=\"#四色建模法\" class=\"headerlink\" title=\"四色建模法\"></a>四色建模法</h3>\n <p>(Color UML)是由 Peter Coad 发明的一种建模方法，将抽象出来的对象分成四种原型（archetype）：</p> \n <ol> \n  <li>moment-interval：这种对象表示那些在某个时间点存在，或者会存在一段时间的，这样的对象往往表示了一次外界的请求，比如一次询价（Quotation），一次购买（Sale），这样的对象表示的都是系统的价值所在，所以也是最重要的一类对象，一般用粉红色来表示。这样的对象一般都有一个起始时间和终止时间，以及一个唯一的标识号，用来唯一的标识这一次客户请求，比如 PolicyNo.</li> \n  <li>Role：这种对象表示的是一种角色，往往由人或者物来承担，会有相应的责任和权利，一般一个 moment-interval 对象会关联多个 Role,比如说一次询价（Quotation）涉及到两个 Role, 询价人（Quoter）和询价的产品（Product for Quotation）, 这类对象是除 moment-interval 对象外最重要的一类对象，一般用黄色来表示。这类对象一般都有一些被 moment-interval 对象请求的操作，用来完成它们的职责。</li> \n  <li>Party：Place or Thing, 这种对象往往表示的是一种客观存在的事物，例如：人，组织，产品，配件等等，这些事物往往会在一种 moment-interval 中扮演某个 Role, 比如某个人会在一次购买中扮演 Customer 的角色，也可以在询价中扮演询价人的角色。这类对象第三重要，所以一般用绿色来表示。这类对象一般都有 Name, Address 等属性。</li> \n  <li>Description：这种对象一般是分类用或者描述性的对象，一般某个 Thing, Place，Party会属于某个 Description，主要用来表示一类事物，它的属性一般都是这一类事物都有的属性，这类对象一般用蓝色来表示。这类对象一般都有 type, defaultValue 等属性。</li> \n </ol> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>通过将分析得到的领域对象分别归入这四类原型，能让我们更加深刻的理解每个对象的职责，以及对象之间的相互关系，通过四种颜色，能表达出比一般的黑白模型更加丰富的领域信息。</p> \n <p>四色建模法和别的建模方法相比，更倾向于作为一种分析方法，而不是设计方法，它也可以看作是一种分析模式，和 Martin Fowler 的《分析模式》有异曲同工之妙。在《Java Modeling in Color with UML》这本书中，Peter Coad 给出了多个行业的通用对象模型，包括制造业，资源管理，人力资源管理，财务管理等等，当然都是用四色建模法表示的，确实有耳目一新之感。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:36','2018-12-19 15:45:36'),
(179,12,'你如何考虑服务化',1,'www.funtl.com/assets/fenbu.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"集中式与分布式\"><a href=\"#集中式与分布式\" class=\"headerlink\" title=\"集中式与分布式\"></a>集中式与分布式</h3>\n <p>要谈微服务，那么必须建立在分布式的基础上，对于一个集中式系统也无需谈微服务。</p> \n <p><img src=\"/assets/fenbu.jpg\" alt=\"\"></p> \n <h4 id=\"集中式\"><a href=\"#集中式\" class=\"headerlink\" title=\"集中式\"></a>集中式</h4>\n <p>集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力，仅负责数据的录入和输出。而运算、存储等全部在主机上进行。</p> \n <p>集中式系统的最大的特点就是部署结构非常简单，底层一般采用从IBM、HP等厂商购买到的昂贵的大型主机。因此无需考虑如何对服务进行多节点的部署，也就不用考虑各节点之间的分布式协作问题。但是，由于采用单机部署。很可能带来系统大而复杂、难于维护、发生单点故障（单个点发生故障的时候会波及到整个系统或者网络，从而导致整个系统或者网络的瘫痪）、扩展性差等问题。</p> \n <h4 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h4>\n <p>分布式就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p> \n <p>拿电商网站来说，我们一般把一个电商网站横向拆分成商品模块、订单模块、购物车模块、消息模块、支付模块等。然后我们把不同的模块部署到不同的机器上，各个模块之间通过远程服务调用(<code>RPC</code>)等方式进行通信。以一个分布式的系统对外提供服务。</p> \n <h3 id=\"服务化\"><a href=\"#服务化\" class=\"headerlink\" title=\"服务化\"></a>服务化</h3>\n <p>提到分布式，一个不得不提的词就是服务化，服务化架构使搭建分布式系统成为了可能。</p> \n <p>传统的软件开发面临着很多的问题，比如： 代码重复率高、代码庞大难以维护、无法快速迭代、测试成本高、可伸缩性差、可靠性差、模块间高度依赖。为了解决上面这些问题，我们一般采用拆分、解耦、分层、独立等方式来解决。有了服务化架构，我们就可以在很大程度上解决这些问题。</p> \n <blockquote> \n  <p>服务化是一种粗粒度、松耦合的以服务为中心的架构，服务之间通过定义明确的协议和接口进行通信。</p> \n </blockquote> \n <p>这里说到的“服务”，本质上来说，就是指“RPC”。单纯的RPC功能实现，其实很简单，无非就是client发起调用，中间某个组件（甚至就是client本身）拦截调用信息，序列化后将信息传输到server端，server端收到调用请求后反序列化，根据请求详细发起实际调用后返回响应传输回给client端。这样的RPC很常见，比如常见的存储过程调用就是一例。但是在一个复杂的业务环境，如何管理和协同这些大量的RPC才是最麻烦的事情。所以，一般提到的“服务化”更多指的是对RPC的管理。服务化一般关注服务注册，服务协调，服务可用性，服务通讯协议和内容交换等。</p> \n <p><img src=\"/assets/RPC.jpg\" alt=\"\"></p> \n <h3 id=\"面向服务的架构\"><a href=\"#面向服务的架构\" class=\"headerlink\" title=\"面向服务的架构\"></a>面向服务的架构</h3>\n <p>面向服务架构（Service-Oriented Architecture，<code>SOA</code>）又称“面向服务的体系结构”，是Gartner于2O世纪9O年代中期提出的面向服务架构的概念。</p> \n <blockquote> \n  <p>面向服务架构，从语义上说，它与面向过程、面向对象、面向组件一样，是一种软件组建及开发的方式。与以往的软件开发、架构模式一样，SOA 只是一种体系、一种思想，而不是某种具体的软件产品。</p> \n </blockquote> \n <p><img src=\"/assets/SOA.jpg\" alt=\"\"></p> \n <p>这里，我们通过一个例子来解释一下到底什么是 SOA？如何做到 SOA？</p> \n <h4 id=\"什么是-SOA\"><a href=\"#什么是-SOA\" class=\"headerlink\" title=\"什么是 SOA\"></a>什么是 SOA</h4>\n <p>SOA 也可以说是一种是设计原则（模式），那么它包含哪些内容呢？事实上，这方面并没有最标准的答案，多数是遵从著名 SOA 专家 Thomas Erl 的归纳：</p> \n <ul> \n  <li>标准化的服务契约 Standardized service contract</li> \n  <li>服务的松耦合 Service loose coupling</li> \n  <li>服务的抽象 Service abstraction</li> \n  <li>服务的可重用性 Service reusability</li> \n  <li>服务的自治性 Service autonomy</li> \n  <li>服务的无状态性 Service statelessness</li> \n  <li>服务的可发现性 Service discoverability</li> \n  <li>服务的可组合性 Service composability</li> \n </ul> \n <p>这些原则总的来说要达到的目的是：提高软件的重用性，减少开发和维护的成本，最终增加一个公司业务的敏捷度。既然是面向服务的架构，那么我们就先来定义一个服务，</p> \n <pre><code>public interface Echo {\n    String echo(String text);\n}\n\npublic class EchoImpl implements Echo {\n    public String echo(String text) {\n        return text;\n    }\n}\n</code></pre>\n <p>上面这段代码相信有过 JavaWeb 开发经验的人都不会陌生。就是定义了一个服务的接口和实现。</p> \n <p>那么，定义了服务，我们就做到了 SOA 了么？</p> \n <p>我们用 Thomas Erl 定义的原则来对比一下，用松耦合和可重用这几个原则来尝试分析一下上面 Echo 示例：</p> \n <ul> \n  <li>Echo 的服务契约是用 Java 接口定义，而不是一种与平台和语言无关的标准化协议，如 WSDL，CORBA IDL。当然可以抬杠，Java 也是行业标准，甚至全国牙防组一致认定的东西也是行业标准。</li> \n  <li>Java 接口大大加重了与 Service 客户端的耦合度，即要求客户端必须也是 Java，或者 JVM 上的动态语言（如Groovy、Jython）等等……</li> \n  <li>同时，Echo 是一个 Java 的本地接口，就要求调用者最好在同一个 JVM 进程之内……</li> \n  <li>Echo 的业务逻辑虽然简单独立，但以上技术方面的局限就导致它无法以后在其他场合被轻易重用，比如分布式环境，异构平台等等 ESB 是 SCA 思想实现的基础设施。ESB 主要作用是集中注册发布服务，为服务与传输协议之间解耦。并不是所有的 SOA 架构都需要 ESB，ESB 是 SCA 特有的。当然任何符合 ESB 特征的解决方式都可以称之为 ESB，也不仅仅是 SCA 内部的。</li> \n </ul> \n <p>因此，我们可以认为 Echo 并不太符合 SOA 的基本设计原则。</p> \n <h4 id=\"实现-SOA\"><a href=\"#实现-SOA\" class=\"headerlink\" title=\"实现 SOA\"></a>实现 SOA</h4>\n <p>修改一下上面的 Echo，添加 Java EE 的 <code>@WebServices</code> 注解</p> \n <pre><code>@WebServices\npublic class EchoImpl implements Echo {\n    public String echo(String text) {\n        return text;\n    }\n}\n</code></pre>\n <p>现在将 Echo 发布为 Java WebServices，并由底层框架自动生成 WSDL 来作为标准化的服务契约，这样就能与远程的各种语言和平台互操作了，较好的解决了上面提到的松耦合和可重用的问题。按照一般的理解，Echo 似乎就成为比较理想的 SOA service了。</p> \n <p>使用 WebServices 只是一种相对简单的方案，SOA 的最常见的解决方案是 SCA，其次还有 JBI，BPEL 等。ESB 是 SCA 思想实现的基础设施。ESB 主要作用是集中注册发布服务，为服务与传输协议之间解耦。关于 SCA 和 ESB 并不是本文的重点，感兴趣的朋友可以从网络上获取更多资料。(可以从上图中看到 ESB 在整个 SOA 架构中所扮演的角色)</p> \n <h3 id=\"面向对象和面向服务的对比\"><a href=\"#面向对象和面向服务的对比\" class=\"headerlink\" title=\"面向对象和面向服务的对比\"></a>面向对象和面向服务的对比</h3>\n <p>面向对象（<code>OO</code>）和面向服务（<code>SO</code>）在基础理念上有大量共通之处，比如都尽可能追求抽象、封装和低耦合。</p> \n <p>但 SO 相对于 OO，又有非常不同的典型应用场景，比如：</p> \n <ul> \n  <li>多数 OO 接口（interface）都只被有限的人使用（比如团队和部门内），而 SO 接口（或者叫契约）一般来说都不应该对使用者的范围作出太多的限定和假设（可以是不同部门，不同企业，不同国家）。还记得贝佐斯原则吗？“团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外”。</li> \n  <li>多数 OO 接口都只在进程内被访问，而 SO 接口通常都是被远程调用。</li> \n </ul> \n <p>简单讲，就是 SO 接口使用范围比一般 OO 接口可能广泛得多。我们用网站打个比方：一个大型网站的 web 界面就是它整个系统入口点和边界，可能要面对全世界的访问者（所以经常会做国际化之类的工作），而系统内部传统的 OO 接口和程序则被隐藏在 web 界面之后，只被内部较小范围使用。而理想的 SO 接口和 web 界面一样，也是变成系统入口和边界，可能要对全世界开发者开放，因此 SO 在设计开发之中与 OO 相比其实会有很多不同。</p> \n <h3 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h3>\n <p>微服务架构(<code>MicroService</code>)是一种服务化架构风格，通过将功能分散到各个离散的服务中以实现对解决方案的解耦。微服务架构强调的第一个重点就是业务系统需要彻底的组件化和服务化（这也是我们为什么要先介绍组件化和服务化的原因）。微服务的诞生并非偶然。它是互联网高速发展，敏捷、精益、持续交付方法论的深入人心，虚拟化技术与 DevOps 文化的快速发展以及传统单块架构无法适应快速变化等多重因素的推动下所诞生的产物。</p> \n <p>微服务的流行，Martin 功不可没，先看看他是如何定义微服务的：</p> \n <ul> \n  <li>一些列的独立的服务共同组成系统</li> \n  <li>单独部署，跑在自己的进程里</li> \n  <li>每个服务为独立的业务开发</li> \n  <li>分布式的管理</li> \n </ul> \n <p>Martin 自己也说了，每个人对微服务都可以有自己的理解，不过大概的标准还是有一些的。</p> \n <ul> \n  <li>分布式服务组成的系统</li> \n  <li>按照业务而不是技术来划分组织</li> \n  <li>做有生命的产品而不是项目</li> \n  <li>Smart endpoints and dumb pipes（我的理解是强服务个体和弱通信）</li> \n  <li>自动化运维（DevOps）</li> \n  <li>容错</li> \n  <li>快速演化</li> \n </ul> \n <h3 id=\"SOA-和微服务\"><a href=\"#SOA-和微服务\" class=\"headerlink\" title=\"SOA 和微服务\"></a>SOA 和微服务</h3>\n <p>看了 SOA 和微服务，很多人会认为这不就是一回事儿么。其实 SOA 和微服务就是差不多的。</p> \n <ul> \n  <li>SOA 关注的是服务重用，微服务在关注服务重用的同时，也同时关注快速交付；</li> \n  <li>微服务不再强调传统 SOA 架构里面比较重的 ESB 企业服务总线。微服务把所有的“思考”逻辑包括路由、消息解析等放在服务内部，去掉一个大一统的 ESB，服务间轻通信，是比 SOA 更彻底的拆分。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-19 15:45:36','2018-12-19 15:45:36'),
(180,12,'说说概要设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>概要设计是一个设计师根据用户交互过程和用户需求来形成交互框架和视觉框架的过程，其结果往往以反映交互控件布置、界面元素分组以及界面整体板式的页面框架图的形式来呈现。这是一个在用户研究和设计之间架起桥梁，使用户研究和设计无缝结合，将对用户目标与需求转换成具体界面设计解决方案的重要阶段。</p> \n <p>概要设计的主要任务是把需求分析得到的系统扩展用例图转换为软件结构和数据结构。设计软件结构的具体任务是：将一个复杂系统按功能进行模块划分、建立模块的层次结构及调用关系、确定模块间的接口及人机界面等。数据结构设计包括数据特征的描述、确定数据的结构特性、以及数据库的设计。显然，概要设计建立的是目标系统的逻辑模型，与计算机无关。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:36','2018-12-19 15:45:36'),
(181,12,'分布式事务',1,'www.funtl.com/assets/success.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"分布式一致性\"><a href=\"#分布式一致性\" class=\"headerlink\" title=\"分布式一致性\"></a>分布式一致性</h3>\n <p>在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的 CRUD 等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。</p> \n <p>为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有<strong>二阶提交协议（Two Phase Commitment Protocol）</strong>、<strong>三阶提交协议（Three Phase Commitment Protocol）</strong> 和 <strong>Paxos 算法</strong>。</p> \n <h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3>\n <blockquote> \n  <p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p> \n </blockquote> \n <p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足 ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该 commit 还是 rollback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。</p> \n <h3 id=\"XA-规范\"><a href=\"#XA-规范\" class=\"headerlink\" title=\"XA 规范\"></a>XA 规范</h3>\n <p>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。 通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。 一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。</p> \n <blockquote> \n  <p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。 </p> \n </blockquote> \n <p>二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现 XA 分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)</p> \n <h3 id=\"2PC\"><a href=\"#2PC\" class=\"headerlink\" title=\"2PC\"></a>2PC</h3>\n <blockquote> \n  <p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p> \n </blockquote> \n <p>所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)</strong> 和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p> \n <h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4>\n <p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p> \n <p>可以进一步将准备阶段分为以下三个步骤：</p> \n <ol> \n  <li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li> \n  <li>参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li> \n  <li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li> \n </ol> \n <h4 id=\"提交阶段\"><a href=\"#提交阶段\" class=\"headerlink\" title=\"提交阶段\"></a>提交阶段</h4>\n <p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚( Rollback )消息；否则，发送提交( Commit )消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p> \n <p>接下来分两种情况分别讨论提交阶段的过程。</p> \n <p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：</p> \n <p><img src=\"/assets/success.png\" alt=\"\"></p> \n <ol> \n  <li>协调者节点向所有参与者节点发出”正式提交( commit )”的请求。</li> \n  <li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li> \n  <li>参与者节点向协调者节点发送”完成”消息。</li> \n  <li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li> \n </ol> \n <p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p> \n <p><img src=\"/assets/fail.png\" alt=\"\"></p> \n <ol> \n  <li>协调者节点向所有参与者节点发出”回滚操作( rollback )”的请求。</li> \n  <li>参与者节点利用之前写入的 Undo 信息执行回滚，并释放在整个事务期间内占用的资源。</li> \n  <li>参与者节点向协调者节点发送”回滚完成”消息。</li> \n  <li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li> \n </ol> \n <p><strong>不管最后结果如何，第二阶段都会结束当前事务。</strong></p> \n <p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个<strong>缺点</strong>的：</p> \n <ol> \n  <li><strong>同步阻塞问题</strong>：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li> \n  <li><strong>单点故障</strong>：由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li> \n  <li><strong>数据不一致</strong>：在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li> \n  <li>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li> \n </ol> \n <p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p> \n <h3 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h3>\n <blockquote> \n  <p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p> \n </blockquote> \n <p><img src=\"/assets/3pccommit.png\" alt=\"\"></p> \n <p>与两阶段提交不同的是，三阶段提交有两个改动点。</p> \n <ol> \n  <li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li> \n  <li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li> \n </ol> \n <p>也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 <code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code> 三个阶段。</p> \n <h4 id=\"CanCommit-阶段\"><a href=\"#CanCommit-阶段\" class=\"headerlink\" title=\"CanCommit 阶段\"></a>CanCommit 阶段</h4>\n <p>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p> \n <ol> \n  <li><strong>事务询问</strong>：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li> \n  <li><strong>响应反馈</strong>：参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li> \n </ol> \n <h4 id=\"PreCommit-阶段\"><a href=\"#PreCommit-阶段\" class=\"headerlink\" title=\"PreCommit 阶段\"></a>PreCommit 阶段</h4>\n <p>协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p> \n <p><strong>1. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</strong></p> \n <ul> \n  <li>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。</li> \n  <li>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。</li> \n  <li>响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</li> \n </ul> \n <p><strong>2. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p> \n <ul> \n  <li>发送中断请求：协调者向所有参与者发送 abort 请求。</li> \n  <li>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li> \n </ul> \n <h4 id=\"doCommit-阶段\"><a href=\"#doCommit-阶段\" class=\"headerlink\" title=\"doCommit 阶段\"></a>doCommit 阶段</h4>\n <p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p> \n <p><strong>1. 执行提交</strong></p> \n <ul> \n  <li>发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</li> \n  <li>事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li> \n  <li>响应反馈：事务提交完之后，向协调者发送 ACK 响应。</li> \n  <li>完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</li> \n </ul> \n <p><strong>2. 中断事务</strong></p> \n <p>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p> \n <ul> \n  <li>发送中断请求：协调者向所有参与者发送 abort 请求</li> \n  <li>事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li> \n  <li>反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息</li> \n  <li>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li> \n </ul> \n <blockquote> \n  <p>在 <code>doCommit</code> 阶段，如果参与者无法及时接收到来自协调者的 <code>doCommit</code> 或者 <code>abort</code> 请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了 <code>PreCommit</code> 请求，那么协调者产生 <code>PreCommit</code> 请求的前提条件是他在第二阶段开始之前，收到所有参与者的 <code>CanCommit</code> 响应都是 <code>Yes</code>。（一旦参与者收到了 <code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到 <code>commit</code> 或者 <code>abort</code> 响应，但是他有理由相信：成功提交的几率很大。）</p> \n </blockquote> \n <h3 id=\"2PC-与-3PC-的区别\"><a href=\"#2PC-与-3PC-的区别\" class=\"headerlink\" title=\"2PC 与 3PC 的区别\"></a>2PC 与 3PC 的区别</h3>\n <p>相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p> \n</div>',NULL,NULL,'2018-12-19 15:45:37','2018-12-19 15:45:37'),
(182,12,'面试宝典',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av31873911/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/09/16/interview/Java-面试宝典-知己知彼百战不殆/\">面试心经-知己知彼百战不殆</a></li> \n </ul> \n <h3 id=\"简历篇\"><a href=\"#简历篇\" class=\"headerlink\" title=\"简历篇\"></a>简历篇</h3>\n <ul> \n  <li>自我介绍</li> \n  <li>项目介绍</li> \n </ul> \n <h3 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h3>\n <ul> \n  <li><h4 id=\"Java-基础\"><a href=\"#Java-基础\" class=\"headerlink\" title=\"Java 基础\"></a>Java 基础</h4>\n   <ul> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-面向对象的特征/\">面向对象的特征</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-final-finally-finalize-的区别/\">final, finally, finalize 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-int-和-Integer-有什么区别/\">int 和 Integer 有什么区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-重载和重写的区别/\">重载和重写的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-抽象类和接口有什么区别/\">抽象类和接口有什么区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-说说反射的用途及实现/\">说说反射的用途及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-说说自定义注解的场景及实现/\">说说自定义注解的场景及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HTTP-请求的-GET-与-POST-方式的区别/\">HTTP 请求的 GET 与 POST 方式的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-session-与-cookie-区别/\">session 与 cookie 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-session-分布式处理/\">session 分布式处理</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-JDBC-流程/\">JDBC 流程</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-MVC-设计思想/\">MVC 设计思想</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-equals-与-的区别/\">equals 与 == 的区别</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-集合\"><a href=\"#Java-集合\" class=\"headerlink\" title=\"Java 集合\"></a>Java 集合</h4>\n   <ul> \n    <li><a href=\"/2018/07/11/interview/Java-面试宝典-List-和-Set-区别/\">List 和 Set 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-List-和-Map-区别/\">List 和 Map 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-Arraylist-与-LinkedList-区别/\">ArrayList 与 LinkedList 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-ArrayList-与-Vector-区别/\">ArrayList 与 Vector 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-和-HashTable-的区别/\">HashMap 和 HashTable 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashSet-和-HashMap-区别/\">HashSet 和 HashMap 区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-和-ConcurrentHashMap-的区别/\">HashMap 和 ConcurrentHashMap 的区别</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-HashMap-的工作原理及代码实现/\">HashMap 的工作原理及代码实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-ConcurrentHashMap-的工作原理及代码实现/\">ConcurrentHashMap 的工作原理及代码实现</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-线程\"><a href=\"#Java-线程\" class=\"headerlink\" title=\"Java 线程\"></a>Java 线程</h4>\n   <ul> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-创建线程的方式及实现/\">创建线程的方式及实现</a></li> \n    <li><a href=\"/2018/04/07/interview/Java-面试宝典-sleep-、join（）、yield（）有什么区别/\">sleep() 、join（）、yield（）有什么区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CountDownLatch-原理/\">说说 CountDownLatch 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CyclicBarrier-原理/\">说说 CyclicBarrier 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-Semaphore-原理/\">说说 Semaphore 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-Exchanger-原理/\">说说 Exchanger 原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-CountDownLatch-与-CyclicBarrier-区别/\">说说 CountDownLatch 与 CyclicBarrier 区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ThreadLocal-原理分析/\">ThreadLocal 原理分析</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-讲讲线程池的实现原理/\">讲讲线程池的实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-线程池的几种方式与使用场景/\">线程池的几种方式与使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-线程的生命周期/\">线程的生命周期</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Java-锁机制\"><a href=\"#Java-锁机制\" class=\"headerlink\" title=\"Java 锁机制\"></a>Java 锁机制</h4>\n   <ul> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说线程安全问题/\">说说线程安全问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-volatile-实现原理/\">volatile 实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-synchronize-实现原理/\">synchronize 实现原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-synchronized-与-lock-的区别/\">synchronized 与 lock 的区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-CAS-乐观锁/\">CAS 乐观锁</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ABA-问题/\">ABA 问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-乐观锁的业务场景及实现方式/\">乐观锁的业务场景及实现方式</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"核心篇\"><a href=\"#核心篇\" class=\"headerlink\" title=\"核心篇\"></a>核心篇</h3>\n <ul> \n  <li><h4 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h4>\n   <ul> \n    <li><a href=\"/2018/08/26/interview/58-到家-MySQL-军规升级版/\">58 到家 MySQL 军规升级版（如何优化 MySQL）</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-MySQL-索引使用的注意事项/\">MySQL 索引使用的注意事项</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说反模式设计/\">说说反模式设计</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说分库与分表设计/\">说说分库与分表设计</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-分库与分表带来的分布式困境与应对之策/\">分库与分表带来的分布式困境与应对之策</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-说说-SQL-优化之道/\">说说 SQL 优化之道</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-MySQL-遇到的死锁问题/\">MySQL 遇到的死锁问题</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-存储引擎的-InnoDB-与-MyISAM/\">存储引擎的 InnoDB 与 MyiSAM</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-数据库索引的原理/\">数据库索引的原理</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-为什么要用-B-Tree/\">为什么要用 B-Tree</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聚集索引与非聚集索引的区别/\">聚集索引与非聚集索引的区别</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-limit-20000-加载很慢怎么解决/\">limit 20000 加载很慢怎么解决</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-选择合适的分布式主键方案/\">选择合适的分布式主键方案</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-选择合适的数据存储方案/\">选择合适的数据存储方案</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-ObjectId-规则/\">ObjectId 规则</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-MongoDB-使用场景/\">聊聊 MongoDB 使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-倒排索引/\">倒排索引</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-ElasticSearch-使用场景/\">聊聊 ElasticSearch 使用场景</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"缓存使用\"><a href=\"#缓存使用\" class=\"headerlink\" title=\"缓存使用\"></a>缓存使用</h4>\n   <ul> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-有哪些类型/\">Redis 有哪些类型</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-内部结构/\">Redis 内部结构</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-内存淘汰机制/\">Redis 内存淘汰机制</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-聊聊-Redis-使用场景/\">聊聊 Redis 使用场景</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-持久化机制/\">Redis 持久化机制</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-集群方案与实现/\">Redis 集群方案与实现</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-Redis-为什么是单线程的/\">Redis 为什么是单线程的</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-缓存崩溃/\">缓存崩溃</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-缓存降级/\">缓存降级</a></li> \n    <li><a href=\"/2018/04/08/interview/Java-面试宝典-使用缓存的合理性问题/\">使用缓存的合理性问题</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息队列的使用场景/\">消息队列的使用场景</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的重发补偿解决思路/\">消息的重发补偿解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的幂等性解决思路/\">消息的幂等性解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-消息的堆积解决思路/\">消息的堆积解决思路</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-自己如何实现消息队列/\">自己如何实现消息队列</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何保证消息的有序性/\">如何保证消息的有序性</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"框架篇\"><a href=\"#框架篇\" class=\"headerlink\" title=\"框架篇\"></a>框架篇</h3>\n <ul> \n  <li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-BeanFactory-和-ApplicationContext-有什么区别/\">BeanFactory 和 ApplicationContext 有什么区别</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-Bean-的生命周期/\">Spring Bean 的生命周期</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-IOC-如何实现/\">Spring IOC 如何实现</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Spring-AOP/\">说说 Spring AOP</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-AOP-实现原理/\">Spring AOP 实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-动态代理（CGLIB-与-JDK）/\">动态代理（CGLIB 与 JDK）</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-事务实现方式/\">Spring 事务实现方式</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-事务底层原理/\">Spring 事务底层原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何自定义注解实现功能/\">如何自定义注解实现功能</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-MVC-运行流程/\">Spring MVC 运行流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-MVC-启动流程/\">Spring MVC 启动流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-的单例实现原理/\">Spring 的单例实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Spring-框架中用到了哪些设计模式/\">Spring 框架中用到了哪些设计模式</a></li> \n    <li>Spring 其他产品（Spring Boot、Spring Cloud、Spring Security、Spring Data、Spring AMQP 等）<br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-为什么选择-Netty/\">为什么选择 Netty</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说业务中-Netty-的使用场景/\">说说业务中 Netty 的使用场景</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-原生的-NIO-在-JDK-1-7-版本存在-EPoll-BUG/\">原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-什么是-TCP-粘包-拆包/\">什么是 TCP 粘包/拆包</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-TCP-粘包-拆包的解决办法/\">TCP 粘包/拆包的解决办法</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-线程模型/\">Netty 线程模型</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Netty-的零拷贝/\">说说 Netty 的零拷贝</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-内部执行流程/\">Netty 内部执行流程</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-Netty-重连实现/\">Netty 重连实现</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"微服务篇\"><a href=\"#微服务篇\" class=\"headerlink\" title=\"微服务篇\"></a>微服务篇</h3>\n <ul> \n  <li><h4 id=\"微服务\"><a href=\"#微服务\" class=\"headerlink\" title=\"微服务\"></a>微服务</h4>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-前后端分离是如何做的/\">前后端分离是如何做的</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何解决跨域/\">如何解决跨域</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-微服务哪些框架/\">微服务哪些框架</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RPC-框架/\">你怎么理解 RPC 框架</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-RPC-的实现原理/\">说说 RPC 的实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-Dubbo-的实现原理/\">说说 Dubbo 的实现原理</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RESTful/\">你怎么理解 RESTful</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说如何设计一个良好的-API/\">说说如何设计一个良好的 API</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何理解-RESTful-API-的幂等性/\">如何理解 RESTful API 的幂等性</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何保证接口的幂等性/\">如何保证接口的幂等性</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说-CAP-定理、-BASE-理论/\">说说 CAP 定理、 BASE 理论</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-怎么考虑数据一致性问题/\">怎么考虑数据一致性问题</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-说说最终一致性的实现方案/\">说说最终一致性的实现方案</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-你怎么看待微服务/\">你怎么看待微服务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务与-SOA-的区别/\">微服务与 SOA 的区别</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-如何拆分服务/\">如何拆分服务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务如何进行数据库管理/\">微服务如何进行数据库管理</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-如何应对微服务的链式调用异常/\">如何应对微服务的链式调用异常</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-对于快速追踪与定位问题/\">对于快速追踪与定位问题</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-微服务的安全/\">微服务的安全</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h4>\n   <ul> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-谈谈业务中使用分布式的场景/\">谈谈业务中使用分布式的场景</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-Session-分布式方案/\">Session 分布式方案</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-分布式锁的场景/\">分布式锁的场景与实现</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-分布式事务/\">分布式事务</a></li> \n    <li><a href=\"/2018/04/10/interview/Java-面试宝典-集群与负载均衡的算法与实现/\">集群与负载均衡的算法与实现</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"安全篇\"><a href=\"#安全篇\" class=\"headerlink\" title=\"安全篇\"></a>安全篇</h3>\n <ul> \n  <li><a href=\"/2018/04/10/interview/Java-面试宝典-安全要素与-STRIDE-威胁/\">安全要素与 STRIDE 威胁</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-防范常见的-Web-攻击/\">防范常见的 Web 攻击</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-服务端通信安全攻防/\">服务端通信安全攻防</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-HTTPS-原理剖析/\">HTTPS 原理剖析</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-HTTPS-降级攻击/\">HTTPS 降级攻击</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-授权与认证/\">授权与认证</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-基于角色的访问控制/\">基于角色的访问控制</a></li> \n  <li>基于数据的访问控制</li> \n </ul> \n <h3 id=\"性能篇\"><a href=\"#性能篇\" class=\"headerlink\" title=\"性能篇\"></a>性能篇</h3>\n <ul> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-性能指标有哪些/\">性能指标有哪些</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-如何发现性能瓶颈/\">如何发现性能瓶颈</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-性能调优的常见手段/\">性能调优的常见手段</a></li> \n  <li>说说你在项目中如何进行性能调优</li> \n </ul> \n <h3 id=\"设计模式篇\"><a href=\"#设计模式篇\" class=\"headerlink\" title=\"设计模式篇\"></a>设计模式篇</h3>\n <ul> \n  <li>你项目中有使用哪些设计模式</li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-说说常用开源框架中设计模式使用分析/\">说说常用开源框架中设计模式使用分析</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-说说你对设计原则的理解/\">说说你对设计原则的理解</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-23-种设计模式的设计理念/\">23 种设计模式的设计理念</a></li> \n  <li><a href=\"/2018/04/11/interview/Java-面试宝典-设计模式之间的异同，例如策略模式与状态模式的区别/\">设计模式之间的异同，例如策略模式与状态模式的区别</a></li> \n  <li><a href=\"/2018/04/12/interview/Java-面试宝典-设计模式之间的结合，例如策略模式-简单工厂模式的实践/\">设计模式之间的结合，例如策略模式 + 简单工厂模式的实践</a></li> \n  <li><a href=\"/2018/04/12/interview/Java-面试宝典-设计模式的性能，例如单例模式哪种性能更好/\">设计模式的性能，例如单例模式哪种性能更好</a></li> \n </ul> \n <h3 id=\"工程篇\"><a href=\"#工程篇\" class=\"headerlink\" title=\"工程篇\"></a>工程篇</h3>\n <ul> \n  <li><h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4>\n   <ul> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何对需求原型进行理解和拆分/\">你如何对需求原型进行理解和拆分</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你对功能性需求的理解/\">说说你对功能性需求的理解</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你对非功能性需求的理解/\">说说你对非功能性需求的理解</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你针对产品提出哪些交互和改进意见/\">你针对产品提出哪些交互和改进意见</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何理解用户痛点/\">你如何理解用户痛点</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"设计能力\"><a href=\"#设计能力\" class=\"headerlink\" title=\"设计能力\"></a>设计能力</h4>\n   <ul> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说你在项目中使用过的-UML-图/\">说说你在项目中使用过的 UML 图</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何考虑组件化/\">你如何考虑组件化</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何考虑服务化/\">你如何考虑服务化</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何进行领域建模/\">你如何进行领域建模</a></li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-你如何划分领域边界/\">你如何划分领域边界</a></li> \n    <li>说说你项目中的领域建模</li> \n    <li><a href=\"/2018/04/13/interview/Java-面试宝典-说说概要设计/\">说说概要设计</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"业务工程\"><a href=\"#业务工程\" class=\"headerlink\" title=\"业务工程\"></a>业务工程</h3>\n <ul> \n  <li>你系统中的前后端分离是如何做的</li> \n  <li>说说你的开发流程</li> \n  <li>你和团队是如何沟通的</li> \n  <li>你如何进行代码评审</li> \n  <li>说说你对技术与业务的理解</li> \n  <li>说说你在项目中经常遇到的 Exception</li> \n  <li>说说你在项目中遇到感觉最难Bug，怎么解决的</li> \n  <li>说说你在项目中遇到印象最深困难，怎么解决的</li> \n  <li>你觉得你们项目还有哪些不足的地方</li> \n  <li>你是否遇到过 CPU 100%，如何排查与解决</li> \n  <li><a href=\"/2018/04/13/interview/Java-面试宝典-你是否遇到过内存-OOM，如何排查与解决/\">你是否遇到过内存 OOM，如何排查与解决</a></li> \n  <li>说说你对敏捷开发的实践</li> \n  <li>说说你对开发运维的实践</li> \n  <li>介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色<br><br><h3 id=\"软实力\"><a href=\"#软实力\" class=\"headerlink\" title=\"软实力\"></a>软实力</h3></li> \n  <li>说说你的亮点</li> \n  <li>说说你最近在看什么书</li> \n  <li>说说你觉得最有意义的技术书籍</li> \n  <li>说说个人发展方向方面的思考</li> \n  <li>说说你认为的服务端开发工程师应该具备哪些能力</li> \n  <li>说说你认为的架构师是什么样的，架构师主要做什么</li> \n  <li>说说你所理解的技术专家<br><br><h3 id=\"人力面\"><a href=\"#人力面\" class=\"headerlink\" title=\"人力面\"></a>人力面</h3></li> \n  <li>你为什么离开之前的公司</li> \n  <li>你为什么要进我们公司</li> \n  <li>说说职业规划</li> \n  <li>你如何看待加班问题</li> \n  <li>谈一谈你的一次失败经历</li> \n  <li>你觉得你最大的优点是什么</li> \n  <li>你觉得你最大的缺点是什么</li> \n  <li>你在工作之余做什么事情</li> \n  <li>你为什么认为你适合这个职位</li> \n  <li>你觉得自己那方面能力最急需提高</li> \n  <li>你来我们公司最希望得到什么</li> \n  <li>你希望从这份工作中获得什么</li> \n  <li>你对现在应聘的职位有什么了解</li> \n  <li>您还有什么想问的</li> \n  <li>你怎么看待自己的职涯</li> \n  <li>谈谈你的家庭情况</li> \n  <li>你有什么业余爱好</li> \n  <li>你计划在公司工作多久</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(183,12,'抽象类和接口有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>参数</th> \n    <th>抽象类</th> \n    <th>接口</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>默认的方法实现</td> \n    <td>它可以有默认的方法实现</td> \n    <td>接口完全是抽象的。它根本不存在方法的实现</td> \n   </tr> \n   <tr> \n    <td>实现</td> \n    <td>子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td> \n    <td>子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现</td> \n   </tr> \n   <tr> \n    <td>构造器</td> \n    <td>抽象类可以有构造器</td> \n    <td>接口不能有构造器</td> \n   </tr> \n   <tr> \n    <td>与正常 Java 类的区别</td> \n    <td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td> \n    <td>接口是完全不同的类型</td> \n   </tr> \n   <tr> \n    <td>访问修饰符</td> \n    <td>抽象方法可以有 public、protected 和 default 这些修饰符</td> \n    <td>接口方法默认修饰符是 public。你不可以使用其它修饰符。</td> \n   </tr> \n   <tr> \n    <td>main 方法</td> \n    <td>抽象方法可以有 main 方法并且我们可以运行它</td> \n    <td>接口没有 main 方法，因此我们不能运行它。</td> \n   </tr> \n   <tr> \n    <td>多继承</td> \n    <td>抽象方法可以继承一个类和实现多个接口</td> \n    <td>接口只可以继承一个或多个其它接口</td> \n   </tr> \n   <tr> \n    <td>速度</td> \n    <td>它比接口速度要快</td> \n    <td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td> \n   </tr> \n   <tr> \n    <td>添加新方法</td> \n    <td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td> \n    <td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(184,12,'final, finally, finalize 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3>\n <p>用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</p> \n <h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h3>\n <p>是异常处理语句结构的一部分，表示总是执行.</p> \n <h3 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize\"></a>finalize</h3>\n <p>是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</p> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(185,12,'面向对象的特征',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>面向对象的三个基本特征是：封装、继承、多态。</p> \n <h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3>\n <p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。<br>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p> \n <h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3>\n <p>面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p> \n <h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3>\n <p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。<br>实现多态，有二种方式，覆盖，重载。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(186,12,'int 和 Integer 有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。<br>int 的默认值为 <code>0</code>，而 Integer 的默认值为 <code>null</code>，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况，<br>Java 中 int 和 Integer 关系是比较微妙的。关系如下：</p> \n <ul> \n  <li>int 是基本的数据类型；</li> \n  <li>Integer 是 int 的封装类；</li> \n  <li>int 和 Integer 都可以表示某一个数值；</li> \n  <li>int 和 Integer 不能够互用，因为他们两种不同的数据类型；</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(187,12,'重载和重写的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"重载-Overload\"><a href=\"#重载-Overload\" class=\"headerlink\" title=\"重载 Overload\"></a>重载 Overload</h3>\n <p>表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p> \n <h3 id=\"重写-Override\"><a href=\"#重写-Override\" class=\"headerlink\" title=\"重写 Override\"></a>重写 Override</h3>\n <p>表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(188,12,'说说反射的用途及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"反射的用途\"><a href=\"#反射的用途\" class=\"headerlink\" title=\"反射的用途\"></a>反射的用途</h3>\n <p>Java 反射机制是一个非常强大的功能，在很多的项目比如 Spring，MyBatis 都都可以看到反射的身影。通过反射机制，我们可以在运行期间获取对象的类型信息。利用这一点我们可以实现工厂模式和代理模式等设计模式，同时也可以解决 Java 泛型擦除等令人苦恼的问题。</p> \n <h3 id=\"反射的实现\"><a href=\"#反射的实现\" class=\"headerlink\" title=\"反射的实现\"></a>反射的实现</h3>\n <p>获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类</p> \n <ol> \n  <li>通过 <code>getClass()</code> 方法</li> \n  <li>通过 <code>Class.forName()</code> 方法</li> \n  <li>使用 <code>类.class</code></li> \n  <li>通过类加载器实现，<code>getClassLoader()</code></li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(189,12,'说说自定义注解的场景及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>登陆、权限拦截、日志处理，以及各种 Java 框架，如 Spring，Hibernate，JUnit 提到注解就不能不说反射，Java 自定义注解是通过运行时靠反射获取注解。实际开发中，例如我们要获取某个方法的调用日志，可以通过 AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。反射的实现在 Java 应用层面上讲，是通过对 Class 对象的操作实现的，Class 对象为我们提供了一系列方法对类进行操作。在 JVM 这个角度来说，Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目按严格的顺序紧凑的排列在 Class 文件中，里面包含了类、方法、字段等等相关数据。通过对 Class 数据流的处理我们即可得到字段、方法等数据。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(190,12,'HTTP 请求的 GET 与 POST 方式的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。</li> \n  <li>根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。</li> \n  <li>首先是 “GET 方式提交的数据最多只能是 1024 字节”，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</li> \n  <li>POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(191,12,'session 与 cookie 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li> \n  <li>cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li> \n  <li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li> \n  <li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(192,12,'JDBC 流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>向 DriverManager 类注册驱动数据库驱动程序</li> \n  <li>调用 DriverManager.getConnection 方法， 通过 JDBC URL，用户名，密码取得数据库连接的 Connection 对象。</li> \n  <li>获取 Connection 后， 便可以通过 createStatement 创建 Statement 用以执行 SQL 语句。</li> \n  <li>有时候会得到查询结果，比如 select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。</li> \n  <li>关闭数据库语句，关闭数据库连接。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(193,12,'session 分布式处理',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Session-复制\"><a href=\"#Session-复制\" class=\"headerlink\" title=\"Session 复制\"></a>Session 复制</h3>\n <p>在支持 Session 复制的 Web 服务器上，通过修改 Web 服务器的配置，可以实现将 Session 同步到其它 Web 服务器上，达到每个 Web 服务器上都保存一致的 Session。</p> \n <ul> \n  <li>优点：代码上不需要做支持和修改。</li> \n  <li>缺点：需要依赖支持的 Web 服务器，一旦更换成不支持的 Web 服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。</li> \n  <li>适用场景：只适用于Web服务器比较少且 Session 数据量少的情况。</li> \n  <li>可用方案：开源方案 tomcat-redis-session-manager，暂不支持 Tomcat8。</li> \n </ul> \n <h3 id=\"Session-粘滞\"><a href=\"#Session-粘滞\" class=\"headerlink\" title=\"Session 粘滞\"></a>Session 粘滞</h3>\n <p>将用户的每次请求都通过某种方法强制分发到某一个 Web 服务器上，只要这个 Web 服务器上存储了对应 Session 数据，就可以实现会话跟踪。</p> \n <ul> \n  <li>优点：使用简单，没有额外开销。</li> \n  <li>缺点：一旦某个 Web 服务器重启或宕机，相对应的 Session 数据将会丢失，而且需要依赖负载均衡机制。</li> \n  <li>适用场景：对稳定性要求不是很高的业务情景。</li> \n </ul> \n <h3 id=\"Session-集中管理\"><a href=\"#Session-集中管理\" class=\"headerlink\" title=\"Session 集中管理\"></a>Session 集中管理</h3>\n <p>在单独的服务器或服务器集群上使用缓存技术，如 Redis 存储 Session 数据，集中管理所有的 Session，所有的Web服务器都从这个存储介质中存取对应的 Session，实现 Session 共享。</p> \n <ul> \n  <li>优点：可靠性高，减少 Web 服务器的资源开销。</li> \n  <li>缺点：实现上有些复杂，配置较多。</li> \n  <li>适用场景：Web服务器较多、要求高可用性的情况。</li> \n  <li>可用方案：开源方案 Spring Session，也可以自己实现，主要是重写 HttpServletRequestWrapper 中的 getSession 方法。</li> \n </ul> \n <h3 id=\"基于-Cookie-管理\"><a href=\"#基于-Cookie-管理\" class=\"headerlink\" title=\"基于 Cookie 管理\"></a>基于 Cookie 管理</h3>\n <p>这种方式每次发起请求的时候都需要将 Session 数据放到 Cookie 中传递给服务端。</p> \n <ul> \n  <li>优点：不需要依赖额外外部存储，不需要额外配置。</li> \n  <li>缺点：不安全，易被盗取或篡改；Cookie 数量和长度有限制，需要消耗更多网络带宽。</li> \n  <li>适用场景：数据不重要、不敏感且数据量小的情况。</li> \n </ul> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>这四种方式，相对来说，<strong>Session 集中管理</strong> 更加可靠，使用也是最多的。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(194,12,'equals 与 == 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><code>==</code> 与<code>equals</code> 的主要区别是：<code>==</code> 常用于比较原生类型，而 <code>equals()</code> 方法用于检查对象的相等性。</li> \n  <li>另一个不同的点是：如果 <code>==</code> 和 <code>equals()</code> 用于比较对象，当两个引用地址相同，<code>==</code> 返回 true。而 <code>equals()</code> 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 <code>==</code> 和 <code>equals()</code> 返回不同的结果。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(195,12,'MVC 设计思想',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MVC 是三个单词的首字母缩写，它们是 Model（模型）、View（视图）和 Controller（控制）。<br>这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层：</p> \n <ul> \n  <li>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</li> \n  <li>最底下的一层，是核心的”数据层”（Model），也就是程序需要操作的数据或信息。</li> \n  <li>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:49','2018-12-20 22:05:49'),
(196,12,'ArrayList 与 Vector 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>同步性：Vector 是线程安全的，也就是说是同步的 ，而 ArrayList 是线程不安全的，不是同步的。</p> </li> \n  <li><p>数据增长：当需要增长时，Vector 默认增长为原来一倍 ，而 ArrayList 却是原来的 50% ，这样 ArrayList 就有利于节约内存空间。</p> </li> \n </ul> \n <p>说明：如果涉及到堆栈，队列等操作，应该考虑用 Vector，如果需要快速随机访问元素，应该使用 ArrayList</p> \n</div>',NULL,NULL,'2018-12-20 22:05:50','2018-12-20 22:05:50'),
(197,12,'HashMap 和 HashTable 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>HashMap 几乎可以等价于 HashTable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值 (key) 和值 (value)，而 HashTable 则不行)。</li> \n  <li>HashMap 是非 synchronized，而 HashTable 是 synchronized，这意味着 HashTable 是线程安全的，多个线程可以共享一个 HashTable；而如果没有正确的同步的话，多个线程是不能共享 HashMap 的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。</li> \n  <li>另一个区别是 HashMap 的迭代器 (Iterator) 是 fail-fast 迭代器，而 HashTable 的 enumerator 迭代器不是 fail-fast 的。所以当有其它线程改变了 HashMap 的结构（增加或者移除元素），将会抛出 ConcurrentModificationException，但迭代器本身的 remove() 方法移除元素则不会抛出 ConcurrentModificationException 异常。但这并不是一个一定发生的行为，要看 JVM。这条同样也是 Enumeration 和 Iterator 的区别。</li> \n  <li>由于 HashTable 是线程安全的也是 synchronized，所以在单线程环境下它比 HashMap 要慢。如果你不需要同步，只需要单一线程，那么使用 HashMap 性能要好过 HashTable。</li> \n  <li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:50','2018-12-20 22:05:50'),
(198,12,'ArrayList 与 LinkedList 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>因为 Array 是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array 获取数据的时间复杂度是 <code>O(1)</code>,但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p> </li> \n  <li><p>相对于 ArrayList，LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 <code>O(n)</code>，而 LinkedList 中插入或删除的时间复杂度仅为 <code>O(1)</code>。ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。</p> </li> \n  <li><p>类似于插入数据，删除数据时，LinkedList 也优于 ArrayList。</p> </li> \n  <li><p>LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置。</p> </li> \n  <li><p>你的应用不会随机访问数据。因为如果你需要 LinkedList 中的第 n 个元素的时候，你需要从第一个元素顺序数到第 n 个数据，然后读取数据。</p> </li> \n  <li><p>你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比 ArrayList 要快。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:50','2018-12-20 22:05:50'),
(199,12,'HashMap 的工作原理及代码实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>HashMap 基于 hashing 原理，我们通过 put() 和 get() 方法储存和获取对象。当我们将键值对传递给 put() 方法时，它调用键对象的 hashCode() 方法来计算 hashcode，让后找到 bucket 位置来储存值对象。当获取对象时，通过键对象的 equals() 方法找到正确的键值对，然后返回值对象。HashMap 使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap 在每个链表节点中储存键值对对象。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:50','2018-12-20 22:05:50'),
(200,12,'HashSet 和 HashMap 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>HashMap</th> \n    <th>HashSet</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>HashMap 实现了 Map 接口</td> \n    <td>HashSet 实现了 Set 接口</td> \n   </tr> \n   <tr> \n    <td>HashMap 储存键值对</td> \n    <td>HashSet 仅仅存储对象</td> \n   </tr> \n   <tr> \n    <td>使用 put() 方法将元素放入 map 中</td> \n    <td>使用 add() 方法将元素放入 set 中</td> \n   </tr> \n   <tr> \n    <td>HashMap 中使用键对象来计算 hashcode 值</td> \n    <td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals() 方法用来判断对象的相等性，如果两个对象不同的话，那么返回 false</td> \n   </tr> \n   <tr> \n    <td>HashMap 比较快，因为是使用唯一的键来获取对象</td> \n    <td>HashSet 较 HashMap 来说比较慢</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-20 22:05:50','2018-12-20 22:05:50'),
(201,12,'ConcurrentHashMap 的工作原理及代码实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>ConcurrentHashMap 采用了非常精妙的”分段锁”策略，ConcurrentHashMap 的主干是个 Segment 数组。Segment 继承了 ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在 ConcurrentHashMap，一个 Segment 就是一个子哈希表，Segment 里维护了一个 HashEntry 数组，并发环境下，对于不同 Segment 的数据进行操作是不用考虑锁竞争的。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(202,12,'创建线程的方式及实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>继承 Thread 类创建线程类</p> \n   <ul> \n    <li>定义 Thread 类的子类，并重写该类的 <code>run</code> 方法，该 <code>run</code> 方法的方法体就代表了线程要完成的任务。因此把 <code>run()</code> 方法称为执行体。</li> \n    <li>创建 Thread 子类的实例，即创建了线程对象。</li> \n    <li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li> \n   </ul> </li> \n  <li><p>通过 Runnable 接口创建线程类</p> \n   <ul> \n    <li>定义 Runnable 接口的实现类，并重写该接口的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体同样是该线程的线程执行体。</li> \n    <li>创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，该 Thread 对象才是真正的线程对象。</li> \n    <li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li> \n   </ul> </li> \n  <li><p>通过 Callable 和 Future 创建线程</p> \n   <ul> \n    <li>创建 Callable 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li> \n    <li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 <code>call()</code> 方法的返回值。</li> \n    <li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li> \n    <li>调用 FutureTask 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值</li> \n   </ul> </li> \n  <li><p>采用实现 Runnable、Callable 接口的方式创见多线程时：</p> \n   <ul> \n    <li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li> \n    <li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread() 方法。</li> \n   </ul> </li> \n  <li><p>使用继承 Thread 类的方式创建多线程时：</p> \n   <ul> \n    <li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li> \n    <li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(203,12,'HashMap 和 ConcurrentHashMap 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>放入 HashMap 的元素是 key-value 对。</li> \n  <li>底层说白了就是散列结构。</li> \n  <li>要将元素放入到 HashMap 中，那么 key 的类型必须要实现实现 hashcode 方法，默认这个方法是根据对象的地址来计算的，接着还必须覆盖对象的 equals() 方法。</li> \n  <li>ConcurrentHashMap 对整个桶数组进行了分段，而 HashMap 则没有</li> \n  <li>ConcurrentHashMap 在每一个分段上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好，而 HashMap 没有锁机制，不是线程安全的</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(204,12,'sleep() 、join（）、yield（）有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"sleep\"><a href=\"#sleep\" class=\"headerlink\" title=\"sleep()\"></a>sleep()</h3>\n <p><code>sleep()</code> 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是 <code>sleep()</code> 方法不会释放“锁标志”，也就是说如果有 <code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。</p> \n <h3 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h3>\n <p><code>wait()</code> 方法需要和 <code>notify()</code> 及 <code>notifyAll()</code> 两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在 <code>synchronized</code> 语句块内使用，也就是说，调用 <code>wait()</code>，<code>notify()</code> 和 <code>notifyAll()</code> 的任务在调用这些方法前必须拥有对象的锁。注意，它们都是 <code>Object</code> 类的方法，而不是 <code>Thread</code> 类的方法。</p> \n <p><code>wait()</code> 方法与 <code>sleep()</code> 方法的不同之处在于，<code>wait()</code> 方法会释放对象的“锁标志”。当调用某一对象的 <code>wait()</code> 方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了 <code>notify()</code> 方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的 <code>notifyAll()</code> 方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。</p> \n <p>除了使用 <code>notify()</code> 和 <code>notifyAll()</code> 方法，还可以使用带毫秒参数的 <code>wait(long timeout)</code> 方法，效果是在延迟 timeout 毫秒后，被暂停的线程将被恢复到锁标志等待池。</p> \n <p>此外，<code>wait()</code>，<code>notify()</code> 及 <code>notifyAll()</code> 只能在 <code>synchronized</code> 语句中使用，但是如果使用的是 <code>ReenTrantLock</code> 实现同步，该如何达到这三个方法的效果呢？解决方法是使用 <code>ReenTrantLock.newCondition()</code> 获取一个 <code>Condition</code> 类对象，然后 <code>Condition</code> 的 <code>await()</code>，<code>signal()</code> 以及 <code>signalAll()</code> 分别对应上面的三个方法。</p> \n <h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield()\"></a>yield()</h3>\n <p><code>yield()</code> 方法和 <code>sleep()</code> 方法类似，也不会释放“锁标志”，区别在于，它没有参数，即 <code>yield()</code> 方法只是使当前线程重新回到可执行状态，所以执行 <code>yield()</code> 的线程有可能在进入到可执行状态后马上又被执行，另外 <code>yield()</code> 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 <code>sleep()</code> 方法不同。</p> \n <h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3>\n <p><code>join()</code> 方法会使当前线程等待调用 <code>join()</code> 方法的线程结束后才能继续执行</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(205,12,'说说 CyclicBarrier 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p><code>CyclicBarrier</code> 是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(CommonBarrierPoint)。因为该 <code>barrier</code> 在释放等待线程后可以重用,所以称它为循环的 <code>barrier</code>。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(206,12,'说说 CountDownLatch 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CountDownLatch 内部维护了一个整数 <code>n</code>，n（要大于等于0）在 <strong>当前线程</strong> 初始化 <code>CountDownLatch</code> 方法指定。当前线程调用 <code>CountDownLatch</code> 的 <code>await()</code> 方法阻塞当前线程，等待其他调用 <code>CountDownLatch</code> 对象的 <code>CountDown()</code> 方法的线程执行完毕。 其他线程调用该 <code>CountDownLatch</code> 的 <code>CountDown()</code> 方法，该方法会把 <code>n-1</code>，直到所有线程执行完成，<code>n</code> 等于 <code>0</code>，<strong>当前线程</strong> 就恢复执行。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(207,12,'说说 CountDownLatch 与 CyclicBarrier 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>CountDownLatch 的作用是允许 <code>1</code> 或 <code>N</code> 个线程等待其他线程完成执行;而 CyclicBarrier 则是允许 <code>N</code> 个线程相互等待。</li> \n  <li>CountDownLatch 的计数器无法被重置; CyclicBarrier 的计数器可以被重置后使用,因此它被称为是循环的 barrier。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(208,12,'说说 Exchanger 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当一个线程到达 <code>exchange</code> 调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(209,12,'ThreadLocal 原理分析',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>ThreadLocal 提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal 相当于提供了一种线程隔离，将变量与线程相绑定。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(210,12,'讲讲线程池的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当提交一个新任务到线程池时，线程池的处理流程如下：</p> \n <ol> \n  <li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li> \n  <li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li> \n  <li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:51','2018-12-20 22:05:51'),
(211,12,'线程的生命周期',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>新建(New)、就绪(Runnable)、运行(Running)、阻塞(Blocked)和死亡(Dead)5种状态</p> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(212,12,'说说 Semaphore 原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p><code>Semaphore</code> 直译为信号。实际上 <code>Semaphore</code> 可以看做是一个信号的集合。不同的线程能够从 <code>Semaphore</code> 中获取若干个信号量。当 <code>Semaphore</code> 对象持有的信号量不足时，尝试从 <code>Semaphore</code> 中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(213,12,'说说线程安全问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。</p> \n <p>在 Java 多线程编程当中，提供了多种实现 Java 线程安全的方式：</p> \n <ul> \n  <li>最简单的方式，使用 <code>Synchronization</code> 关键字</li> \n  <li>使用 <code>java.util.concurrent.atomic</code> 包中的原子类，例如 <code>AtomicInteger</code></li> \n  <li>使用 <code>java.util.concurrent.locks</code> 包中的锁</li> \n  <li>使用线程安全的集合 <code>ConcurrentHashMap</code></li> \n  <li>使用 <code>volatile</code> 关键字，保证变量可见性（直接从内存读，而不是从线程 <code>cache</code> 读）</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(214,12,'线程池的几种方式与使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 <code>Executors</code> 类里面提供了一些静态工厂，生成一些常用的线程池。</p> \n <ol> \n  <li><code>newFixedThreadPool</code>：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li> \n  <li><code>newCachedThreadPool</code>：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li> \n  <li><code>newSingleThreadExecutor</code>：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li> \n  <li><code>newScheduledThreadPool</code>：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li> \n  <li><code>newSingleThreadScheduledExecutor</code>：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(215,12,'synchronize 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>同步代码块是使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令实现的，同步方法（在这看不出来需要看 JVM 底层实现）依靠的是方法修饰符上的 <code>ACC_SYNCHRONIZED</code> 实现。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(216,12,'CAS 乐观锁',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CAS 是项乐观锁技术，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p> \n <p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查 + 数据更新的原理是一样的。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(217,12,'volatile 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>在 JVM 底层 volatile 是采用“内存屏障”来实现的</li> \n  <li>缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个 CPU 在写数据时，如果发现操作的变量是共享变量，则会通知其他 CPU 告知该变量的缓存行是无效的，因此其他 CPU 在读取该变量时，发现其无效会重新从主存中加载数据</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(218,12,'ABA 问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>CAS 会导致“ABA问题”。</p> \n <p>CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</p> \n <p>比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。</p> \n <p>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:52','2018-12-20 22:05:52'),
(219,12,'synchronized 与 lock 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>synchronized 和 lock 的用法区别</p> \n   <ul> \n    <li>synchronized(隐式锁)：在需要同步的对象中加入此控制，<code>synchronized</code> 可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。</li> \n    <li>lock（显示锁）：需要显示指定起始位置和终止位置。一般使用 <code>ReentrantLock</code> 类做为锁，多个线程中必须要使用一个 <code>ReentrantLock</code> 类做为对象才能保证锁的生效。且在加锁和解锁处需要通过 <code>lock()</code> 和 <code>unlock()</code> 显示指出。所以一般会在 <code>finally</code> 块中写 <code>unlock()</code> 以防死锁。</li> \n   </ul> </li> \n  <li><p>synchronized 和 lock 性能区别<br><code>synchronized</code> 是托管给 JVM 执行的，而 <code>lock</code> 是 Java 写的控制锁的代码。在 <strong>JDK 1.5</strong> 中，<code>synchronize</code> 是性能低效的。因为这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用 Java 提供的 <code>Lock</code> 对象，性能更高一些。但是到了 <strong>JDK 1.6</strong>，发生了变化。<code>synchronize</code> 在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在 <strong>JDK 1.6</strong> 上 <code>synchronize</code> 的性能并不比 <code>Lock</code> 差。</p> </li> \n  <li><p>synchronized 和 lock 机制区别</p> \n   <ul> \n    <li><code>synchronized</code> 原始采用的是 CPU 悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。</li> \n    <li><code>Lock</code> 用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是 CAS 操作（Compare and Swap）。</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(220,12,'58 到家 MySQL 军规升级版',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"基础规范\"><a href=\"#基础规范\" class=\"headerlink\" title=\"基础规范\"></a>基础规范</h3>\n <ul> \n  <li>表存储引擎必须使用 <code>InnoDB</code></li> \n  <li>表字符集默认使用 <code>utf8</code>，必要时候使用 <code>utf8mb4</code>\n   <ul> \n    <li>通用，无乱码风险，汉字 3 字节，英文 1 字节</li> \n    <li><code>utf8mb4</code> 是 <code>utf8</code> 的超集，有存储 4 字节例如表情符号时，使用它</li> \n   </ul> </li> \n  <li>禁止使用存储过程，视图，触发器，Event\n   <ul> \n    <li>对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层</li> \n    <li>调试，排错，迁移都比较困难，扩展性较差</li> \n   </ul> </li> \n  <li>禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径</li> \n  <li>禁止在线上环境做数据库压力测试</li> \n  <li>测试，开发，线上数据库环境必须隔离</li> \n </ul> \n <h3 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h3>\n <ul> \n  <li>库名，表名，列名必须用小写，采用下划线分隔\n   <ul> \n    <li>abc，Abc，ABC 都是给自己埋坑</li> \n   </ul> </li> \n  <li>库名，表名，列名必须见名知义，长度不要超过 32 字符\n   <ul> \n    <li>tmp，wushan 谁 TM 知道这些库是干嘛的</li> \n   </ul> </li> \n  <li>库备份必须以 bak 为前缀，以日期为后缀</li> \n  <li>从库必须以 <code>-s</code> 为后缀</li> \n  <li>备库必须以 <code>-ss</code> 为后缀</li> \n </ul> \n <h3 id=\"表设计规范\"><a href=\"#表设计规范\" class=\"headerlink\" title=\"表设计规范\"></a>表设计规范</h3>\n <ul> \n  <li>单实例表个数必须控制在 <code>2000</code> 个以内</li> \n  <li>单表分表个数必须控制在 <code>1024</code> 个以内</li> \n  <li>表必须有主键，推荐使用 <code>UNSIGNED</code> 整数为主键\n   <ul> \n    <li>删除无主键的表，如果是 <code>row</code> 模式的主从架构，从库会挂住</li> \n   </ul> </li> \n  <li>禁止使用外键，如果要保证完整性，应由应用程式实现\n   <ul> \n    <li>外键使得表之间相互耦合，影响 <code>update/delete</code> 等 SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈</li> \n   </ul> </li> \n  <li>建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据（具体参考：<a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959773&amp;idx=1&amp;sn=7e4ad0dcd050f6662dfaf39d9de36f2c&amp;chksm=bd2d04018a5a8d17b92098b4840aac23982e32d179cdd957e4c55011f6a08f6bd31f9ba5cfee&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《如何实施数据库垂直拆分》</a>）</li> \n </ul> \n <h3 id=\"列设计规范\"><a href=\"#列设计规范\" class=\"headerlink\" title=\"列设计规范\"></a>列设计规范</h3>\n <ul> \n  <li>根据业务区分使用 <code>tinyint/int/bigint</code>，分别会占用 <code>1/4/8</code> 字节</li> \n  <li>根据业务区分使用 <code>char/varchar</code>\n   <ul> \n    <li>字段长度固定，或者长度近似的业务场景，适合使用 <code>char</code>，能够减少碎片，查询性能高</li> \n    <li>字段长度相差较大，或者更新较少的业务场景，适合使用 <code>varchar</code>，能够减少空间</li> \n   </ul> </li> \n  <li>根据业务区分使用 <code>datetime/timestamp</code>\n   <ul> \n    <li>前者占用 5 个字节，后者占用 4 个字节，存储年使用 <code>YEAR</code>，存储日期使用 <code>DATE</code>，存储时间使用 <code>datetime</code></li> \n   </ul> </li> \n  <li>必须把字段定义为 <code>NOT NULL</code> 并设默认值\n   <ul> \n    <li>NULL 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化</li> \n    <li>NULL 需要更多的存储空间</li> \n    <li>NULL 只能采用 <code>IS NULL</code> 或者 <code>IS NOT NULL</code> ，而在 <code>=/!=/in/not in</code> 时有大坑</li> \n   </ul> </li> \n  <li>使用 <code>INT UNSIGNED</code> 存储 <code>IPv4</code> ，不要用 <code>char(15)</code></li> \n  <li>使用 <code>varchar(20)</code> 存储手机号，不要使用整数\n   <ul> \n    <li>牵扯到国家代号，可能出现 <code>+/-/()</code> 等字符，例如 <code>+86</code></li> \n    <li>手机号不会用来做数学运算</li> \n    <li><code>varchar</code> 可以模糊查询，例如 <code>like‘138%’</code></li> \n   </ul> </li> \n  <li>使用 <code>TINYINT</code> 来代替 <code>ENUM</code>\n   <ul> \n    <li><code>ENUM</code> 增加新值要进行 <code>DDL</code> 操作</li> \n   </ul> </li> \n </ul> \n <h3 id=\"索引规范\"><a href=\"#索引规范\" class=\"headerlink\" title=\"索引规范\"></a>索引规范</h3>\n <ul> \n  <li>唯一索引使用 <code>uniq_[字段名]</code> 来命名</li> \n  <li>非唯一索引使用 <code>idx_[字段名]</code> 来命名</li> \n  <li>单张表索引数量建议控制在 5 个以内\n   <ul> \n    <li>互联网高并发业务，太多索引会影响写性能</li> \n    <li>生成执行计划时，如果索引太多，会降低性能，并可能导致 MySQL 选择不到最优索引</li> \n    <li>异常复杂的查询需求，可以选择 <code>ES</code> 等更为适合的方式存储</li> \n   </ul> </li> \n  <li>组合索引字段数不建议超过 5 个\n   <ul> \n    <li>如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题</li> \n   </ul> </li> \n  <li>不建议在频繁更新的字段上建立索引</li> \n  <li>非必要不要进行 <code>JOIN</code> 查询，如果要进行 <code>JOIN</code> 查询，被 <code>JOIN</code> 的字段必须类型相同，并建立索引\n   <ul> \n    <li>踩过因为 <code>JOIN</code> 字段类型不一致，而导致全表扫描的坑么？</li> \n   </ul> </li> \n  <li>理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)</li> \n </ul> \n <h3 id=\"SQL-规范\"><a href=\"#SQL-规范\" class=\"headerlink\" title=\"SQL 规范\"></a>SQL 规范</h3>\n <ul> \n  <li>禁止使用 <code>select *</code>，只获取必要字段\n   <ul> \n    <li><code>select *</code> 会增加 <code>cpu/io/内存/带宽</code> 的消耗</li> \n    <li>指定字段能有效利用索引覆盖</li> \n    <li>指定字段查询，在表结构变更时，能保证对应用程序无影响</li> \n   </ul> </li> \n  <li><code>insert</code> 必须指定字段，禁止使用 <code>insert into T values()</code>\n   <ul> \n    <li>指定字段插入，在表结构变更时，能保证对应用程序无影响</li> \n   </ul> </li> \n  <li>隐式类型转换会使索引失效，导致全表扫描</li> \n  <li>禁止在 <code>where</code> 条件列使用函数或者表达式\n   <ul> \n    <li>导致不能命中索引，全表扫描</li> \n   </ul> </li> \n  <li>禁止负向查询以及 <code>%</code> 开头的模糊查询\n   <ul> \n    <li>导致不能命中索引，全表扫描</li> \n   </ul> </li> \n  <li>禁止大表 <code>JOIN</code> 和子查询</li> \n  <li>同一个字段上的 <code>OR</code> 必须改写问 <code>IN</code>，<code>IN</code> 的值必须少于 50 个</li> \n  <li>应用程序必须捕获 SQL 异常\n   <ul> \n    <li>方便定位线上问题</li> \n   </ul> </li> \n </ul> \n <h3 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h3>\n <p>本军规适用于并发量大，数据量大的典型互联网业务，可直接带走参考，不谢。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(221,12,'乐观锁的业务场景及实现方式',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>乐观锁（Optimistic Lock）：</p> \n <ul> \n  <li>每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</li> \n  <li>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(222,12,'List 和 Set 区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>List, Set 都是继承自 Collection 接口</li> \n  <li>List 特点：元素有放入顺序，元素可重复。Set 特点：元素无放入顺序，元素不可重复（注意：元素虽然无放入顺序，但是元素在 set 中的位置是有该元素的 HashCode 决定的，其位置其实是固定的）</li> \n  <li>List 接口有三个实现类：LinkedList，ArrayList，Vector。Set 接口有两个实现类：HashSet(底层由 HashMap 实现)，LinkedHashSet</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(223,12,'说说反模式设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(224,12,'说说分库与分表设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a>垂直分表</h3>\n <p>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。</p> \n <h3 id=\"垂直分库\"><a href=\"#垂直分库\" class=\"headerlink\" title=\"垂直分库\"></a>垂直分库</h3>\n <p>垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。</p> \n <p>众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。</p> \n <h3 id=\"水平分表\"><a href=\"#水平分表\" class=\"headerlink\" title=\"水平分表\"></a>水平分表</h3>\n <p>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。</p> \n <h3 id=\"水平分库\"><a href=\"#水平分库\" class=\"headerlink\" title=\"水平分库\"></a>水平分库</h3>\n <p>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。</p> \n <h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3>\n <p>很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(225,12,'MySQL 索引使用的注意事项',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>索引不会包含有 <code>NULL</code> 的列<br>只要列中包含有 <code>NULL</code> 值，都将不会被包含在索引中，复合索引中只要有一列含有 <code>NULL</code> 值，那么这一列对于此符合索引就是无效的。</p> </li> \n  <li><p>使用短索引<br>对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个 <code>char（255）</code> 的列，如果在前 <code>10</code> 个或 <code>20</code> 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 <code>I/O</code> 操作。</p> </li> \n  <li><p>索引列排序<br>MySql 查询只使用一个索引，因此如果 <code>where</code> 子句中已经使用了索引的话，那么 <code>order by</code> 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。</p> </li> \n  <li><p><code>like</code> 语句操作<br>一般情况下不鼓励使用 <code>like</code> 操作，如果非使用不可，注意正确的使用方式。<code>like ‘%aaa%’</code> 不会使用索引，而 <code>like ‘aaa%’</code> 可以使用索引。</p> </li> \n  <li><p>不要在列上进行运算</p> </li> \n  <li><p>不使用 <code>NOT IN</code> 、<code>&lt;&gt;</code>、<code>！=</code>操作，但 <code>&lt;</code> , <code>&lt;=</code> ，<code>=</code> ，<code>&gt;</code> , <code>&gt;=</code> , <code>BETWEEN</code> , <code>IN</code> 是可以用到索引的</p> </li> \n  <li><p>索引要建立在经常进行select操作的字段上<br>这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p> </li> \n  <li><p>索引要建立在值比较唯一的字段上</p> </li> \n  <li><p>对于那些定义为 <code>text</code>、<code>image</code> 和 <code>bit</code> 数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少</p> </li> \n  <li><p>在 <code>where</code> 和 <code>join</code> 中出现的列需要建立索引</p> </li> \n  <li><p><code>where</code> 的查询条件里有不等号 <code>(where column != …)</code> , MySql 将无法使用索引</p> </li> \n  <li><p>如果 <code>where</code> 字句的查询条件里使用了函数(如：<code>where DAY(column)=…)</code>, MySql 将无法使用索引</p> </li> \n  <li><p>在 <code>join</code> 操作中(需要从多个数据表提取数据时)，MySql 只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(226,12,'说说 SQL 优化之道',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"一些常见的-SQL-实践\"><a href=\"#一些常见的-SQL-实践\" class=\"headerlink\" title=\"一些常见的 SQL 实践\"></a>一些常见的 SQL 实践</h3>\n <ul> \n  <li>负向条件查询不能使用索引</li> \n </ul> \n <pre><code>select from order where status!=0 and status!=1\n</code></pre>\n <pre><code>not in/not exists # 都不是好习惯\n</code></pre>\n <p>可以优化为 <code>in</code> 查询：</p> \n <pre><code>select from order where status in(2,3)\n</code></pre>\n <ul> \n  <li>前导模糊查询不能使用索引<pre><code>select from order where desc like \'%XX\'\n</code></pre></li> \n </ul> \n <p>而非前导模糊查询则可以：</p> \n <pre><code>select from order where desc like \'XX%\'\n</code></pre>\n <ul> \n  <li>数据区分度不大的字段不宜使用索引<pre><code>select from user where sex=1\n</code></pre></li> \n </ul> \n <p>原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。</p> \n <p>经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。</p> \n <ul> \n  <li>在属性上进行计算不能命中索引<pre><code>select from order where YEAR(date) &lt; = \'2017\'\n</code></pre></li> \n </ul> \n <p>即使date上建立了索引，也会全表扫描，可优化为值计算：</p> \n <pre><code>select from order where date &lt; = CURDATE()\n</code></pre>\n <p>或者：</p> \n <pre><code>select from order where date &lt; = \'2017-01-01\'\n</code></pre>\n <h3 id=\"并非周知的-SQL-实践\"><a href=\"#并非周知的-SQL-实践\" class=\"headerlink\" title=\"并非周知的 SQL 实践\"></a>并非周知的 SQL 实践</h3>\n <ul> \n  <li>如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心<pre><code>select from user where uid=?\nselect from user where login_name=?\n</code></pre></li> \n </ul> \n <p>原因：<code>B-Tree</code> 索引的时间复杂度是 <code>O(log(n))</code>；<code>Hash</code> 索引的时间复杂度是 <code>O(1)</code></p> \n <ul> \n  <li>允许为 <code>null</code> 的列，查询有潜在大坑</li> \n </ul> \n <p>单列索引不存 <code>null</code> 值，复合索引不存全为 <code>null</code> 的值，如果列允许为 <code>null</code>，可能会得到“不符合预期”的结果集</p> \n <pre><code>select from user where name != \'shenjian\'\n</code></pre>\n <p>如果 <code>name</code> 允许为 <code>null</code>，索引不存储 <code>null</code> 值，结果集中不会包含这些记录。所以，请使用 <code>not null</code> 约束以及默认值。</p> \n <ul> \n  <li>复合索引最左前缀，并不是值 SQL 语句的 <code>where</code> 顺序要和复合索引一致</li> \n </ul> \n <p>用户中心建立了(login_name, passwd)的复合索引</p> \n <pre><code>select from user where login_name=? and passwd=?\nselect from user where passwd=? and login_name=?\n</code></pre>\n <p>都能够命中索引</p> \n <pre><code>select from user where login_name=?\n</code></pre>\n <p>也能命中索引，满足复合索引最左前缀</p> \n <pre><code>select from user where passwd=?\n</code></pre>\n <p>不能命中索引，不满足复合索引最左前缀</p> \n <ul> \n  <li>使用 <code>ENUM</code> 而不是字符串</li> \n </ul> \n <p><code>ENUM</code> 保存的是 <code>TINYINT</code>，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。</p> \n <h3 id=\"小众但有用的-SQL-实践\"><a href=\"#小众但有用的-SQL-实践\" class=\"headerlink\" title=\"小众但有用的 SQL 实践\"></a>小众但有用的 SQL 实践</h3>\n <ul> \n  <li>如果明确知道只有一条结果返回，<code>limit 1</code> 能够提高效率</li> \n </ul> \n <pre><code>select from user where login_name=?\n</code></pre>\n <p>可以优化为：</p> \n <pre><code>select from user where login_name=? limit 1\n</code></pre>\n <p>原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动</p> \n <ul> \n  <li>把计算放到业务层而不是数据库层，除了节省数据的 CPU，还有意想不到的查询缓存优化效果</li> \n </ul> \n <pre><code>select from order where date &lt; = CURDATE()\n</code></pre>\n <p>这不是一个好的SQL实践，应该优化为：</p> \n <pre><code>$curDate = date(\'Y-m-d\');\n$res = mysqlquery(\'select from order where date &lt; = $curDate\');\n</code></pre>\n <p>原因：释放了数据库的 CPU，多次调用，传入的SQL相同，才可以利用查询缓存</p> \n <ul> \n  <li>强制类型转换会全表扫描</li> \n </ul> \n <pre><code>select from user where phone=13800001234\n</code></pre>\n <p>你以为会命中 phone 索引么？大错特错了，这个语句究竟要怎么改？</p> \n <p>末了，再加一条，不要使用 <code>select *（潜台词，文章的 SQL 都不合格 ==）</code>，只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:53','2018-12-20 22:05:53'),
(227,12,'MySQL 遇到的死锁问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>产生死锁的四个必要条件：</p> \n <ul> \n  <li>互斥条件：一个资源每次只能被一个进程使用。</li> \n  <li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li> \n  <li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li> \n  <li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li> \n </ul> \n <p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。<br>下列方法有助于最大限度地降低死锁：</p> \n <ul> \n  <li>按同一顺序访问对象。</li> \n  <li>避免事务中的用户交互。</li> \n  <li>保持事务简短并在一个批处理中。</li> \n  <li>使用低隔离级别。</li> \n  <li>使用绑定连接。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(228,12,'存储引擎的 InnoDB 与 MyiSAM',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>InnoDB 不支持 <code>FULLTEXT</code> 类型的索引。</li> \n  <li>InnoDB 中不保存表的具体行数，也就是说，执行 <code>select count() from table</code> 时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 <code>count()</code> 语句包含 <code>where</code> 条件时，两种表的操作是一样的。</li> \n  <li>对于 <code>AUTO_INCREMENT</code> 类型的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中，可以和其他字段一起建立联合索引。</li> \n  <li><code>DELETE FROM table</code> 时，InnoDB 不会重新建立表，而是一行一行的删除。</li> \n  <li><code>LOAD TABLE FROM MASTER</code> 操作对 InnoDB 是不起作用的，解决方法是首先把 InnoDB 表改成 MyISAM 表，导入数据后再改成 InnoDB 表，但是对于使用的额外的 InnoDB 特性(例如外键)的表不适用。</li> \n </ol> \n <p>另外，InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表，例如 <code>update table set num=1 where name like “%aaa%”</code></p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(229,12,'数据库索引的原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 <strong>BTree</strong> 及其变种 <strong>B+Tree</strong>。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(230,12,'为什么要用 B-Tree',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(231,12,'聚集索引与非聚集索引的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</li> \n  <li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li> \n  <li>聚集索引：物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序</li> \n  <li>非聚集索引：物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.</li> \n  <li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(232,12,'分库与分表带来的分布式困境与应对之策',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"数据迁移与扩容问题\"><a href=\"#数据迁移与扩容问题\" class=\"headerlink\" title=\"数据迁移与扩容问题\"></a>数据迁移与扩容问题</h3>\n <p>前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。</p> \n <p>针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。</p> \n <h3 id=\"表关联问题\"><a href=\"#表关联问题\" class=\"headerlink\" title=\"表关联问题\"></a>表关联问题</h3>\n <p>在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。</p> \n <h3 id=\"分页与排序问题\"><a href=\"#分页与排序问题\" class=\"headerlink\" title=\"分页与排序问题\"></a>分页与排序问题</h3>\n <p>一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。</p> \n <h3 id=\"分布式事务问题\"><a href=\"#分布式事务问题\" class=\"headerlink\" title=\"分布式事务问题\"></a>分布式事务问题</h3>\n <p>随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。</p> \n <h3 id=\"分布式全局唯一ID\"><a href=\"#分布式全局唯一ID\" class=\"headerlink\" title=\"分布式全局唯一ID\"></a>分布式全局唯一ID</h3>\n <p>在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(233,12,'选择合适的分布式主键方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>数据库自增长序列或字段</li> \n  <li>UUID</li> \n  <li><strong>使用 UUID to Int64 的方法</strong></li> \n  <li><strong>Redis 生成 ID</strong></li> \n  <li><strong>Twitter 的 snowflake 算法</strong></li> \n  <li><strong>利用 zookeeper 生成唯一 ID</strong></li> \n  <li>MongoDB 的 ObjectId</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(234,12,'选择合适的数据存储方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"关系型数据库-MySQL\"><a href=\"#关系型数据库-MySQL\" class=\"headerlink\" title=\"关系型数据库 MySQL\"></a>关系型数据库 MySQL</h3>\n <p>MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。</p> \n <h3 id=\"内存数据库-Redis\"><a href=\"#内存数据库-Redis\" class=\"headerlink\" title=\"内存数据库 Redis\"></a>内存数据库 Redis</h3>\n <p>随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。</p> \n <p>在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。</p> \n <p>使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。</p> \n <h3 id=\"文档数据库-MongoDB\"><a href=\"#文档数据库-MongoDB\" class=\"headerlink\" title=\"文档数据库 MongoDB\"></a>文档数据库 MongoDB</h3>\n <p>MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</p> \n <p>此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p> \n <p>MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。</p> \n <h3 id=\"列族数据库-HBase\"><a href=\"#列族数据库-HBase\" class=\"headerlink\" title=\"列族数据库 HBase\"></a>列族数据库 HBase</h3>\n <p>HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。</p> \n <h3 id=\"全文搜索引擎-ElasticSearch\"><a href=\"#全文搜索引擎-ElasticSearch\" class=\"headerlink\" title=\"全文搜索引擎 ElasticSearch\"></a>全文搜索引擎 ElasticSearch</h3>\n <p>在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。</p> \n <p>ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。<strong>著名的 ELK 日志处理方案，由 ElasticSearch、LogStash 和 KibAna 三个组件组成</strong>，包括了日志收集、聚合、多维度查询、可视化显示等。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(235,12,'聊聊 MongoDB 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"高伸缩性的场景\"><a href=\"#高伸缩性的场景\" class=\"headerlink\" title=\"高伸缩性的场景\"></a>高伸缩性的场景</h3>\n <p>MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。</p> \n <h3 id=\"日志系统的场景\"><a href=\"#日志系统的场景\" class=\"headerlink\" title=\"日志系统的场景\"></a>日志系统的场景</h3>\n <p>日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。</p> \n <h3 id=\"分布式文件存储\"><a href=\"#分布式文件存储\" class=\"headerlink\" title=\"分布式文件存储\"></a>分布式文件存储</h3>\n <p>MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:54','2018-12-20 22:05:54'),
(236,12,'limit 20000 加载很慢怎么解决',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MySQL 的性能低是因为数据库要去扫描 <code>N + M</code> 条记录，然后又要放弃之前 <code>N</code> 条记录，开销很大</p> \n <p>解决思路：</p> \n <ul> \n  <li>前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用 es 等进行搜索</li> \n  <li>使用延迟关联，即先通用 limit 得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据</li> \n </ul> \n <pre><code>select a.* from a,(select id from table_1 where is_deleted=\'N\' limit 100000,20) b where a.id = b.id\n</code></pre>\n <ul> \n  <li>从业务上实现，不分页如此多，例如只能分页前 100 页，后面的不允许再查了</li> \n  <li>不使用 limit N,M, 而是使用 limit N，即将 offset 转化为 where 条件。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(237,12,'倒排索引',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。</p> \n <p>有两种不同的反向索引形式：</p> \n <ul> \n  <li><p>一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。</p> </li> \n  <li><p>一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(238,12,'Redis 内部结构',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p> \n <ul> \n  <li>type ：代表一个 value 对象具体是何种数据类型。</li> \n  <li>encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如：”123” “456”这样的字符串。</li> \n  <li>vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(239,12,'聊聊 ElasticSearch 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。</p> </li> \n  <li><p>数据库，挺奇葩的用法，因为 ES 存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式 P2P 扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。</p> </li> \n  <li><p>在线统计分析引擎，日志系统，LogStash，不用解释了吧; 可以实时动态分析数据，很是爽。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(240,12,'聊聊 Redis 使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>缓存</li> \n  <li>会话缓存</li> \n  <li>时效性</li> \n  <li>访问频率</li> \n  <li>计数器</li> \n  <li>社交列表</li> \n  <li>记录用户判定信息</li> \n  <li>交集、并集和差集</li> \n  <li>热门列表与排行榜</li> \n  <li>最新动态</li> \n  <li>消息队列</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(241,12,'ObjectId 规则',1,NULL,1,'<div class=\"col-sm-12\"> \n <table> \n  <thead> \n   <tr> \n    <th>时间戳</th> \n    <th>机器码</th> \n    <th>PID</th> \n    <th>计数器</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>0,1,2,3</td> \n    <td>4,5,6</td> \n    <td>7,8</td> \n    <td>9,10,11</td> \n   </tr> \n  </tbody> \n </table> \n <ul> \n  <li>前四位是时间戳，可以提供秒级别的唯一性。</li> \n  <li>接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。</li> \n  <li>接下来两位是产生 ObjectId 的 PID，确保同一台机器上并发产生的 ObjectId 是唯一的。</li> \n  <li>前九位保证了同一秒钟不同机器的不同进程产生的 ObjectId 时唯一的。</li> \n  <li>最后三位是自增计数器，确保相同进程同一秒钟产生的 ObjectId 是唯一的。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(242,12,'Redis 有哪些类型',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 Redis 中有五种数据类型</p> \n <ul> \n  <li>String：字符串</li> \n  <li>Hash：字典</li> \n  <li>List：列表</li> \n  <li>Set：集合</li> \n  <li>Sorted Set：有序集合</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:55','2018-12-20 22:05:55'),
(243,12,'Redis 持久化机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 有两种持久化机制：</p> \n <h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3>\n <p>RDB 持久化方式会在一个特定的间隔保存那个时间点的一个数据快照</p> \n <h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3>\n <p>AOF 持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟 Redis 协议一致，以追加的方式进行保存</p> \n <p>Redis 的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。两种方式的持久化是可以同时存在的，但是当 Redis 重启时，AOF 文件会被优先用于重建数据。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(244,12,'Redis 为什么是单线程的',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>因为 CPU 不是 Redis 的瓶颈。Redis 的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方 FAQ）既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(245,12,'Redis 集群方案与实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>客户端分片</li> \n  <li>基于代理的分片</li> \n  <li>路由查询</li> \n  <li>客户端分片</li> \n  <li>由客户端决定 key 写入或者读取的节点</li> \n  <li>包括 Jedis 在内的一些客户端，实现了客户端分片机制</li> \n </ul> \n <h3 id=\"路由查询\"><a href=\"#路由查询\" class=\"headerlink\" title=\"路由查询\"></a>路由查询</h3>\n <p>将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p> \n <h3 id=\"开源方案\"><a href=\"#开源方案\" class=\"headerlink\" title=\"开源方案\"></a>开源方案</h3>\n <p>Sentinel</p> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(246,12,'缓存崩溃',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。</p> </li> \n  <li><p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间 key 是锁着的，这时过来 1000 个请求 999 个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(247,12,'缓存降级',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"页面降级\"><a href=\"#页面降级\" class=\"headerlink\" title=\"页面降级\"></a>页面降级</h3>\n <p>在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；</p> \n <h3 id=\"页面片段降级\"><a href=\"#页面片段降级\" class=\"headerlink\" title=\"页面片段降级\"></a>页面片段降级</h3>\n <p>比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；</p> \n <h3 id=\"页面异步请求降级\"><a href=\"#页面异步请求降级\" class=\"headerlink\" title=\"页面异步请求降级\"></a>页面异步请求降级</h3>\n <p>比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</p> \n <h3 id=\"服务功能降级\"><a href=\"#服务功能降级\" class=\"headerlink\" title=\"服务功能降级\"></a>服务功能降级</h3>\n <p>比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；</p> \n <h3 id=\"读降级\"><a href=\"#读降级\" class=\"headerlink\" title=\"读降级\"></a>读降级</h3>\n <p>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；</p> \n <h3 id=\"写降级\"><a href=\"#写降级\" class=\"headerlink\" title=\"写降级\"></a>写降级</h3>\n <p>比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</p> \n <h3 id=\"爬虫降级\"><a href=\"#爬虫降级\" class=\"headerlink\" title=\"爬虫降级\"></a>爬虫降级</h3>\n <p>在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。</p> \n <h3 id=\"自动开关降级\"><a href=\"#自动开关降级\" class=\"headerlink\" title=\"自动开关降级\"></a>自动开关降级</h3>\n <p>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。</p> \n <h3 id=\"超时降级\"><a href=\"#超时降级\" class=\"headerlink\" title=\"超时降级\"></a>超时降级</h3>\n <p>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(248,12,'使用缓存的合理性问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>热点数据，缓存才有价值</li> \n  <li>频繁修改的数据，看情况考虑使用缓存</li> \n  <li>数据不一致性</li> \n  <li>缓存更新机制</li> \n  <li>缓存可用性</li> \n  <li>缓存服务降级</li> \n  <li>缓存预热</li> \n  <li>缓存穿透</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(249,12,'消息队列的使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>校验用户名等信息，如果没问题会在数据库中添加一个用户记录</li> \n  <li>如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</li> \n  <li>分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</li> \n  <li>发送给用户一个包含操作指南的系统通知</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:56','2018-12-20 22:05:56'),
(250,12,'消息的重发补偿解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>可靠消息服务定时查询状态为已发送并超时的消息</li> \n  <li>可靠消息将消息重新投递到 MQ 组件中</li> \n  <li>下游应用监听消息，在满足幂等性的条件下，重新执行业务。</li> \n  <li>下游应用通知可靠消息服务该消息已经成功消费。</li> \n  <li>通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(251,12,'自己如何实现消息队列',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>大体上的设计是由一条线程 1 执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.</p> \n <p>添加一条线程 1 主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,</p> \n <p>当任务队列长度达到最大值时,线程 1 将被阻塞,等待线程 2,3… 从任务队列取出任务执行。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(252,12,'消息的幂等性解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"查询操作\"><a href=\"#查询操作\" class=\"headerlink\" title=\"查询操作\"></a>查询操作</h3>\n <p>查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作</p> \n <h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3>\n <p>删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)</p> \n <h3 id=\"唯一索引，防止新增脏数据\"><a href=\"#唯一索引，防止新增脏数据\" class=\"headerlink\" title=\"唯一索引，防止新增脏数据\"></a>唯一索引，防止新增脏数据</h3>\n <p>比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录</p> \n <h3 id=\"Token-机制\"><a href=\"#Token-机制\" class=\"headerlink\" title=\"Token 机制\"></a>Token 机制</h3>\n <p>防止页面重复提交</p> \n <h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3>\n <p>获取数据的时候加锁获取</p> \n <pre><code>select * from table_xxx where id=\'xxx\' for update;\n</code></pre>\n <p>注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的</p> \n <p>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用</p> \n <h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3>\n <p>乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。</p> \n <h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3>\n <p>还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多个系统，也就是分布式系统中得解决思路。</p> \n <h3 id=\"select-insert\"><a href=\"#select-insert\" class=\"headerlink\" title=\"select + insert\"></a>select + insert</h3>\n <p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了</p> \n <p>注意：核心高并发流程不要用这种方法</p> \n <h3 id=\"状态机幂等\"><a href=\"#状态机幂等\" class=\"headerlink\" title=\"状态机幂等\"></a>状态机幂等</h3>\n <p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p> \n <h3 id=\"对外提供接口的-API-如何保证幂等\"><a href=\"#对外提供接口的-API-如何保证幂等\" class=\"headerlink\" title=\"对外提供接口的 API 如何保证幂等\"></a>对外提供接口的 API 如何保证幂等</h3>\n <p>如银联提供的付款接口：需要接入商户提交付款请求时附带：<code>source</code> 来源，<code>seq</code> 序列号<br><code>source + seq</code> 在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(253,12,'消息的堆积解决思路',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>如果还没开始投入使用 Kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。</p> \n <h3 id=\"增大批次\"><a href=\"#增大批次\" class=\"headerlink\" title=\"增大批次\"></a>增大批次</h3>\n <p>瓶颈在消费吞吐量的时候，增加批次也可以改善性能</p> \n <h3 id=\"增加线程数\"><a href=\"#增加线程数\" class=\"headerlink\" title=\"增加线程数\"></a>增加线程数</h3>\n <p>如果一些消费者组中的消费者线程还是有 1 个消费者线程消费多个分区的情况，建议增加消费者线程。尽量 1 个消费者线程对应 1 个分区，从而发挥现有分区数下的最大并行度。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(254,12,'BeanFactory 和 ApplicationContext 有什么区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。</p> </li> \n  <li><p>BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。</p> </li> \n  <li><p>从表面上看，ApplicationContext 如同 BeanFactory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 ApplicationContext 在此基础上还提供了其他的功能：</p> \n   <ul> \n    <li>提供了支持国际化的文本消息</li> \n    <li>统一的资源文件读取方式</li> \n    <li>已在监听器中注册的 bean 的事件</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(255,12,'Spring IOC 如何实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring 中的 <code>org.springframework.beans</code> 包和 <code>org.springframework.context</code> 包构成了 Spring 框架 IoC 容器的基础。</li> \n  <li>BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContext 接口对 BeanFactory（是一个子接口）进行了扩展，在 BeanFactory 的基础上添加了其他功能，比如与 Spring 的 AOP 更容易集成，也提供了处理 message resource 的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对 Web 应用的 WebApplicationContext。</li> \n  <li><code>org.springframework.beans.factory.BeanFactory</code> 是 Spring IoC 容器的具体实现，用来包装和管理前面提到的各种 bean。BeanFactory 接口是 Spring IoC 容器的核心接口。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(256,12,'说说 Spring AOP',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>面向切面编程，在我们的应用中，经常需要做一些事情，但是这些事情与核心业务无关，比如，要记录所有 update 方法的执行时间时间，操作人等等信息，记录到日志，<br>通过 Spring 的 AOP 技术，就可以在不修改 update 的代码的情况下完成该需求。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(257,12,'Spring Bean 的生命周期',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。</li> \n  <li>Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n   <ul> \n    <li>初始化之后调用的回调方法。</li> \n    <li>销毁之前调用的回调方法。</li> \n   </ul> </li> \n  <li>Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：\n   <ul> \n    <li>InitializingBean 和 DisposableBean 回调接口</li> \n    <li>针对特殊行为的其他 Aware 接口</li> \n    <li>Bean 配置文件中的 Custom init() 方法和 destroy() 方法</li> \n    <li>@PostConstruct 和 @PreDestroy 注解方式</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(258,12,'Spring 事务实现方式',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"编码方式\"><a href=\"#编码方式\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h3>\n <p>所谓编程式事务指的是通过编码方式实现事务，即类似于 JDBC 编程实现事务管理。</p> \n <h3 id=\"声明式事务管理方式\"><a href=\"#声明式事务管理方式\" class=\"headerlink\" title=\"声明式事务管理方式\"></a>声明式事务管理方式</h3>\n <p>声明式事务管理又有两种实现方式：</p> \n <ul> \n  <li>基于 xml 配置文件的方式；</li> \n  <li>另一个实在业务方法上进行 <code>@Transaction</code> 注解，将事务规则应用到业务逻辑中；</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(259,12,'Spring AOP 实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Spring AOP 中的动态代理主要有两种方式，<strong>JDK 动态代理</strong> 和 <strong>CGLIB 动态代理</strong>。JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK 动态代理的核心是 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类。</p> \n <p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:57','2018-12-20 22:05:57'),
(260,12,'动态代理（CGLIB 与 JDK）',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>JDK 动态代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用 Java 动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。而 CGLIB 则可以实现对类的动态代理。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(261,12,'如何自定义注解实现功能',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>创建自定义注解和创建一个接口相似，但是注解的 <code>interface</code> 关键字需要以 <code>@</code> 符号开头。</li> \n  <li>注解方法不能带有参数；</li> \n  <li>注解方法返回值类型限定为：基本类型、String、Enums、Annotation 或者是这些类型的数组；</li> \n  <li>注解方法可以有默认值；</li> \n  <li>注解本身能够包含元注解，元注解被用来注解其它注解。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(262,12,'Spring MVC 启动流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 <code>web.xml</code> 文件中给 Spring MVC 的 Servlet 配置了 <code>load-on-startup</code>，所以程序启动的时候会初始化 Spring MVC，在 <code>HttpServletBean</code> 中将配置的 <code>contextConfigLocation</code> 属性设置到 Servlet 中，然后在 <code>FrameworkServlet</code> 中创建了 <code>WebApplicationContext</code>，<code>DispatcherServlet</code> 根据 <code>contextConfigLocation</code> 配置的 <code>classpath</code> 下的 xml 文件初始化了 Spring MVC 总的组件。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(263,12,'Spring 事务底层原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"划分处理单元-IOC\"><a href=\"#划分处理单元-IOC\" class=\"headerlink\" title=\"划分处理单元 IOC\"></a>划分处理单元 IOC</h3>\n <p>由于 Spring 解决的问题是对单个数据库进行局部事务处理的，具体的实现首相用 Spring 中的 IOC 划分了事务处理单元。并且将对事务的各种配置放到了 IOC 容器中（设置事务管理器，设置事务的传播特性及隔离机制）。</p> \n <h3 id=\"AOP-拦截需要进行事务处理的类\"><a href=\"#AOP-拦截需要进行事务处理的类\" class=\"headerlink\" title=\"AOP 拦截需要进行事务处理的类\"></a>AOP 拦截需要进行事务处理的类</h3>\n <p>Spring 事务处理模块是通过 AOP 功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用 <code>TransactionProxyFactoryBean</code> 接口来使用 AOP 功能，生成 proxy 代理对象，通过 <code>TransactionInterceptor</code> 完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。读取 IOC 容器事务配置属性，转化为 Spring 事务处理需要的内部数据结构（<code>TransactionAttributeSourceAdvisor</code>），转化为 <code>TransactionAttribute</code> 表示的数据对象。</p> \n <h3 id=\"对事物处理实现（事务的生成、提交、回滚、挂起）\"><a href=\"#对事物处理实现（事务的生成、提交、回滚、挂起）\" class=\"headerlink\" title=\"对事物处理实现（事务的生成、提交、回滚、挂起）\"></a>对事物处理实现（事务的生成、提交、回滚、挂起）</h3>\n <p>Spring 委托给具体的事务处理器实现。实现了一个抽象和适配。适配的具体事务处理器：DataSource 数据源支持、Hibernate 数据源事务处理支持、JDO 数据源事务处理支持，JPA、JTA 数据源事务处理支持。这些支持都是通过设计 <code>PlatformTransactionManager</code>、<code>AbstractPlatforTransaction</code> 一系列事务处理的支持。 为常用数据源支持提供了一系列的 <code>TransactionManager</code>。</p> \n <h3 id=\"结合\"><a href=\"#结合\" class=\"headerlink\" title=\"结合\"></a>结合</h3>\n <p><code>PlatformTransactionManager</code> 实现了 <code>TransactionInterception</code> 接口，让其与 <code>TransactionProxyFactoryBean</code> 结合起来，形成一个 Spring 声明式事务处理的设计体系。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(264,12,'Spring MVC 运行流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>Spring MVC 将所有的请求都提交给 <code>DispatcherServlet</code>，它会委托应用系统的其他模块负责对请求进行真正的处理工作。</li> \n  <li><code>DispatcherServlet</code> 查询一个或多个 <code>HandlerMapping</code>，找到处理请求的 Controller.</li> \n  <li><code>DispatcherServlet</code> 请求提交到目标 Controller</li> \n  <li>Controller 进行业务逻辑处理后，会返回一个 <code>ModelAndView</code></li> \n  <li>Dispatcher 查询一个或多个 <code>ViewResolver</code> 视图解析器,找到 <code>ModelAndView</code> 对象指定的视图对象</li> \n  <li>视图对象负责渲染返回给客户端。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(265,12,'如何保证消息的有序性',1,NULL,1,'<div class=\"col-sm-12\"> \n <ol> \n  <li>通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，</li> \n  <li>在获取到路由信息以后，会根据算法来选择一个队列，同一个 OrderId 获取到的肯定是同一个队列。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(266,12,'Spring 的单例实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Spring 对 Bean 实例的创建是采用单例注册表的方式进行实现的，而这个注册表的缓存是 ConcurrentHashMap 对象。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(267,12,'原生的 NIO 在 JDK 1.7 版本存在 EPoll BUG',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 BUG 发生概率降低了一些而已，它并没有得到根本性解决。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58');
insert  into `content`(`id`,`type_id`,`title`,`author_id`,`pic`,`status`,`content`,`title_desc`,`reads`,`created`,`updated`) values 
(268,12,'Redis 内存淘汰机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Redis 内存淘汰指的是用户存储的一些键被可以被 Redis 主动地从实例中删除，从而产生读 miss 的情况，那么 Redis 为什么要有这种功能？这就是我们需要探究的设计初衷。Redis 最常见的两种应用场景为缓存和持久存储，首先要明确的一个问题是内存淘汰策略更适合于那种场景？是持久存储还是缓存？</p> \n <p>假设我们有一个 Redis 服务器，服务器物理内存大小为 1G 的，我们需要存在 Redis 中的数据量很小，这看起来似乎足够用很长时间了，随着业务量的增长，我们放在 Redis 里面的数据越来越多了，数据量大小似乎超过了 1G，但是应用还可以正常运行，这是因为操作系统的可见内存并不受物理内存限制，而是虚拟内存，物理内存不够用没关系，操作系统会从硬盘上划出一片空间用于构建虚拟内存，比如32位的操作系统的可见内存大小为 <code>2^32</code>，而用户空间的可见内存要小于 <code>2^32</code> 很多，大概是 3G 左右。好了，我们庆幸操作系统为我们做了这些，但是我们需要知道这背后的代价是不菲的，不合理的使用内存有可能发生频繁的 swap，频繁 swap 的代价是惨痛的。所以回过头来看，作为有追求的程序员，我们还是要小心翼翼地使用好每块内存，把用户代码能解决的问题尽量不要抛给操作系统解决。</p> \n <p><strong>内存的淘汰机制的初衷是为了更好地使用内存，用一定的缓存 miss 来换取内存的使用效率。</strong></p> \n <h3 id=\"如何用\"><a href=\"#如何用\" class=\"headerlink\" title=\"如何用\"></a>如何用</h3>\n <p>作为 Redis 用户，我们如何使用 Redis 提供的这个特性呢？</p> \n <pre><code># maxmemory &lt;bytes&gt;\n</code></pre>\n <p>我们可以通过配置 <code>redis.conf</code> 中的 <code>maxmemory</code> 这个值来开启内存淘汰功能，至于这个值有什么意义，我们可以通过了解内存淘汰的过程来理解它的意义：</p> \n <ul> \n  <li>客户端发起了需要申请更多内存的命令（如set）</li> \n  <li>Redis 检查内存使用情况，如果已使用的内存大于 <code>maxmemory</code> 则开始根据用户配置的不同淘汰策略来淘汰内存（key），从而换取一定的内存</li> \n  <li>如果上面都没问题，则这个命令执行成功</li> \n </ul> \n <p><code>maxmemory</code> 为 0 的时候表示我们对 Redis 的内存使用没有限制</p> \n <h3 id=\"内存淘汰策略\"><a href=\"#内存淘汰策略\" class=\"headerlink\" title=\"内存淘汰策略\"></a>内存淘汰策略</h3>\n <p>内存淘汰只是 Redis 提供的一个功能，为了更好地实现这个功能，必须为不同的应用场景提供不同的策略，内存淘汰策略讲的是为实现内存淘汰我们具体怎么做，要解决的问题包括淘汰键空间如何选择？在键空间中淘汰键如何选择？</p> \n <p>Redis 提供了下面几种淘汰策略供用户选择，其中默认的策略为 <code>noeviction</code> 策略：</p> \n <ul> \n  <li>noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错</li> \n  <li>allkeys-lru：在主键空间中，优先移除最近未使用的key</li> \n  <li>volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的 key</li> \n  <li>allkeys-random：在主键空间中，随机移除某个 key</li> \n  <li>volatile-random：在设置了过期时间的键空间中，随机移除某个 key</li> \n  <li>volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除</li> \n </ul> \n <p>这里补充一下主键空间和设置了过期时间的键空间，举个例子，假设我们有一批键存储在Redis中，则有那么一个哈希表用于存储这批键及其值，如果这批键中有一部分设置了过期时间，那么这批键还会被存储到另外一个哈希表中，这个哈希表中的值对应的是键被设置的过期时间。设置了过期时间的键空间为主键空间的子集。</p> \n <h3 id=\"如何选择淘汰策略\"><a href=\"#如何选择淘汰策略\" class=\"headerlink\" title=\"如何选择淘汰策略\"></a>如何选择淘汰策略</h3>\n <p>我们了解了 Redis 大概提供了这么几种淘汰策略，那么如何选择呢？淘汰策略的选择可以通过下面的配置指定：</p> \n <pre><code># maxmemory-policy noeviction\n</code></pre>\n <p>但是这个值填什么呢？为解决这个问题，我们需要了解我们的应用请求对于 Redis 中存储的数据集的访问方式以及我们的诉求是什么。同时 Redis 也支持 Runtime 修改淘汰策略，这使得我们不需要重启 Redis 实例而实时的调整内存淘汰策略。</p> \n <p>下面看看几种策略的适用场景：</p> \n <ul> \n  <li>allkeys-lru：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略</li> \n  <li>allkeys-random：如果我们的应用对于缓存 key 的访问概率相等，则可以使用这个策略</li> \n  <li>volatile-ttl：这种策略使得我们可以向 Redis 提示哪些 key 更适合被 eviction</li> \n </ul> \n <p>另外，<code>volatile-lru</code> 策略和 <code>volatile-random</code> 策略适合我们将一个Redis实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果，值得一提的是将key设置过期时间实际上会消耗更多的内存，因此我们建议使用 <code>allkeys-lru</code> 策略从而更有效率的使用内存。</p> \n <h3 id=\"非精准的-LRU\"><a href=\"#非精准的-LRU\" class=\"headerlink\" title=\"非精准的 LRU\"></a>非精准的 LRU</h3>\n <p>上面提到的 LRU（Least Recently Used）策略，实际上 Redis 实现的 LRU 并不是可靠的 LRU，也就是名义上我们使用 LRU 算法淘汰键，但是实际上被淘汰的键并不一定是真正的最久没用的，这里涉及到一个权衡的问题，如果需要在全部键空间内搜索最优解，则必然会增加系统的开销，Redis 是单线程的，也就是同一个实例在每一个时刻只能服务于一个客户端，所以耗时的操作一定要谨慎。为了在一定成本内实现相对的 LRU，早期的 Redis 版本是基于采样的 LRU，也就是放弃全部键空间内搜索解改为采样空间搜索最优解。自从 Redis3.0 版本之后，Redis 作者对于基于采样的 LRU 进行了一些优化，目的是在一定的成本内让结果更靠近真实的 LRU。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:58','2018-12-20 22:05:58'),
(269,12,'说说业务中 Netty 的使用场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li><p>构建高性能、低时延的各种 Java 中间件，例如 MQ、分布式服务框架、ESB 消息总线等，Netty 主要作为基础通信框架提供高性能、低时延的通信服务；</p> </li> \n  <li><p>公有或者私有协议栈的基础通信框架，例如可以基于 Netty 构建异步、高性能的 WebSocket 协议栈；</p> </li> \n  <li><p>各领域应用，例如大数据、游戏等，Netty 作为高性能的通信框架用于内部各模块的数据分发、传输和汇总等，实现模块之间高性能通信。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(270,12,'为什么选择 Netty',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>API 使用简单，开发门槛低；</li> \n  <li>功能强大，预置了多种编解码功能，支持多种主流协议；</li> \n  <li>定制能力强，可以通过 ChannelHandler 对通信框架进行灵活的扩展；</li> \n  <li>性能高，通过与其它业界主流的 NIO 框架对比，Netty 的综合性能最优；</li> \n  <li>成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼；</li> \n  <li>社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；</li> \n  <li>经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。</li> \n </ul> \n <p>正是因为这些优点，Netty 逐渐成为 Java NIO 编程的首选框架。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(271,12,'什么是 TCP 粘包/拆包',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li> \n  <li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li> \n  <li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li> \n  <li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(272,12,'Netty 线程模型',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先，Netty 使用 EventLoop 来处理连接上的读写事件，而一个连接上的所有请求都保证在一个 EventLoop 中被处理，一个 EventLoop 中只有一个 Thread，所以也就实现了一个连接上的所有事件只会在一个线程中被执行。一个 EventLoopGroup 包含多个 EventLoop，可以把一个 EventLoop 当做是 Reactor 线程模型中的一个线程，而一个 EventLoopGroup 类似于一个 ExecutorService</p> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(273,12,'Netty 内部执行流程',1,NULL,1,'<div class=\"col-sm-12\"> \n <h2 id=\"Netty-内部执行流程\"><a href=\"#Netty-内部执行流程\" class=\"headerlink\" title=\"Netty 内部执行流程\"></a>Netty 内部执行流程</h2>\n <ul> \n  <li>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li> \n  <li>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的 Buffer。</li> \n  <li>Netty 的文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(274,12,'说说 Netty 的零拷贝',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>“零拷贝”是指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(275,12,'Spring 框架中用到了哪些设计模式',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>代理模式：在 AOP 和 Remoting 中被用的比较多。</li> \n  <li>单例模式：在 Spring 配置文件中定义的 Bean 默认为单例模式。</li> \n  <li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li> \n  <li>前端控制器：Spring 提供了 DispatcherServlet 来对请求进行分发。</li> \n  <li>视图帮助(View Helper )：Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li> \n  <li>依赖注入：贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li> \n  <li>工厂模式：BeanFactory 用来创建对象的实例。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(276,12,'前后端分离是如何做的',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的 API 服务即可。前后端之间通过 HTTP 请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器。</p> \n</div>',NULL,NULL,'2018-12-20 22:05:59','2018-12-20 22:05:59'),
(277,12,'如何解决跨域',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是跨域问题？\"><a href=\"#什么是跨域问题？\" class=\"headerlink\" title=\"什么是跨域问题？\"></a>什么是跨域问题？</h3>\n <p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。</p> \n <h3 id=\"什么是同源？\"><a href=\"#什么是同源？\" class=\"headerlink\" title=\"什么是同源？\"></a>什么是同源？</h3>\n <p>所谓同源是指，域名，协议，端口均相同</p> \n <ul> \n  <li><code>http://www.funtl.com --&gt; http://admin.funtl.com 跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; http://www.funtl.com 非跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; http://www.funtl.com:8080 跨域</code></li> \n  <li><code>http://www.funtl.com --&gt; https://www.funtl.com 跨域</code></li> \n </ul> \n <h3 id=\"使用-CORS（跨资源共享）解决跨域问题\"><a href=\"#使用-CORS（跨资源共享）解决跨域问题\" class=\"headerlink\" title=\"使用 CORS（跨资源共享）解决跨域问题\"></a>使用 CORS（跨资源共享）解决跨域问题</h3>\n <p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</p> \n <p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10</p> \n <p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉</p> \n <p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信</p> \n <h3 id=\"CORS-与-JSONP-的比较\"><a href=\"#CORS-与-JSONP-的比较\" class=\"headerlink\" title=\"CORS 与 JSONP 的比较\"></a>CORS 与 JSONP 的比较</h3>\n <p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。</p> \n <p>JSONP 只支持 GET 请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(278,12,'你怎么理解 RPC 框架',1,'www.funtl.com/assets/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是-RPC？\"><a href=\"#什么是-RPC？\" class=\"headerlink\" title=\"什么是 RPC？\"></a>什么是 RPC？</h3>\n <p>RPC 是指远程过程调用，也就是说两台服务器 A，B 一个应用部署在 A 服务器上，想要调用 B 服务器上应用提供的函数或方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p> \n <h3 id=\"RPC-是如何通讯的？\"><a href=\"#RPC-是如何通讯的？\" class=\"headerlink\" title=\"RPC 是如何通讯的？\"></a>RPC 是如何通讯的？</h3>\n <p><img src=\"/assets/45366c44f775abfd0ac3b43bccc1abc3_hd.jpg\" alt=\"\"></p> \n <ol> \n  <li>要解决通讯的问题，主要是通过在客户端和服务器之间建立 TCP 连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li> \n  <li>要解决寻址的问题，也就是说，A 服务器上的应用怎么告诉底层的 RPC 框架，如何连接到 B 服务器（如主机或 IP 地址）以及特定的端口，方法的名称是什么，这样才能完成调用。比如基于 Web 服务协议栈的 RPC，就要提供一个 endpoint URI，或者是从 UDDI 服务上查找。如果是 RMI 调用的话，还需要一个 RMI Registry 来注册服务的地址。</li> \n  <li>当 A 服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如 TCP 传递到 B 服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给 B 服务器。</li> \n  <li>B 服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li> \n  <li>返回值还要发送回服务器 A 上的应用，也要经过序列化的方式发送，服务器 A 接到后，再反序列化，恢复为内存中的表达方式，交给 A 服务器上的应用。</li> \n </ol> \n <h3 id=\"为什么要用-RPC？\"><a href=\"#为什么要用-RPC？\" class=\"headerlink\" title=\"为什么要用 RPC？\"></a>为什么要用 RPC？</h3>\n <p>就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用，</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(279,12,'说说 RPC 的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(280,12,'TCP 粘包/拆包的解决办法',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</li> \n  <li>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li> \n  <li>可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(281,12,'Netty 重连实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <ul> \n  <li>心跳机制检测连接存活</li> \n  <li>启动时连接重试</li> \n  <li>运行中连接断开时重试</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(282,12,'你怎么理解 RESTful',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>2000 年，Roy Thomas Fielding 博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了几种软件应用的架构风格，REST 作为其中的一种架构风格在这篇论文的第5章中进行了概括性的介绍。</p> \n <p>REST 是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”，但是在绝大多数场合中我们只说 REST 或者 RESTful。Fielding 在论文中将 REST 定位为“分布式超媒体应用（Distributed Hypermedia System）”的架构风格，它在文中提到一个名为“HATEOAS（Hypermedia as the engine of application state）”的概念。</p> \n <p>我们利用一个面向最终用户的 Web 应用来对这个概念进行简单阐述：这里所谓的应用状态（Application State）表示 Web 应用的客户端的状态，简单起见可以理解为会话状态。资源在浏览器中以超媒体的形式呈现，通过点击超媒体中的链接可以获取其它相关的资源或者对当前资源进行相应的处理，获取的资源或者针对资源处理的响应同样以超媒体的形式再次呈现在浏览器上。由此可见，超媒体成为了驱动客户端会话状态的转换的引擎。</p> \n <p>借助于超媒体这种特殊的资源呈现方式，应用状态的转换体现为浏览器中呈现资源的转换。如果将超媒体进一步抽象成一般意义上的资源呈现（Representation ）方式，那么应用状态变成了可被呈现的状态（REpresentational State）。应用状态之间的转换就成了可被呈现的状态装换（REpresentational State Transfer），这就是 REST。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>REST 是一种很笼统的概念，它代表一种架构风格。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(283,12,'如何保证接口的幂等性',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>当通过调用创建实例接口在负载均衡中创建云服务器时，如果遇到了请求超时或服务器内部错误时，客户端可能会尝试重发请求，这时客户端可以通过提供可选参数 ClientToken 避免服务器创建出比预期要多的实例，也就是通过提供 ClientToken 参数保证请求的幂等性。ClientToken 是一个由客户端生成的唯一的、大小写敏感、不超过 64 个 ASCII 字符的字符串。</p> \n <p>如果用户使用同一个 ClientToken 值调用创建实例接口，则服务端会返回相同的请求结果，包含相同的 InstanceId。因此用户在遇到错误进行重试的时候，可以通过提供相同的 ClientToken 值，来确保负载均衡只创建一个实例，并得到这个实例的 InstanceId。</p> \n <p>如果用户提供了一个已经使用过的 ClientToken，但其他请求参数不同，则负载均衡会返回 IdempotentParameterMismatch 的错误代码。但需要注意的是，SignatureNonce、Timestamp 和 Signature 参数在重试时是需要变化的，因为负载均衡使用 SignatureNonce 来防止重放攻击，使用 Timestamp 来标记每次请求时间，所以再次请求必须提供不同的 SignatureNonce 和 Timestamp 参数值，这同时也会导致 Signature 值的变化。</p> \n <p>通常，客户端只需要在 500（InternetError）或 503（ServiceUnavailable）错误、或者无法得到响应结果的情况下进行重试操作。返回结果是 200 时，重试可以得到上次相同的结果，但不会对服务端状态带来任何影响。而对 4xx 的返回错误，通常重试也是不能成功的。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(284,12,'如何理解 RESTful API 的幂等性',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是幂等性\"><a href=\"#什么是幂等性\" class=\"headerlink\" title=\"什么是幂等性\"></a>什么是幂等性</h3>\n <p>HTTP 幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。</p> \n <pre><code>GET     /tickets       # 获取ticket列表\nGET     /tickets/12    # 查看某个具体的ticket\nPOST    /tickets       # 新建一个ticket\nPUT     /tickets/12    # 更新ticket 12\nPATCH   /tickets/12    # 更新ticket 12\nDELETE  /tickets/12    # 删除ticekt 12\n</code></pre>\n <h4 id=\"HTTP-GET-方法\"><a href=\"#HTTP-GET-方法\" class=\"headerlink\" title=\"HTTP GET 方法\"></a>HTTP GET 方法</h4>\n <p>HTTP GET 方法，用于获取资源，不管调用多少次接口，结果都不会改变，所以是幂等的。</p> \n <pre><code>GET     /tickets       # 获取ticket列表\nGET     /tickets/12    # 查看某个具体的ticket\n</code></pre>\n <p>只是查询数据，不会影响到资源的变化，因此我们认为它幂等。</p> \n <p>值得注意，幂等性指的是作用于结果而非资源本身。怎么理解呢？例如，这个 HTTP GET 方法可能会每次得到不同的返回内容，但并不影响资源。</p> \n <p>可能你会问有这种情况么？当然有咯。例如，我们有一个接口获取当前时间，我们就应该设计成</p> \n <pre><code>GET     /service_time # 获取服务器当前时间\n</code></pre>\n <p>它本身不会对资源本身产生影响，因此满足幂等性。</p> \n <h4 id=\"HTTP-POST-方法\"><a href=\"#HTTP-POST-方法\" class=\"headerlink\" title=\"HTTP POST 方法\"></a>HTTP POST 方法</h4>\n <p>HTTP POST 方法是一个非幂等方法，因为调用多次，都将产生新的资源。</p> \n <pre><code>POST    /tickets       # 新建一个ticket\n</code></pre>\n <p>因为它会对资源本身产生影响，每次调用都会有新的资源产生，因此不满足幂等性。</p> \n <h4 id=\"HTTP-PUT-方法\"><a href=\"#HTTP-PUT-方法\" class=\"headerlink\" title=\"HTTP PUT 方法\"></a>HTTP PUT 方法</h4>\n <p>HTTP PUT 方法是不是幂等的呢？我们来看下</p> \n <pre><code>PUT     /tickets/12    # 更新ticket 12\n</code></pre>\n <p>因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足幂等性。</p> \n <h4 id=\"HTTP-PATCH-方法\"><a href=\"#HTTP-PATCH-方法\" class=\"headerlink\" title=\"HTTP PATCH 方法\"></a>HTTP PATCH 方法</h4>\n <p>HTTP PATCH 方法是非幂等的。HTTP POST 方法和 HTTP PUT 方法可能比较好理解，但是 HTTP PATCH 方法只是更新部分资源，怎么是非幂等的呢?</p> \n <p>因为，PATCH 提供的实体则需要根据程序或其它协议的定义，解析后在服务器上执行，以此来修改服务器上的资源。换句话说，PATCH 请求是会执行某个程序的，如果重复提交，程序可能执行多次，对服务器上的资源就可能造成额外的影响，这就可以解释它为什么是非幂等的了。</p> \n <p>可能你还不能理解这点。我们举个例子</p> \n <pre><code>PATCH   /tickets/12    # 更新ticket 12\n</code></pre>\n <p>此时，我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条 ticket 记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是非幂等的操作。</p> \n <h4 id=\"HTTP-DELETE-方法\"><a href=\"#HTTP-DELETE-方法\" class=\"headerlink\" title=\"HTTP DELETE 方法\"></a>HTTP DELETE 方法</h4>\n <p>HTTP DELETE 方法用于删除资源，会将资源删除。</p> \n <pre><code>DELETE  /tickets/12    # 删除ticekt 12\n</code></pre>\n <p>调用一次和多次对资源产生影响是相同的，所以也满足幂等性。</p> \n <h3 id=\"如何设计符合幂等性的高质量-RESTful-API\"><a href=\"#如何设计符合幂等性的高质量-RESTful-API\" class=\"headerlink\" title=\"如何设计符合幂等性的高质量 RESTful API\"></a>如何设计符合幂等性的高质量 RESTful API</h3>\n <h4 id=\"HTTP-GET-vs-HTTP-POST\"><a href=\"#HTTP-GET-vs-HTTP-POST\" class=\"headerlink\" title=\"HTTP GET vs HTTP POST\"></a>HTTP GET vs HTTP POST</h4>\n <p>也许，你会想起一个面试题。<strong>HTTP 请求的 GET 与 POST 方式有什么区别？</strong> 你可能会回答到：GET 方式通过 URL 提交数据，数据在 URL 中可以看到；POST 方式，数据放置在 HTML HEADER 内提交。但是，我们现在从 RESTful 的资源角度来看待问题，HTTP GET 方法是幂等的，所以它适合作为查询操作，HTTP POST 方法是非幂等的，所以用来表示新增操作。</p> \n <p>但是，也有例外，我们有的时候可能需要把查询方法改造成 HTTP POST 方法。比如，超长（1k）的 GET URL 使用 POST 方法来替代，因为 GET 受到 URL 长度的限制。虽然，它不符合幂等性，但是它是一种折中的方案。</p> \n <h4 id=\"HTTP-POST-vs-HTTP-PUT\"><a href=\"#HTTP-POST-vs-HTTP-PUT\" class=\"headerlink\" title=\"HTTP POST vs HTTP PUT\"></a>HTTP POST vs HTTP PUT</h4>\n <p>对于 HTTP POST 方法和 HTTP PUT 方法，我们一般的理解是 POST 表示创建资源，PUT 表示更新资源。当然，这个是正确的理解。</p> \n <p>但是，实际上，两个方法都用于创建资源，更为本质的差别是在幂等性。HTTP POST 方法是非幂等，所以用来表示创建资源，HTTP PUT 方法是幂等的，因此表示更新资源更加贴切。</p> \n <h4 id=\"HTTP-PUT-vs-HTTP-PATCH\"><a href=\"#HTTP-PUT-vs-HTTP-PATCH\" class=\"headerlink\" title=\"HTTP PUT vs HTTP PATCH\"></a>HTTP PUT vs HTTP PATCH</h4>\n <p>此时，你看会有另外一个问题。HTTP PUT 方法和 HTTP PATCH 方法，都是用来表述更新资源，它们之间有什么区别呢？我们一般的理解是 PUT 表示更新全部资源，PATCH 表示更新部分资源。首先，这个是我们遵守的第一准则。根据上面的描述，PATCH 方法是非幂等的，因此我们在设计我们服务端的 RESTful API 的时候，也需要考虑。如果，我们想要明确的告诉调用者我们的资源是幂等的，我的设计更倾向于使用 HTTP PUT 方法。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:00','2018-12-20 22:06:00'),
(285,12,'说说 CAP 定理、 BASE 理论',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"CAP-定理\"><a href=\"#CAP-定理\" class=\"headerlink\" title=\"CAP 定理\"></a>CAP 定理</h3>\n <p>2000 年 7 月，加州大学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜想。2年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后，CAP 理论正式成为分布式计算领域的公认定理。</p> \n <p>CAP 理论为：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p> \n <h4 id=\"一致性（Consistency）\"><a href=\"#一致性（Consistency）\" class=\"headerlink\" title=\"一致性（Consistency）\"></a>一致性（Consistency）</h4>\n <p>一致性指 “all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p> \n <h4 id=\"可用性（Availability）\"><a href=\"#可用性（Availability）\" class=\"headerlink\" title=\"可用性（Availability）\"></a>可用性（Availability）</h4>\n <p>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p> \n <h4 id=\"分区容错性（Partition-tolerance）\"><a href=\"#分区容错性（Partition-tolerance）\" class=\"headerlink\" title=\"分区容错性（Partition tolerance）\"></a>分区容错性（Partition tolerance）</h4>\n <p>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p> \n <h3 id=\"CAP-权衡\"><a href=\"#CAP-权衡\" class=\"headerlink\" title=\"CAP 权衡\"></a>CAP 权衡</h3>\n <p>通过 CAP 理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p> \n <p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到 N 个 9，即保证 P 和 A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p> \n <p>对于涉及到钱财这样不能有一丝让步的场景，C 必须保证。网络发生故障宁可停止服务，这是保证 CA，舍弃 P。貌似这几年国内银行业发生了不下 10 起事故，但影响面不大，报到也不多，广大群众知道的少。还有一种是保证 CP，舍弃 A。例如网络故障是只读不写。</p> \n <p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p> \n <h3 id=\"BASE-理论\"><a href=\"#BASE-理论\" class=\"headerlink\" title=\"BASE 理论\"></a>BASE 理论</h3>\n <p>eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p> \n <h4 id=\"基本可用（Basically-Available）\"><a href=\"#基本可用（Basically-Available）\" class=\"headerlink\" title=\"基本可用（Basically Available）\"></a>基本可用（Basically Available）</h4>\n <p>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</p> \n <p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p> \n <h4 id=\"软状态（Soft-State）\"><a href=\"#软状态（Soft-State）\" class=\"headerlink\" title=\"软状态（Soft State）\"></a>软状态（Soft State）</h4>\n <p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication 的异步复制也是一种体现。</p> \n <h4 id=\"最终一致性（Eventual-Consistency）\"><a href=\"#最终一致性（Eventual-Consistency）\" class=\"headerlink\" title=\"最终一致性（Eventual Consistency）\"></a>最终一致性（Eventual Consistency）</h4>\n <p>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p> \n <h3 id=\"ACID-和-BASE-的区别与联系\"><a href=\"#ACID-和-BASE-的区别与联系\" class=\"headerlink\" title=\"ACID 和 BASE 的区别与联系\"></a>ACID 和 BASE 的区别与联系</h3>\n <p>ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p> \n <p>ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(286,12,'说说 Dubbo 的实现原理',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Dubbo 作为 RPC 框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到呢？</p> \n <ol> \n  <li>本地有对远程方法的描述，包括方法名、参数、返回值，在 Dubbo 中是远程和本地使用同样的接口</li> \n  <li>要有对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格式）传递到服务端</li> \n  <li>服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调用；</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(287,12,'说说如何设计一个良好的 API',1,NULL,1,'<div class=\"col-sm-12\"> \n <h2 id=\"版本号\"><a href=\"#版本号\" class=\"headerlink\" title=\"版本号\"></a>版本号</h2>\n <p>在 RESTful API 中，API 接口应该尽量兼容之前的版本。但是，在实际业务开发场景中，可能随着业务需求的不断迭代，现有的 API 接口无法支持旧版本的适配，此时如果强制升级服务端的 API 接口将导致客户端旧有功能出现故障。实际上，Web 端是部署在服务器，因此它可以很容易为了适配服务端的新的 API 接口进行版本升级，然而像 Android 端、IOS 端、PC 端等其他客户端是运行在用户的机器上，因此当前产品很难做到适配新的服务端的 API 接口，从而出现功能故障，这种情况下，用户必须升级产品到最新的版本才能正常使用。</p> \n <p>为了解决这个版本不兼容问题，在设计 RESTful API 的一种实用的做法是使用版本号。一般情况下，我们会在 url 中保留版本号，并同时兼容多个版本。</p> \n <pre><code>【GET】  /v1/users/{user_id}  // 版本 v1 的查询用户列表的 API 接口\n【GET】  /v2/users/{user_id}  // 版本 v2 的查询用户列表的 API 接口\n</code></pre>\n <p>现在，我们可以不改变版本 v1 的查询用户列表的 API 接口的情况下，新增版本 v2 的查询用户列表的 API 接口以满足新的业务需求，此时，客户端的产品的新功能将请求新的服务端的 API 接口地址。虽然服务端会同时兼容多个版本，但是同时维护太多版本对于服务端而言是个不小的负担，因为服务端要维护多套代码。这种情况下，常见的做法不是维护所有的兼容版本，而是只维护最新的几个兼容版本，例如维护最新的三个兼容版本。在一段时间后，当绝大多数用户升级到较新的版本后，废弃一些使用量较少的服务端的老版本API 接口版本，并要求使用产品的非常旧的版本的用户强制升级。</p> \n <p>注意的是，“不改变版本 v1 的查询用户列表的 API 接口”主要指的是对于客户端的调用者而言它看起来是没有改变。而实际上，如果业务变化太大，服务端的开发人员需要对旧版本的 API 接口使用适配器模式将请求适配到新的API 接口上。</p> \n <h3 id=\"资源路径\"><a href=\"#资源路径\" class=\"headerlink\" title=\"资源路径\"></a>资源路径</h3>\n <p>RESTful API 的设计以资源为核心，每一个 URI 代表一种资源。因此，URI 不能包含动词，只能是名词。注意的是，形容词也是可以使用的，但是尽量少用。一般来说，不论资源是单个还是多个，API 的名词要以复数进行命名。此外，命名名词的时候，要使用小写、数字及下划线来区分多个单词。这样的设计是为了与 json 对象及属性的命名方案保持一致。例如，一个查询系统标签的接口可以进行如下设计。</p> \n <pre><code>【GET】  /v1/tags/{tag_id} \n</code></pre>\n <p>同时，资源的路径应该从根到子依次如下</p> \n <pre><code>/{resources}/{resource_id}/{sub_resources}/{sub_resource_id}/{sub_resource_property}\n</code></pre>\n <p>我们来看一个“添加用户的角色”的设计，其中“用户”是主资源，“角色”是子资源。</p> \n <pre><code>【POST】  /v1/users/{user_id}/roles/{role_id} // 添加用户的角色\n</code></pre>\n <p>有的时候，当一个资源变化难以使用标准的 RESTful API 来命名，可以考虑使用一些特殊的 actions 命名。</p> \n <pre><code>/{resources}/{resource_id}/actions/{action}\n</code></pre>\n <p>举个例子，“密码修改”这个接口的命名很难完全使用名词来构建路径，此时可以引入 action 命名。</p> \n <pre><code>【PUT】  /v1/users/{user_id}/password/actions/modify // 密码修改\n</code></pre>\n <h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a>请求方式</h3>\n <p>可以通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。其中：</p> \n <ul> \n  <li>GET：用于查询资源</li> \n  <li>POST：用于创建资源</li> \n  <li>PUT：用于更新服务端的资源的全部信息</li> \n  <li>PATCH：用于更新服务端的资源的部分信息</li> \n  <li>DELETE：用于删除服务端的资源。</li> \n </ul> \n <p>这里，使用“用户”的案例进行回顾通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p> \n <pre><code>【GET】          /users                # 查询用户信息列表\n【GET】          /users/1001           # 查看某个用户信息\n【POST】         /users                # 新建用户信息\n【PUT】          /users/1001           # 更新用户信息(全部字段)\n【PATCH】        /users/1001           # 更新用户信息(部分字段)\n【DELETE】       /users/1001           # 删除用户信息\n</code></pre>\n <h3 id=\"查询参数\"><a href=\"#查询参数\" class=\"headerlink\" title=\"查询参数\"></a>查询参数</h3>\n <p>RESTful API 接口应该提供参数，过滤返回结果。其中，offset 指定返回记录的开始位置。一般情况下，它会结合 limit 来做分页的查询，这里 limit 指定返回记录的数量。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?offset=0&amp;limit=20\n</code></pre>\n <p>同时，orderby 可以用来排序，但仅支持单个字符的排序，如果存在多个字段排序，需要业务中扩展其他参数进行支持。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?orderby={field} [asc|desc]\n</code></pre>\n <p>为了更好地选择是否支持查询总数，我们可以使用 count 字段，count 表示返回数据是否包含总条数，它的默认值为 false。</p> \n <pre><code>【GET】  /{version}/{resources}/{resource_id}?count=[true|false]\n</code></pre>\n <p>上面介绍的 offset、 limit、 orderby 是一些公共参数。此外，业务场景中还存在许多个性化的参数。我们来看一个例子。</p> \n <pre><code>【GET】  /v1/categorys/{category_id}/apps/{app_id}?enable=[1|0]&amp;os_type={field}&amp;device_ids={field,field,…}\n</code></pre>\n <p>注意的是，不要过度设计，只返回用户需要的查询参数。此外，需要考虑是否对查询参数创建数据库索引以提高查询性能。</p> \n <h3 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h3>\n <p>使用适合的状态码很重要，而不应该全部都返回状态码 200，或者随便乱使用。这里，列举在实际开发过程中常用的一些状态码，以供参考。</p> \n <table> \n  <thead> \n   <tr> \n    <th>状态码</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>200</td> \n    <td>请求成功</td> \n   </tr> \n   <tr> \n    <td>201</td> \n    <td>创建成功</td> \n   </tr> \n   <tr> \n    <td>400</td> \n    <td>错误的请求</td> \n   </tr> \n   <tr> \n    <td>401</td> \n    <td>未验证</td> \n   </tr> \n   <tr> \n    <td>403</td> \n    <td>被拒绝</td> \n   </tr> \n   <tr> \n    <td>404</td> \n    <td>无法找到</td> \n   </tr> \n   <tr> \n    <td>409</td> \n    <td>资源冲突</td> \n   </tr> \n   <tr> \n    <td>500</td> \n    <td>服务器内部错误</td> \n   </tr> \n  </tbody> \n </table> \n <h3 id=\"异常响应\"><a href=\"#异常响应\" class=\"headerlink\" title=\"异常响应\"></a>异常响应</h3>\n <p>当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。</p> \n <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n</code></pre>\n <h3 id=\"请求参数\"><a href=\"#请求参数\" class=\"headerlink\" title=\"请求参数\"></a>请求参数</h3>\n <p>在设计服务端的 RESTful API 的时候，我们还需要对请求参数进行限制说明。例如一个支持批量查询的接口，我们要考虑最大支持查询的数量。</p> \n <pre><code>【GET】     /v1/users/batch?user_ids=1001,1002      // 批量查询用户信息\n参数说明\n- user_ids: 用户ID串，最多允许 20 个。\n</code></pre>\n <p>此外，在设计新增或修改接口时，我们还需要在文档中明确告诉调用者哪些参数是必填项，哪些是选填项，以及它们的边界值的限制。</p> \n <pre><code>【POST】     /v1/users                             // 创建用户信息\n请求内容\n{\n    \"username\": \"lusifer\",                 // 必填, 用户名称, max 10\n    \"realname\": \"鲁斯菲尔\",               // 必填, 用户名称, max 10\n    \"password\": \"123456\",              // 必填, 用户密码, max 32\n    \"email\": \"topsale@vip.qq.com\",     // 选填, 电子邮箱, max 32\n    \"weixin\": \"Lusifer\",            // 选填，微信账号, max 32\n    \"sex\": 1                           // 必填, 用户性别[1-男 2-女 99-未知]\n}\n</code></pre>\n <h3 id=\"响应参数\"><a href=\"#响应参数\" class=\"headerlink\" title=\"响应参数\"></a>响应参数</h3>\n <p>针对不同操作，服务端向用户返回的结果应该符合以下规范。</p> \n <pre><code>【GET】     /{version}/{resources}/{resource_id}      // 返回单个资源对象\n【GET】     /{version}/{resources}                    // 返回资源对象的列表\n【POST】    /{version}/{resources}                    // 返回新生成的资源对象\n【PUT】     /{version}/{resources}/{resource_id}      // 返回完整的资源对象\n【PATCH】   /{version}/{resources}/{resource_id}      // 返回完整的资源对象\n【DELETE】  /{version}/{resources}/{resource_id}      // 状态码 200，返回完整的资源对象。\n                                                      // 状态码 204，返回一个空文档\n</code></pre>\n <p>如果是单条数据，则返回一个对象的 JSON 字符串。</p> \n <pre><code>HTTP/1.1 200 OK\n{\n    \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"name\" : \"example\",\n    \"created_time\": 1496676420000,\n    \"updated_time\": 1496676420000,\n    ...\n}\n</code></pre>\n <p>如果是列表数据，则返回一个封装的结构体。</p> \n <pre><code>HTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n            \"name\" : \"example\",\n            \"created_time\": 1496676420000,\n            \"updated_time\": 1496676420000,\n            ...\n        },\n        ...\n    ]\n}\n</code></pre>\n <h3 id=\"一个完整的案例\"><a href=\"#一个完整的案例\" class=\"headerlink\" title=\"一个完整的案例\"></a>一个完整的案例</h3>\n <p>最后，我们使用一个完整的案例将前面介绍的知识整合起来。这里，使用“获取用户列表”的案例。</p> \n <pre><code>【GET】     /v1/users?[&amp;keyword=xxx][&amp;enable=1][&amp;offset=0][&amp;limit=20] 获取用户列表\n功能说明：获取用户列表\n请求方式：GET\n参数说明\n- keyword: 模糊查找的关键字。[选填]\n- enable: 启用状态[1-启用 2-禁用]。[选填]\n- offset: 获取位置偏移，从 0 开始。[选填]\n- limit: 每次获取返回的条数，缺省为 20 条，最大不超过 100。 [选填]\n响应内容\nHTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01234567-89ab-cdef-0123-456789abcdef\",\n            \"name\" : \"example\",\n            \"created_time\": 1496676420000,\n            \"updated_time\": 1496676420000,\n            ...\n        },\n        ...\n    ]\n}\n失败响应\nHTTP/1.1 403 UC/AUTH_DENIED\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n错误代码\n- 403 UC/AUTH_DENIED    授权受限\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(288,12,'怎么考虑数据一致性问题',1,'www.funtl.com/assets/66ecd4cb674eb4b55f786b7f8517ea07.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"单体应用的数据一致性\"><a href=\"#单体应用的数据一致性\" class=\"headerlink\" title=\"单体应用的数据一致性\"></a>单体应用的数据一致性</h3>\n <p>想象一下如果我们经营着一家大型企业，下属有航空公司、租车公司、和连锁酒店。我们为客户提供一站式的旅游行程规划服务，这样客户只需要提供出行目的地，我们帮助客户预订机票、租车、以及预订酒店。从业务的角度，我们必须保证上述三个服务的预订都完成才能满足一个成功的旅游行程，否则不能成行。</p> \n <p>我们的单体应用要满足这个需求非常简单，只需将这个三个服务请求放到同一个数据库事务中，数据库会帮我们保证全部成功或者全部回滚。</p> \n <p><img src=\"/assets/66ecd4cb674eb4b55f786b7f8517ea07.png\" alt=\"\"></p> \n <p>当这个功能上线以后，公司非常满意，客户也非常高兴。</p> \n <h3 id=\"微服务场景下的数据一致性\"><a href=\"#微服务场景下的数据一致性\" class=\"headerlink\" title=\"微服务场景下的数据一致性\"></a>微服务场景下的数据一致性</h3>\n <p>这几年中，我们的行程规划服务非常成功，企业蒸蒸日上，用户量也翻了数十倍。企业的下属航空公司、租车公司、和连锁酒店也相继推出了更多服务以满足客户需求，我们的应用和开发团队也因此日渐庞大。如今我们的单体应用已变得如此复杂，以至于没人了解整个应用是怎么运作的。更糟的是新功能的上线现在需要所有研发团队合作，日夜奋战数周才能完成。看着市场占有率每况愈下，公司高层对研发部门越来越不满意。</p> \n <p>经过数轮讨论，我们最终决定将庞大的单体应用一分为四：机票预订服务、租车服务、酒店预订服务、和支付服务。服务各自使用自己的数据库，并通过 HTTP 协议通信。负责各服务的团队根据市场需求按照自己的开发节奏发版上线。如今我们面临新的挑战：如何保证最初三个服务的预订都完成才能满足一个成功的旅游行程， 否则不能成行的业务规则？现在服务有各自的边界，而且数据库选型也不尽相同，通过数据库保证数据一致性的方案已不可行。</p> \n <p><img src=\"/assets/f1a152a2a4a84d135fafb08525f0f9ce.png\" alt=\"\"></p> \n <h3 id=\"Sagas\"><a href=\"#Sagas\" class=\"headerlink\" title=\"Sagas\"></a>Sagas</h3>\n <p>幸运的是我们在互联网找到一篇精彩的论文，文中提出的数据一致性解决方案 Saga 恰好满足我们的业务要求。</p> \n <blockquote> \n  <p>Saga 是一个长活事务，可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。</p> \n </blockquote> \n <p>在我们的业务场景下，一个行程规划的事务就是一个 Saga，其中包含四个子事务：机票预订、租车、酒店预订、和支付。</p> \n <p><img src=\"/assets/fc69ade8b2ec344c0d6f53fbec302a37.png\" alt=\"\"></p> \n <p>Chris Richardson 在他的文章 Pattern: Saga 中对 Saga 有所描述。 Caitie McCaffrey 也在她的演讲中提到如何在微软的 光晕4 游戏中如何应用 saga 解决数据一致性问题。</p> \n <h4 id=\"Saga-的运行原理\"><a href=\"#Saga-的运行原理\" class=\"headerlink\" title=\"Saga 的运行原理\"></a>Saga 的运行原理</h4>\n <blockquote> \n  <p>Saga 中的事务相互关联，应作为（非原子）单位执行。任何未完全执行的 Saga 是不满足要求的，如果发生，必须得到补偿。要修正未完全执行的部分，每个 saga 子交易 T1 应提供对应补偿事务 C1</p> \n </blockquote> \n <p>我们根据上述规则定义以下事务及其相应的事务补偿： </p> \n <table> \n  <thead> \n   <tr> \n    <th>服务</th> \n    <th>事务</th> \n    <th>补偿</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>机票预订</td> \n    <td>预订机票</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>租车</td> \n    <td>租车</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>酒店预订</td> \n    <td>预订房间</td> \n    <td>取消预订</td> \n   </tr> \n   <tr> \n    <td>支付</td> \n    <td>支付</td> \n    <td>退款</td> \n   </tr> \n  </tbody> \n </table> \n <pre><code>当每个 saga 子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1, 那么 saga 系统可以保证\n\n子事务序列 T1, T2, …, Tn 得以完成 (最佳情况)\n或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成\n</code></pre>\n <p>换句话说，通过上述定义的事务/补偿，saga 保证满足以下业务规则：</p> \n <ul> \n  <li>所有的预订都被执行成功，如果任何一个失败，都会被取消</li> \n  <li>如果最后一步付款失败，所有预订也将被取消</li> \n </ul> \n <h4 id=\"Saga-的恢复方式\"><a href=\"#Saga-的恢复方式\" class=\"headerlink\" title=\"Saga 的恢复方式\"></a>Saga 的恢复方式</h4>\n <p>原论文中描述了两种类型的 Saga 恢复方式：</p> \n <blockquote> \n  <p>向后恢复 补偿所有已完成的事务，如果任一子事务失败<br>向前恢复 重试失败的事务，假设每个子事务最终都会成功</p> \n </blockquote> \n <p>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。</p> \n <p>理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机，网络可能会失败，甚至数据中心也可能会停电。在这种情况下我们能做些什么？最后的手段是提供回退措施，比如人工干预。</p> \n <h4 id=\"使用-Saga-的条件\"><a href=\"#使用-Saga-的条件\" class=\"headerlink\" title=\"使用 Saga 的条件\"></a>使用 Saga 的条件</h4>\n <p>Saga 看起来很有希望满足我们的需求。所有长活事务都可以这样做吗？这里有一些限制：</p> \n <ul> \n  <li>Saga 只允许两个层次的嵌套，顶级的 Saga 和简单子事务 </li> \n  <li>在外层，全原子性不能得到满足。也就是说，sagas 可能会看到其他 sagas 的部分结果</li> \n  <li>每个子事务应该是独立的原子行为</li> \n  <li>在我们的业务场景下，航班预订、租车、酒店预订和付款是自然独立的行为，而且每个事务都可以用对应服务的数据库保证原子操作。</li> \n </ul> \n <p>我们在行程规划事务层面也不需要原子性。一个用户可以预订最后一张机票，而后由于信用卡余额不足而被取消。同时另一个用户可能开始会看到已无余票，接着由于前者预订被取消，最后一张机票被释放，而抢到最后一个座位并完成行程规划。</p> \n <p>补偿也有需考虑的事项：</p> \n <ul> \n  <li>补偿事务从语义角度撤消了事务 Ti 的行为，但未必能将数据库返回到执行 Ti 时的状态。（例如，如果事务触发导弹发射，则可能无法撤消此操作）</li> \n </ul> \n <p>但这对我们的业务来说不是问题。其实难以撤消的行为也有可能被补偿。例如，发送电邮的事务可以通过发送解释问题的另一封电邮来补偿。</p> \n <p>现在我们有了通过 Saga 来解决数据一致性问题的方案。它允许我们成功地执行所有事务，或在任何事务失败的情况下，补偿已成功的事务。虽然 Saga 不提供 ACID 保证，但仍适用于许多数据最终一致性的场景。那我们如何设计一个 Saga 系统？</p> \n <h4 id=\"Saga-Log\"><a href=\"#Saga-Log\" class=\"headerlink\" title=\"Saga Log\"></a>Saga Log</h4>\n <p>Saga 保证所有的子事务都得以完成或补偿，但 Saga 系统本身也可能会崩溃。Saga 崩溃时可能处于以下几个状态：</p> \n <ul> \n  <li>Saga 收到事务请求，但尚未开始。因子事务对应的微服务状态未被 Saga 修改，我们什么也不需要做。</li> \n  <li>一些子事务已经完成。重启后，Saga 必须接着上次完成的事务恢复。</li> \n  <li>子事务已开始，但尚未完成。由于远程服务可能已完成事务，也可能事务失败，甚至服务请求超时，saga 只能重新发起之前未确认完成的子事务。这意味着子事务必须幂等。</li> \n  <li>子事务失败，其补偿事务尚未开始。Saga 必须在重启后执行对应补偿事务。</li> \n  <li>补偿事务已开始但尚未完成。解决方案与上一个相同。这意味着补偿事务也必须是幂等的。</li> \n  <li>所有子事务或补偿事务均已完成，与第一种情况相同。</li> \n </ul> \n <p>为了恢复到上述状态，我们必须追踪子事务及补偿事务的每一步。我们决定通过事件的方式达到以上要求，并将以下事件保存在名为 saga log 的持久存储中：</p> \n <ul> \n  <li>Saga started event 保存整个 saga 请求，其中包括多个事务/补偿请求</li> \n  <li>Transaction started event 保存对应事务请求</li> \n  <li>Transaction ended event 保存对应事务请求及其回复</li> \n  <li>Transaction aborted event 保存对应事务请求和失败的原因</li> \n  <li>Transaction compensated event 保存对应补偿请求及其回复</li> \n  <li>Saga ended event 标志着 saga 事务请求的结束，不需要保存任何内容</li> \n </ul> \n <p><img src=\"/assets/66ae7b320e502c13f4a21a08baa61ead.png\" alt=\"\"></p> \n <p>通过将这些事件持久化在 saga log 中，我们可以将 saga 恢复到上述任何状态。</p> \n <p>由于 Saga 只需要做事件的持久化，而事件内容以 JSON 的形式存储，Saga log 的实现非常灵活，数据库（SQL 或 NoSQL），持久消息队列，甚至普通文件可以用作事件存储，当然有些能更快得帮 saga 恢复状态。</p> \n <h4 id=\"Saga-请求的数据结构\"><a href=\"#Saga-请求的数据结构\" class=\"headerlink\" title=\"Saga 请求的数据结构\"></a>Saga 请求的数据结构</h4>\n <p>在我们的业务场景下，航班预订、租车、和酒店预订没有依赖关系，可以并行处理，但对于我们的客户来说，只在所有预订成功后一次付费更加友好。那么这四个服务的事务关系可以用下图表示：</p> \n <p><img src=\"/assets/918b4d0d912c6cdb8ee0690acf303950.png\" alt=\"\"></p> \n <p>将行程规划请求的数据结构实现为有向非循环图恰好合适。图的根是 saga 启动任务，叶是 saga 结束任务。</p> \n <p><img src=\"/assets/c62a633865fd31b25688523cb5f4093f.png\" alt=\"\"></p> \n <h4 id=\"Parallel-Saga\"><a href=\"#Parallel-Saga\" class=\"headerlink\" title=\"Parallel Saga\"></a>Parallel Saga</h4>\n <p>如上所述，航班预订，租车和酒店预订可以并行处理。但是这样做会造成另一个问题：如果航班预订失败，而租车正在处理怎么办？我们不能一直等待租车服务回应，因为不知道需要等多久。</p> \n <p>最好的办法是再次发送租车请求，获得回应，以便我们能够继续补偿操作。但如果租车服务永不回应，我们可能需要采取回退措施，比如手动干预。</p> \n <p>超时的预订请求可能最后仍被租车服务收到，这时服务已经处理了相同的预订和取消请求。</p> \n <p><img src=\"/assets/b683af658000f43b34c7d99d6be060ca.png\" alt=\"\"></p> \n <p>因此，服务的实现必须保证补偿请求执行以后，再次收到的对应事务请求无效。 Caitie McCaffrey 在她的演讲 Distributed Sagas: A Protocol for Coordinating MicroServices 中把这个称为可交换的补偿请求 (commutative compensating request)。</p> \n <h4 id=\"ACID-and-Saga\"><a href=\"#ACID-and-Saga\" class=\"headerlink\" title=\"ACID and Saga\"></a>ACID and Saga</h4>\n <p>ACID 是具有以下属性的一致性模型：</p> \n <ul> \n  <li>原子性（Atomicity）</li> \n  <li>一致性（Consistency）</li> \n  <li>隔离性（Isolation）</li> \n  <li>持久性（Durability）</li> \n </ul> \n <p>Saga 不提供 ACID 保证，因为原子性和隔离性不能得到满足。原论文描述如下：</p> \n <blockquote> \n  <p>full atomicity is not provided. That is, sagas may view the partial results of other sagas</p> \n </blockquote> \n <p>通过 saga log，saga 可以保证一致性和持久性。</p> \n <h4 id=\"Saga-架构\"><a href=\"#Saga-架构\" class=\"headerlink\" title=\"Saga 架构\"></a>Saga 架构</h4>\n <p>最后，我们的 Saga 架构如下：</p> \n <p><img src=\"/assets/44bd3121a8b6d720704e2d8b363ea2ce.png\" alt=\"\"></p> \n <ul> \n  <li>Saga Execution Component 解析请求 JSON 并构建请求图</li> \n  <li>TaskRunner 用任务队列确保请求的执行顺序</li> \n  <li>TaskConsumer 处理 Saga 任务，将事件写入 saga log，并将请求发送到远程服务</li> \n </ul> \n <p>在上文中，我谈到了 ServiceComb 下的 Saga 是怎么设计的。 然而，业界还有其他数据一致性解决方案，如 <strong>两阶段提交（2PC）</strong> 和 <strong>Try-Confirm / Cancel（TCC）</strong>。那 saga 相比之下有什么特别？</p> \n <h3 id=\"两阶段提交-Two-Phase-Commit-2PC\"><a href=\"#两阶段提交-Two-Phase-Commit-2PC\" class=\"headerlink\" title=\"两阶段提交 Two-Phase Commit (2PC)\"></a>两阶段提交 Two-Phase Commit (2PC)</h3>\n <blockquote> \n  <p>两阶段提交协议是一种分布式算法，用于协调参与分布式原子事务的所有进程，以保证他们均完成提交或中止（回滚）事务。</p> \n </blockquote> \n <p>2PC 包含两个阶段：</p> \n <ul> \n  <li>投票阶段 协调器向所有服务发起投票请求，服务回答 yes 或 no。如果有任何服务回复 no 以拒绝或超时，协调器则在下一阶段发送中止消息。</li> \n </ul> \n <p><img src=\"/assets/b8624ace7c31f49016bde30abf444af0.png\" alt=\"\"> </p> \n <ul> \n  <li>决定阶段 如果所有服务都回复 yes，协调器则向服务发送 commit 消息，接着服务告知事务完成或失败。如果任何服务提交失败， 协调器将启动额外的步骤以中止该事务。</li> \n </ul> \n <p><img src=\"/assets/f29111544bc473085109d3d04788be44.png\" alt=\"\"></p> \n <p>在投票阶段结束之后与决策阶段结束之前，服务处于不确定状态，因为他们不确定交易是否继续进行。当服务处于不确定状态并与协调器失去连接时，它只能选择等待协调器的恢复，或者咨询其他在确定状态下的服务来得知协调器的决定。在最坏的情况下，n 个处于不确定状态的服务向其他 n-1 个服务咨询将产生 O(n2) 个消息。</p> \n <p>另外，2PC 是一个阻塞协议。服务在投票后需要等待协调器的决定，此时服务会阻塞并锁定资源。由于其阻塞机制和最差时间复杂度高，2PC 不能适应随着事务涉及的服务数量增加而扩展的需要。</p> \n <h3 id=\"Try-Confirm-Cancel-TCC\"><a href=\"#Try-Confirm-Cancel-TCC\" class=\"headerlink\" title=\"Try-Confirm/Cancel (TCC)\"></a>Try-Confirm/Cancel (TCC)</h3>\n <p>TCC 也是补偿型事务模式，支持两阶段的商业模型。</p> \n <ul> \n  <li>尝试阶段 将服务置于待处理状态。例如，收到尝试请求时，航班预订服务将为客户预留一个座位，并在数据库插入客户预订记录，将记录设为预留状态。如果任何服务失败或超时，协调器将在下一阶段发送取消请求。</li> \n </ul> \n <p><img src=\"/assets/b09bbf2e8d332c163934ce165eab883e.png\" alt=\"\"></p> \n <ul> \n  <li>确认阶段 将服务设为确认状态。确认请求将确认客户预订的座位，这时服务已可向客户收取机票费用。数据库中的客户预订记录也会被更新为确认状态。如果任何服务无法确认或超时，协调器将重试确认请求直到成功，或在重试了一定次数后采取回退措施，比如人工干预。 </li> \n </ul> \n <p><img src=\"/assets/1e14e4ad4804835734389a7a427ba9c3.png\" alt=\"\"></p> \n <p>与 saga 相比，TCC 的优势在于，尝试阶段将服务转为待处理状态而不是最终状态，这使得设计相应的取消操作轻而易举。</p> \n <p>例如，电邮服务的尝试请求可将邮件标记为准备发送，并且仅在确认后发送邮件，其相应的取消请求只需将邮件标记为已废弃。但如果使用 saga，事务将发送电子邮件，及其相应的补偿事务可能需要发送另一封电子邮件作出解释。</p> \n <p>TCC 的缺点是其两阶段协议需要设计额外的服务待处理状态，以及额外的接口来处理尝试请求。另外，TCC 处理事务请求所花费的时间可能是 saga 的两倍，因为 TCC 需要与每个服务进行两次通信，并且其确认阶段只能在收到所有服务对尝试请求的响应后开始。</p> \n <h3 id=\"事件驱动的架构\"><a href=\"#事件驱动的架构\" class=\"headerlink\" title=\"事件驱动的架构\"></a>事件驱动的架构</h3>\n <p>和 TCC 一样，在事件驱动的架构中，长活事务涉及的每个服务都需要支持额外的待处理状态。接收到事务请求的服务会在其数据库中插入一条新的记录，将该记录状态设为待处理并发送一个新的事件给事务序列中的下一个服务。</p> \n <p>因为在插入记录后服务可能崩溃，我们无法确定是否新事件已发送，所以每个服务还需要额外的事件表来跟踪当前长活事务处于哪一步。</p> \n <p><img src=\"/assets/a94dc9b0b1b2195f9cff27ea3056fd5d.png\" alt=\"\"></p> \n <p>一旦长活事务中的最后一个服务完成其子事务，它将通知它在事务中的前一个服务。接收到完成事件的服务将其在数据库中的记录状态设为完成。</p> \n <p><img src=\"/assets/204d8d1b2939d66cfb9752219ad70920.png\" alt=\"\"></p> \n <p>如果仔细比较，事件驱动的架构就像非集中式的基于事件的 TCC 实现。如果去掉待处理状态而直接把服务记录设为最终状态，这个架构就像非集中式的基于事件的 saga 实现。去中心化能达到服务自治，但也造成了服务之间更紧密的的耦合。假设新的业务需求在服务 B 和 C 之间的增加了新的流程 D。在事件驱动架构下，服务 B 和 C 必须改动代码以适应新的流程 D。</p> \n <p><img src=\"/assets/3f46ba9b45f867c33993cdb81871bfc9.png\" alt=\"\"> </p> \n <p>Saga 则正好相反，所有这些耦合都在 saga 系统中，当在长活事务中添加新流程时，现有服务不需要任何改动。</p> \n <h3 id=\"集中式与非集中式实现\"><a href=\"#集中式与非集中式实现\" class=\"headerlink\" title=\"集中式与非集中式实现\"></a>集中式与非集中式实现</h3>\n <p>这个 Saga 系列的文章讨论的都是集中式的 saga 设计。但 saga 也可用非集中式的方案来实现。那么非集中式的版本有什么不同？</p> \n <p>非集中式 saga 没有专职的协调器。启动下一个服务调用的服务就是当前的协调器。例如：</p> \n <ul> \n  <li>服务 A 收到要求服务 A，B 和 C 之间的数据一致性的事务请求。</li> \n  <li>A 完成其子事务，并将请求传递给事务中的下一个服务，服务 B.</li> \n  <li>B 完成其子事务，并将请求传递给 C，依此类推。</li> \n  <li>如果 C 处理请求失败，B 有责任启动补偿事务，并要求 A 回滚。 </li> \n </ul> \n <p><img src=\"/assets/1a7a9de881f2665697337a03fb1a5c6f.png\" alt=\"\"></p> \n <p>与集中式相比，非集中式的实现具有服务自治的优势。但每个服务都需要包含数据一致性协议，并提供其所需的额外持久化设施。</p> \n <p>我们更倾向于自治的业务服务，但服务还关联很多应用的复杂性，如数据一致性，服务监控和消息传递，将这些棘手问题集中处理，能将业务服务从应用的复杂性中释放，专注于处理复杂的业务，因此我们采用了集中式的 saga 设计。</p> \n <p>另外，随着长活事务中涉及的服务数量增长，服务之间的关系变得越来越难理解。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>本文将 saga 与其他数据一致性解决方案进行了比较。Saga 比两阶段提交更易扩展。在事务可补偿的情况下，相比 TCC，saga 对业务逻辑几乎没有改动的需要，而且性能更高。集中式的 saga 设计解耦了服务与数据一致性逻辑及其持久化设施，并使排查事务中的问题更容易。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(289,12,'微服务与 SOA 的区别',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>微服务是 SOA 发展出来的产物，它是一种比较现代化的细粒度的 SOA 实现方式。</p> \n <p>较早实践微服务的公司 Netflix 就曾经称他们构建的架构是「细粒度的 SOA」。</p> \n <p>讨论「微服务和 SOA 的差别」的意义远不如讨论「微服务和单体系统的差别」更大，因为他们的区别实在有点微妙。此外，互联网近些年的发展，越来越朝去中心化的方向前进了，就像今天的IT工程师不需要像律师、教师那样，需要得到某些机构的认可才能更好的开展工作，这一方面意味着门槛的降低，另一方面也意味着更多的概念没有一个权威的声音来对它进行定义，使得每个人可以根据自己的需求做出不同的调整。</p> \n <p>微服务和 SOA 都是这样背景下的产物，并没有一个权威的定义，来说明它们各自包含了什么东西，使用什么的方法进行系统的构建。但是，还是可以从最大的范围来对比它们的不同，当我们今天说出这两个概念时，其区别往往没有那么大，但 SOA 是有一定的历史了，在历史上的 SOA 往往意味着更多的东西，而这些是现在很多人在做架构设计时不会采用的。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(290,12,'你怎么看待微服务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在我的课程 <a href=\"/2018/04/07/microservice/Java-微服务架构/\"><strong>【Java 微服务架构】</strong></a> 中的 <strong>微服务简介</strong> 章节即为参考答案。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(291,12,'微服务哪些框架',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3>\n <p>是阿里巴巴服务化治理的核心框架，并被广泛应用于阿里巴巴集团的各成员站点。阿里巴巴近几年对开源社区的贡献不论在国内还是国外都是引人注目的，比如：JStorm 捐赠给 Apache 并加入 Apache 基金会等，为中国互联网人争足了面子，使得阿里巴巴在国人眼里已经从电商升级为一家科技公司了。</p> \n <h3 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h3>\n <p>从命名我们就可以知道，它是 Spring Source 的产物，Spring 社区的强大背书可以说是 Java 企业界最有影响力的组织了，除了 Spring Source 之外，还有 Pivotal 和 Netflix 是其强大的后盾与技术输出。其中 Netflix 开源的整套微服务架构套件是 Spring Cloud 的核心。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:01','2018-12-20 22:06:01'),
(292,12,'如何拆分服务',1,'www.funtl.com/assets/d8a0f183c602fd4e0411771d6f325cfd.jpg',1,'<div class=\"col-sm-12\"> \n <p>如今，市场环境纷繁复杂，瞬息万变，现代企业为了更好地生存，需要有极强的适应能力。<strong>快速而轻松地迎接改变，成为了一个优质企业的特征之一</strong>，同时企业还要求技术团队构建更科学的架构，搭建成本更低的平台，这就使得这些团队越来越倾向于使用微服务架构来应对以上要求。</p> \n <p>微服务的做法有利于软件组件和数据的分散化，将一个整体分解成更小、更容易改变的部分，<strong>分散仅帮助团队加快工程进度，而不会牺牲系统的安全性</strong>。要想让这种架构工作得很好，需要改变工作方式。</p> \n <p>微服务架构的设计，其实是为了使团队能够在执行工作的人之间分配决策权力，向更多成员直接推行决策权，允许他们以更自由的方式生产。微服务架构使用正确的话，将产生更好和更快的变化。但是如果你的架构错误，那么一系列坏的决定可能会降低转化率，甚至会损害你的业务。</p> \n <p><img src=\"/assets/d8a0f183c602fd4e0411771d6f325cfd.jpg\" alt=\"\"></p> \n <p>我们讲决策权分配，即是说微服务架构的拆分实际上就是在寻求正确的权力下放战略。这是一个进化过程，需要不断地进行分析和调整。而如何正确的拆分微服务架构，我认为可以重点从以下三个方面考虑：</p> \n <h3 id=\"1-我们应该做哪些决定？\"><a href=\"#1-我们应该做哪些决定？\" class=\"headerlink\" title=\"1. 我们应该做哪些决定？\"></a>1. 我们应该做哪些决定？</h3>\n <p>设计微服务系统不仅仅是改变组件大小，架构中涉及创建和更改服务的所有领域都有一定的作用。在这里总结了以下九个方面，作为拆分微服务架构时所做决定的参考：</p> \n <ul> \n  <li>生命周期：什么时候创建或停止服务？我们什么时候需要将它们分开？</li> \n  <li>服务实现：我们应该在每个服务中使用哪些工具、语言和架构？</li> \n  <li>系统架构：服务如何引导他人？开发人员如何了解？</li> \n  <li>数据架构：服务之间如何共享数据？</li> \n  <li>变更过程：什么时候可以改变服务？部署和 QA 的工具和过程？</li> \n  <li>团队管理：谁在哪个团队服务？每个团队负责什么？团队成员做了什么？</li> \n  <li>人事管理：人员如何被雇用和解雇？员工如何激励和奖励？</li> \n  <li>安全管理：我们如何降低安全事故的风险？需要做些什么来改善整个系统的安全性？</li> \n  <li>采购过程：可以购买什么软件？使用开源软件需要哪些保护？</li> \n </ul> \n <h3 id=\"2-涉及到哪些人？\"><a href=\"#2-涉及到哪些人？\" class=\"headerlink\" title=\"2. 涉及到哪些人？\"></a>2. 涉及到哪些人？</h3>\n <p>不得不承认，一个员工做出的一些决定对他们的公司来说可能是非常有影响力的。一个很典型的现象是，公司试图对内部的决策者增加控制，以便将风险降至最低，从而导致决策权集中化。例如，在过去的几年中，苹果以拥有一个高度集中的设计团队而闻名，少数的人做出产品设计的大部分决策。</p> \n <p>集中发生是因为正确的人需要做出最重要的决定。通常，<strong>“正确的人”是具有天赋，专业知识和经验的组合</strong>，使我们能够相信他们做出最好的决定，我们可以称这些人为我们的“明星决策者”。但实际上，公司的“明星决策者”数量有限，大多数团队只有几颗“明星”。</p> \n <p>微服务改变了这种少数人行使决策权的现象，同时更容易应对错误的决策。如果一个团队在微服务工作时作出错误的决定，其错误的波及范围会很小，容错率变高。当系统的更改变得便宜和容易时，团队可以快速改进先前的决策，使他们能够更快地获得最佳决策。</p> \n <p><img src=\"/assets/28ac7af07ba332c29e9a0d91030b0af1.png\" alt=\"\"></p> \n <h3 id=\"3-谁拥有哪一部分？\"><a href=\"#3-谁拥有哪一部分？\" class=\"headerlink\" title=\"3. 谁拥有哪一部分？\"></a>3. 谁拥有哪一部分？</h3>\n <p>决策基于选择，而选择又基于领域知识。决策不应该立即执行，它需要一个过程，需要高度专业的技能或知识来实现。</p> \n <p>管理专家亨利•明茨伯格（Henry Mintzberg）为我们提供了一个很好的模式，其中概述了决策过程的步骤：</p> \n <ul> \n  <li>研究与信息采集</li> \n  <li>生成选择</li> \n  <li>做出选择</li> \n  <li>授权的选择</li> \n  <li>执行和实施</li> \n </ul> \n <p>所有这一切的关键，是在采用决策分权化时，不需要绝对。每个步骤都可以独立集中或分散化，在平衡效率和安全性时，可以获得更大的灵活性。如今，集中选择与非集中选择相结合，也是现在很多大公司常见的模式。</p> \n <p>当人们谈论微服务架构时，权力下放过程的选择、授权和执行部分相互协作、快速、规模化地移动，这些都降低了变化来临时对整体系统产生的负面影响。它是提高变革速度的有效途径，但不要忘记，你的成员特点、团队协调，以及所有的系统、工具和工作环境同样重要。</p> \n <p>你必须了解如何做出决策，如何改进流程，这才是迎接变化的好方法。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(293,12,'说说最终一致性的实现方案',1,'www.funtl.com/assets/006kbv1Jgw1f31xaggg0bj30cq09mq3h.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"问题的起源\"><a href=\"#问题的起源\" class=\"headerlink\" title=\"问题的起源\"></a>问题的起源</h3>\n <p>在电商等业务中，系统一般由多个独立的服务组成，如何解决分布式调用时候数据的一致性？ </p> \n <p>具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。</p> \n <p>在分布式系统来说，如果不想牺牲一致性，CAP 理论告诉我们只能放弃可用性，这显然不能接受。为了便于讨论问题，先简单介绍下数据一致性的基础理论。</p> \n <h4 id=\"强一致\"><a href=\"#强一致\" class=\"headerlink\" title=\"强一致\"></a>强一致</h4>\n <p>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</p> \n <h4 id=\"弱一致性\"><a href=\"#弱一致性\" class=\"headerlink\" title=\"弱一致性\"></a>弱一致性</h4>\n <p>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</p> \n <h4 id=\"最终一致性\"><a href=\"#最终一致性\" class=\"headerlink\" title=\"最终一致性\"></a>最终一致性</h4>\n <p>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。</p> \n <p>在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别，群友的讨论分成以下 6 种解决方案。</p> \n <h3 id=\"1-规避分布式事务——业务整合\"><a href=\"#1-规避分布式事务——业务整合\" class=\"headerlink\" title=\"1. 规避分布式事务——业务整合\"></a>1. 规避分布式事务——业务整合</h3>\n <p>业务整合方案主要采用将接口整合到本地执行的方法。拿问题场景来说，则可以将服务 A、B、C 整合为一个服务 D 给业务，这个服务 D 再通过转换为本地事务的方式，比如服务 D 包含本地服务和服务 E，而服务 E 是本地服务 A ~ C 的整合。</p> \n <p>优点：解决（规避）了分布式事务。</p> \n <p>缺点：显而易见，把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。</p> \n <p>由于这个方法存在明显缺点，<strong>通常不建议使用</strong>。</p> \n <h3 id=\"2-经典方案-eBay-模式\"><a href=\"#2-经典方案-eBay-模式\" class=\"headerlink\" title=\"2. 经典方案 - eBay 模式\"></a>2. 经典方案 - eBay 模式</h3>\n <p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p> \n <p><strong>消息日志方案的核心是保证服务接口的幂等性。</strong></p> \n <p>考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。</p> \n <p>eBay 方式的主要思路如下。</p> \n <h4 id=\"BASE：一种-ACID-的替代方案\"><a href=\"#BASE：一种-ACID-的替代方案\" class=\"headerlink\" title=\"BASE：一种 ACID 的替代方案\"></a>BASE：一种 ACID 的替代方案</h4>\n <p>此方案是 eBay 的架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章，是一篇解释 BASE 原则，或者说最终一致性的经典文章。文中讨论了 BASE 与 ACID 原则在保证数据一致性的基本差异。</p> \n <p>如果 ACID 为分区的数据库提供一致性的选择，那么如何实现可用性呢？</p> \n <h4 id=\"BASE-basically-available-soft-state-eventually-consistent\"><a href=\"#BASE-basically-available-soft-state-eventually-consistent\" class=\"headerlink\" title=\"BASE (basically available, soft state, eventually consistent)\"></a>BASE (basically available, soft state, eventually consistent)</h4>\n <p>BASE 的可用性是通过 <strong>支持局部故障</strong> 而不是系统全局故障来实现的。下面是一个简单的例子：如果将用户分区在 5 个数据库服务器上，BASE 设计鼓励类似的处理方式，一个用户数据库的故障只影响这台特定主机那 20% 的用户。这里不涉及任何魔法，不过它确实可以带来更高的可感知的系统可用性。</p> \n <p>文章中描述了一个最常见的场景，如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。这两个表属于不同的远程服务，所以就涉及到分布式事务一致性的问题</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xaggg0bj30cq09mq3h.jpg\" alt=\"\"></p> \n <p>文中提出了一个经典的解决方法，将主要修改操作以及更新用户表的消息放在 <strong>一个本地事务</strong> 来完成。同时为了避免重复消费用户表消息带来的问题，达到多次重试的幂等性，<strong>增加一个更新记录表 updates_applied</strong> 来记录已经处理过的消息。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xaq6ex2j30ct082wev.jpg\" alt=\"\"></p> \n <p>系统的执行伪代码如下：</p> \n <pre><code>Begin transaction\n    Insert into transaction(id, selller_id, buyer_id, amount);\n    Queue message \"update user(\'seller\', selller_id, amount)\";\n    Queue message \"update user(\'buyer\', buyer_id, amount)\";\nEnd transaction\n\nFor each message in queue\n    Peek message\n    Begin transaction\n        Select count(*) as processed where trans_id = message.trans_id\n            and balance = message.balance and user_id = message.user_id\n        if processed == 0\n            if message.balance == \"seller\"\n                Update user set amt_sold = amt_sold + message.amount\n                    where id = message.id;\n\n            Else\n                Update user set amt_bought = amt_bought + message.amount\n                    where id = message.id\n\n            End if\n\n        Insert int updates_applied\n            (message.trans_id, message.balance, message.user_id);\n        End if\n    End transaction\n\n    if transaction successful\n        Remove message from queue\n    End if\nEnd for\n</code></pre>\n <p>基于以上方法，在第一阶段，通过本地的数据库的事务保障，增加了 transaction 表及消息队列 。</p> \n <p>在第二阶段，分别读出消息队列（但不删除），通过判断更新记录表 updates_applied 来检测相关记录是否被执行，未被执行的记录会修改 user 表，然后增加一条操作记录到 updates_applied，事务执行成功之后再删除队列。</p> \n <p>通过以上方法，达到了分布式系统的最终一致性。进一步了解 eBay 的方案可以参考文末链接。</p> \n <h3 id=\"3-去哪儿网分布式事务方案\"><a href=\"#3-去哪儿网分布式事务方案\" class=\"headerlink\" title=\"3. 去哪儿网分布式事务方案\"></a>3. 去哪儿网分布式事务方案</h3>\n <p>随着业务规模不断地扩大，电商网站一般都要面临拆分之路。就是将原来一个单体应用拆分成多个不同职责的子系统。比如以前可能将面向用户、客户和运营的功能都放在一个系统里，现在拆分为订单中心、代理商管理、运营系统、报价中心、库存管理等多个子系统。</p> \n <p><strong>拆分首先要面临的是什么呢？</strong></p> \n <p>最开始的单体应用所有功能都在一起，存储也在一起。比如运营要取消某个订单，那直接去更新订单表状态，然后更新库存表就 ok 了。因为是单体应用，库在一起，这些都可以在一个事务里，由关系数据库来保证一致性。</p> \n <p>但拆分之后就不同了，不同的子系统都有自己的存储。比如订单中心就只管理自己的订单库，而库存管理也有自己的库。那么运营系统取消订单的时候就是通过接口调用等方式来调用订单中心和库存管理的服务了，而不是直接去操作库。这就涉及一个『分布式事务』的问题。 </p> \n <p>分布式事务有两种解决方式</p> \n <h4 id=\"优先使用异步消息\"><a href=\"#优先使用异步消息\" class=\"headerlink\" title=\"优先使用异步消息\"></a>优先使用异步消息</h4>\n <p>上文已经说过，使用异步消息 Consumer 端需要实现幂等。</p> \n <p>幂等有两种方式，<strong>一种方式是业务逻辑保证幂等</strong>。比如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息则说明消息重复了，直接作为消息成功处理。</p> \n <p><strong>另外一种方式如果业务逻辑无法保证幂等，则要增加一个去重表或者类似的实现</strong>。对于 producer 端在业务数据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务里。发消息的时候消息并不立即发出，而是向消息库插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送消息如果成功则将消息库里的消息删除，如果遇到消息队列服务异常或网络问题，消息没有成功发出那么消息就留在这里了，会有另外一个服务不断地将这些消息扫出重新发送。</p> \n <h4 id=\"有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\"><a href=\"#有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\" class=\"headerlink\" title=\"有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果\"></a>有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果</h4>\n <p>这种情况的实现方式其实和上面类似，每个参与方的本地业务库的同实例上面放一个事务记录库。</p> \n <p>比如 A 同步调用 B，C。A 本地事务成功的时候更新本地事务记录状态，B 和 C 同样。如果有一次 A 调用 B 失败了，这个失败可能是 B 真的失败了，也可能是调用超时，实际 B 成功。则由一个中心服务对比三方的事务记录表，做一个最终决定。假设现在三方的事务记录是 A 成功，B 失败，C 成功。那么最终决定有两种方式，根据具体场景：</p> \n <ul> \n  <li>重试 B，直到 B 成功，事务记录表里记录了各项调用参数等信息；</li> \n  <li>执行 A 和 B 的补偿操作(一种可行的补偿方式是回滚)。</li> \n </ul> \n <p>对 b 场景做一个特殊说明：比如 B 是扣库存服务，在第一次调用的时候因为某种原因失败了，但是重试的时候库存已经变为 0，无法重试成功，这个时候只有回滚 A 和 C 了。</p> \n <p>那么可能有人觉得在业务库的同实例里放消息库或事务记录库，会对业务侵入，业务还要关心这个库，是否一个合理的设计？</p> \n <p>实际上可以依靠运维的手段来简化开发的侵入，我们的方法是让 DBA 在公司所有 MySQL 实例上预初始化这个库，通过框架层（消息的客户端或事务 RPC 框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要直接访问这个库。</p> \n <p>总结起来，其实两种方式的根本原理是类似的，也就是<strong>将分布式事务转换为多个本地事务，然后依靠重试等方式达到最终一致性。</strong></p> \n <h3 id=\"4-蘑菇街交易创建过程中的分布式一致性方案\"><a href=\"#4-蘑菇街交易创建过程中的分布式一致性方案\" class=\"headerlink\" title=\"4. 蘑菇街交易创建过程中的分布式一致性方案\"></a>4. 蘑菇街交易创建过程中的分布式一致性方案</h3>\n <h4 id=\"交易创建的一般性流程\"><a href=\"#交易创建的一般性流程\" class=\"headerlink\" title=\"交易创建的一般性流程\"></a>交易创建的一般性流程</h4>\n <p>我们把交易创建流程抽象出一系列可扩展的功能点，每个功能点都可以有多个实现（具体的实现之间有组合/互斥关系）。把各个功能点按照一定流程串起来，就完成了交易创建的过程。 </p> \n <p><img src=\"/assets/006kbv1Jgw1f31xdryziuj30i008d0tu.jpg\" alt=\"\"></p> \n <h4 id=\"面临的问题\"><a href=\"#面临的问题\" class=\"headerlink\" title=\"面临的问题\"></a>面临的问题</h4>\n <p>每个功能点的实现都可能会依赖外部服务。那么如何保证各个服务之间的数据是一致的呢？比如锁定优惠券服务调用超时了，不能确定到底有没有锁券成功，该如何处理？再比如锁券成功了，但是扣减库存失败了，该如何处理？</p> \n <h4 id=\"方案选型\"><a href=\"#方案选型\" class=\"headerlink\" title=\"方案选型\"></a>方案选型</h4>\n <p>服务依赖过多，会带来管理复杂性增加和稳定性风险增大的问题。试想如果我们强依赖 10 个服务，9 个都执行成功了，最后一个执行失败了，那么是不是前面 9 个都要回滚掉？这个成本还是非常高的。</p> \n <p>所以在拆分大的流程为多个小的本地事务的前提下，对于非实时、非强一致性的关联业务写入，在本地事务执行成功后，我们选择发消息通知、关联事务异步化执行的方案。</p> \n <p><strong>消息通知往往不能保证 100% 成功；且消息通知后，接收方业务是否能执行成功还是未知数。前者问题可以通过重试解决；后者可以选用事务消息来保证。</strong></p> \n <p>但是事务消息框架本身会给业务代码带来侵入性和复杂性，所以我们选择<strong>基于 DB 事件变化通知到 MQ 的方式</strong>做系统间解耦，通过订阅方消费 MQ 消息时的 ACK 机制，保证消息一定消费成功，达到最终一致性。由于消息可能会被重发，消息订阅方业务逻辑处理要做好幂等保证。</p> \n <p>所以目前只剩下需要实时同步做、有强一致性要求的业务场景了。在交易创建过程中，锁券和扣减库存是这样的两个典型场景。</p> \n <p>要保证多个系统间数据一致，乍一看，必须要引入分布式事务框架才能解决。但引入非常重的类似二阶段提交分布式事务框架会带来复杂性的急剧上升；在电商领域，绝对的强一致是过于理想化的，我们可以选择准实时的最终一致性。</p> \n <p>我们在交易创建流程中，<strong>首先创建一个不可见订单</strong>，然后在同步调用锁券和扣减库存时，针对调用异常（失败或者超时），发出废单消息到MQ。如果消息发送失败，本地会做时间阶梯式的异步重试；优惠券系统和库存系统收到消息后，会进行判断是否需要做业务回滚，这样就准实时地保证了多个本地事务的最终一致性。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xeajfqkj30680i2wez.jpg\" alt=\"\"></p> \n <h3 id=\"5-支付宝及蚂蚁金融云的分布式服务-DTS-方案\"><a href=\"#5-支付宝及蚂蚁金融云的分布式服务-DTS-方案\" class=\"headerlink\" title=\"5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案\"></a>5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案</h3>\n <p>业界常用的还有支付宝的一种 xts 方案，由支付宝在 2PC 的基础上改进而来。主要思路如下，大部分信息引用自官方网站。</p> \n <h4 id=\"分布式事务服务简介\"><a href=\"#分布式事务服务简介\" class=\"headerlink\" title=\"分布式事务服务简介\"></a>分布式事务服务简介</h4>\n <p>分布式事务服务 (Distributed Transaction Service, DTS) 是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。DTS 从架构上分为 xts-client 和 xts-server 两部分，前者是一个嵌入客户端应用的 JAR 包，主要负责事务数据的写入和处理；后者是一个独立的系统，主要负责异常事务的恢复。</p> \n <h4 id=\"核心特性\"><a href=\"#核心特性\" class=\"headerlink\" title=\"核心特性\"></a>核心特性</h4>\n <p>传统关系型数据库的事务模型必须遵守 ACID 原则。在单数据库模式下，ACID 模型能有效保障数据的完整性，但是在大规模分布式环境下，一个业务往往会跨越多个数据库，如何保证这多个数据库之间的数据一致性，需要其他行之有效的策略。在 JavaEE 规范中使用 2PC (2 Phase Commit, 两阶段提交) 来处理跨 DB 环境下的事务问题，但是 2PC 是反可伸缩模式，也就是说，在事务处理过程中，参与者需要一直持有资源直到整个分布式事务结束。这样，当业务规模达到千万级以上时，2PC 的局限性就越来越明显，系统可伸缩性会变得很差。基于此，我们采用 BASE 的思想实现了一套类似 2PC 的分布式事务方案，这就是 DTS。DTS在充分保障分布式环境下高可用性、高可靠性的同时兼顾数据一致性的要求，其最大的特点是保证数据最终一致 (Eventually consistent)。</p> \n <p>简单的说，DTS 框架有如下特性：</p> \n <ul> \n  <li><p>最终一致：事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。</p> </li> \n  <li><p>协议简单：DTS 定义了类似 2PC 的标准两阶段接口，业务系统只需要实现对应的接口就可以使用 DTS 的事务功能。</p> </li> \n  <li><p>与 RPC 服务协议无关：在 SOA 架构下，一个或多个 DB 操作往往被包装成一个一个的 Service，Service 与 Service 之间通过 RPC 协议通信。DTS 框架构建在 SOA 架构上，与底层协议无关。</p> </li> \n  <li><p>与底层事务实现无关： DTS 是一个抽象的基于 Service 层的概念，与底层事务实现无关，也就是说在 DTS 的范围内，无论是关系型数据库 MySQL，Oracle，还是 KV 存储 MemCache，或者列存数据库 HBase，只要将对其的操作包装成 DTS 的参与者，就可以接入到 DTS 事务范围内。</p> </li> \n </ul> \n <p>以下是分布式事务框架的流程图</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xfuizhpj30a70b7q3x.jpg\" alt=\"\"></p> \n <h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4>\n <ul> \n  <li><p>一个完整的业务活动由一个主业务服务与若干从业务服务组成。</p> </li> \n  <li><p>主业务服务负责发起并完成整个业务活动。</p> </li> \n  <li><p>从业务服务提供 TCC 型业务操作。</p> </li> \n  <li><p>业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在活动提交时确认所有的两阶段事务的 confirm 操作，在业务活动取消时调用所有两阶段事务的 cancel 操作。”</p> </li> \n </ul> \n <h4 id=\"与-2PC-协议比较\"><a href=\"#与-2PC-协议比较\" class=\"headerlink\" title=\"与 2PC 协议比较\"></a>与 2PC 协议比较</h4>\n <ul> \n  <li><p>没有单独的 Prepare 阶段，降低协议成本</p> </li> \n  <li><p>系统故障容忍度高，恢复简单</p> </li> \n </ul> \n <h3 id=\"6-农信网数据一致性方案\"><a href=\"#6-农信网数据一致性方案\" class=\"headerlink\" title=\"6. 农信网数据一致性方案\"></a>6. 农信网数据一致性方案</h3>\n <h4 id=\"电商业务\"><a href=\"#电商业务\" class=\"headerlink\" title=\"电商业务\"></a>电商业务</h4>\n <p>公司的支付部门，通过接入其它第三方支付系统来提供支付服务给业务部门，支付服务是一个基于 Dubbo 的 RPC 服务。</p> \n <p>对于业务部门来说，电商部门的订单支付，需要调用</p> \n <ul> \n  <li><p>支付平台的支付接口来处理订单；</p> </li> \n  <li><p>同时需要调用积分中心的接口，按照业务规则，给用户增加积分。</p> </li> \n </ul> \n <p>从业务规则上需要同时保证业务数据的实时性和一致性，也就是支付成功必须加积分。</p> \n <p>我们采用的方式是同步调用，首先处理本地事务业务。考虑到积分业务比较单一且业务影响低于支付，由积分平台提供增加与回撤接口。</p> \n <p>具体的流程是先调用积分平台增加用户积分，再调用支付平台进行支付处理，如果处理失败，catch 方法调用积分平台的回撤方法，将本次处理的积分订单回撤。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xgmb4wrj30hl09rgmn.jpg\" alt=\"\"></p> \n <h4 id=\"用户信息变更\"><a href=\"#用户信息变更\" class=\"headerlink\" title=\"用户信息变更\"></a>用户信息变更</h4>\n <p>公司的用户信息，统一由用户中心维护，而用户信息的变更需要同步给各业务子系统，业务子系统再根据变更内容，处理各自业务。用户中心作为 MQ 的 producer，添加通知给 MQ。APP Server 订阅该消息，同步本地数据信息，再处理相关业务比如 APP 退出下线等。</p> \n <p>我们采用异步消息通知机制，目前主要使用 ActiveMQ，基于 Virtual Topic 的订阅方式，保证单个业务集群订阅的单次消费。</p> \n <p><img src=\"/assets/006kbv1Jgw1f31xhl94fyj30hu08qt9j.jpg\" alt=\"\"></p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>分布式服务对衍生的配套系统要求比较多，特别是我们基于消息、日志的最终一致性方案，需要考虑消息的积压、消费情况、监控、报警等。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(294,12,'微服务如何进行数据库管理',1,'www.funtl.com/assets/201705272.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"分布式数据管理之痛点\"><a href=\"#分布式数据管理之痛点\" class=\"headerlink\" title=\"分布式数据管理之痛点\"></a>分布式数据管理之痛点</h3>\n <p>为了确保微服务之间松耦合，每个服务都有自己的数据库, 有的是关系型数据库(SQL)，有的是非关系型数据库(NoSQL)。开发企业事务往往牵涉到多个服务，要想做到多个服务数据的一致性并非易事，同样，在多个服务之间进行数据查询也充满挑战。我们以一个在线 B2B 商店为例，客户服务包括了客户的各种信息，例如可用信用等。管理订单，提供订单服务，则需要验证某个新订单与客户的信用限制没有冲突。在单体应用中，订单服务只需要使用传统事务交易就可以一次性检查可用信用和创建订单。相反微服务架构下，订单和客户表分别是相应服务的私有表，如下图所示：</p> \n <p><img src=\"/assets/201705272.jpg\" alt=\"\"></p> \n <p>订单服务不能直接访问客户表，只能通过客户服务发布的 API 来访问或者使用分布式事务, 也就是众所周知的两阶段提交 (2PC)来访问客户表，2PC 意义图如下所示：</p> \n <p><img src=\"/assets/201705273.jpg\" alt=\"\"></p> \n <p>这里存在两个挑战：</p> \n <ol> \n  <li>第一个挑战是 2PC 除要求数据库本身支持外，还要求服务的数据库类型需要保持一致。但是现在的微服务架构中，每个服务的数据库类型可能是不一样的，有的可能是 MySQL 数据库，有的也可能是 NoSQL 数据库;</li> \n  <li>第二个挑战是如何实现从多个服务中查询数据。假设应用程序需要显示一个客户和他最近的订单。如果订单服务提供用于检索客户订单的 API，那么应用程序端可以通过 JOIN 方式来检索此数据，即应用程序首选从客户服务检索客户，并从订单服务检索客户的订单。然而，如果订单服务仅支持通过其主键查找订单(也许它使用仅支持基于主键的检索的 NoSQL 数据库)， 在这种情况下，就没有方法来检索查询所需的数据。</li> \n </ol> \n <p>为解决这两大痛点，就需要我们使用到分步式数据管理了。</p> \n <h3 id=\"分布式数据管理之举措\"><a href=\"#分布式数据管理之举措\" class=\"headerlink\" title=\"分布式数据管理之举措\"></a>分布式数据管理之举措</h3>\n <p>在介绍分布式数据管理(CRUD)解决方案之前，有必要介绍下 CAP 原理和最终一致性相关概念。</p> \n <h3 id=\"CAP-原理-CAP-Theorem\"><a href=\"#CAP-原理-CAP-Theorem\" class=\"headerlink\" title=\"CAP 原理(CAP Theorem)\"></a>CAP 原理(CAP Theorem)</h3>\n <p>在足球比赛里，一个球员在一场比赛中进三个球，称之为帽子戏法(Hat-trick)。在分布式数据系统中，也有一个帽子原理(CAP Theorem)，不过此帽子非彼帽子。CAP 原理中，有三个要素：</p> \n <p>1) 一致性(C onsistency)<br>2) 可用性(A vailability)<br>3) 分区容忍性(P artition tolerance)</p> \n <p>CAP 原理指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p> \n <p>因此在进行分布式架构设计时，必须做出取舍。而对于分布式数据系统，分区容忍性是基本要求 ，否则就失去了价值，因此设计分布式数据系统，就是在一致性和可用性之间取一个平衡。</p> \n <p>对于大多数 WEB 应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是目前多数分布式数据库产品的方向。</p> \n <p>当然，牺牲一致性，并不是完全不管数据的一致性，否则数据是混乱的，那么系统可用性再高分布式再好也没有了价值。</p> \n <p>牺牲一致性，只是不再要求关系型数 据库中的强一致性，而是只要系统能达到最终一致性即可，考虑到客户体验，这个最终一致的时间窗口，要尽可能的对用户透明，也就是需要保障“用户感知到的一致性”。</p> \n <p>通常是通过数据的多份异步复制来实现系统的高可用和数据的最终一致性的，“用户感知到的一致性”的时间窗口则 取决于数据复制到一致状态的时间。</p> \n <h3 id=\"最终一致性-eventually-consistent\"><a href=\"#最终一致性-eventually-consistent\" class=\"headerlink\" title=\"最终一致性(eventually consistent)\"></a>最终一致性(eventually consistent)</h3>\n <p>对于一致性，可以分为从客户端和服务端两个不同的视角。</p> \n <p>从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。</p> \n <p>从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。</p> \n <p>一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p> \n <p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</p> \n <p>对于关系型数据库，要求更新过的数据能被后续的 访问都能看到，这是强一致性 ;如果能容忍后续的部分或者全部访问不到，则是弱一致性 ; 如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p> \n <p>从服务端角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。</p> \n <p>那么问题来了，如何实现数据的最终一致性呢?答案就在事件驱动架构。</p> \n <h3 id=\"事件驱动架构简介\"><a href=\"#事件驱动架构简介\" class=\"headerlink\" title=\"事件驱动架构简介\"></a>事件驱动架构简介</h3>\n <p>Chris Richardson 作为微服务架构设计领域的权威，给出了分布式数据管理的最佳解决方案。</p> \n <p>对于大多数应用而言，要实现微服务的分布式数据管理，需要采用事件驱动架构(event-driven architecture)。</p> \n <p>在事件驱动架构中，当某件重要事情发生时，微服务会发布一个事件，例如更新一个业务实体。</p> \n <p>当订阅这些事件的微服务接收此事件时，就可以更新自己的业务实体，也可能会引发更多的事件发布，让其他相关服务进行数据更新，最终实现分布式数据最终一致性。</p> \n <p>可以使用事件来实现跨多服务的业务交易。交易一般由一系列步骤构成，每一步骤都由一个更新业务实体的微服务和发布激活下一步骤的事件构成。</p> \n <h4 id=\"事件驱动示例-1\"><a href=\"#事件驱动示例-1\" class=\"headerlink\" title=\"事件驱动示例 1\"></a>事件驱动示例 1</h4>\n <p>下图展现如何使用事件驱动方法，在创建订单时检查信用可用度，微服务之间通过消息代理(Messsage Broker)来交换事件。</p> \n <ul> \n  <li>订单服务创建一个带有 NEW 状态的 Order (订单)，发布了一个“Order Created Event(创建订单)”的事件。</li> \n </ul> \n <p><img src=\"/assets/201705274.jpg\" alt=\"\"></p> \n <ul> \n  <li>客户服务消费 Order Created Event 事件，为此订单预留信用，发布“Credit Reserved Event(信用预留)”事件。</li> \n </ul> \n <p><img src=\"/assets/201705275.jpg\" alt=\"\"></p> \n <ul> \n  <li>订单服务消费 Credit Reserved Event，改变订单的状态为 OPEN。</li> \n </ul> \n <p><img src=\"/assets/201705276.jpg\" alt=\"\"></p> \n <h4 id=\"事件驱动示例-2\"><a href=\"#事件驱动示例-2\" class=\"headerlink\" title=\"事件驱动示例 2\"></a>事件驱动示例 2</h4>\n <p>下图展现如何使用事件驱动方法，在创建订单时触发支付业务的数据更新，微服务之间通过消息代理(Messsage Broker)来交换事件。</p> \n <ul> \n  <li>订单服务创建一个待支付的订单，发布一个“创建订单”的事件。</li> \n </ul> \n <p><img src=\"/assets/201705277.jpg\" alt=\"\"></p> \n <ul> \n  <li>支付服务消费“创建订单”事件，支付完成后发布一个“支付完成”事件。</li> \n </ul> \n <p><img src=\"/assets/201705278.jpg\" alt=\"\"></p> \n <ul> \n  <li>订单服务消费“支付完成”事件，订单状态更新为待出库。</li> \n </ul> \n <p><img src=\"/assets/201705279.jpg\" alt=\"\"></p> \n <h3 id=\"事件驱动架构之分布式数据更新\"><a href=\"#事件驱动架构之分布式数据更新\" class=\"headerlink\" title=\"事件驱动架构之分布式数据更新\"></a>事件驱动架构之分布式数据更新</h3>\n <p>上节通过示例概要介绍了通过事件驱动方式，实现了分布式数据最终一致性保证。纵观微服务架构下的事件驱动业务处理逻辑，其核心要点在于，可靠的事件投递和避免事件的重复消费。</p> \n <p>可靠事件投递有以下两个特性：</p> \n <p>1) 每个服务原子性的完成业务操作和发布事件;<br>2) 消息代理确保事件投递至少一次(at least once);</p> \n <p>而避免事件重复消费则要求消费事件的服务实现幂等性，比如支付服务不能因为重复收到事件而多次支付。</p> \n <p>BTW：当前流行的消息队列如Kafka等，都已经实现了事件的持久化和at least once的投递模式，所以可靠事件投递的第二条特性已经满足，这里就不展开。接下来章节讲重点讲述如何实现可靠事件投递的第一条特性和避免事件重复消费，即服务的业务操作和发布事件的原子性和避免消费者重复消费事件要求服务实现幂等性。</p> \n <h4 id=\"如何实现事件投递操作原子性\"><a href=\"#如何实现事件投递操作原子性\" class=\"headerlink\" title=\"如何实现事件投递操作原子性?\"></a>如何实现事件投递操作原子性?</h4>\n <p>事件驱动架构会碰到数据库更新和发布事件原子性问题。例如，订单服务必须向 ORDER 表插入一行，然后发布 Order Created event，这两个操作需要原子性。比如更新数据库后，服务瘫了(crashes)造成事件未能发布，系统变成不一致状态。那么如何实现服务的业务操作和发布事件的原子性呢?</p> \n <ul> \n  <li><strong>使用本地事务发布事件</strong></li> \n </ul> \n <p>获得原子性的一个方法是将服务的业务操作和发布事件放在一个本地数据库事务里，也就是说，需要在本地建立一个 EVENT 表，此表在存储业务实体数据库中起到消息列表功能。当应用发起一个(本地)数据库交易，更新业务实体状态时，会向 EVENT 表中插入一个事件，然后提交此次交易。另外一个独立应用进程或者线程查询此 EVENT 表，向消息代理发布事件，然后使用本地交易标志此事件为已发布，如下图所示：</p> \n <p><img src=\"/assets/2017052710.jpg\" alt=\"\"></p> \n <p>订单服务向 ORDER 表插入一行，然后向 EVENT 表中插入 Order Created event，事件发布线程或者进程查询 EVENT 表，请求未发布事件，发布他们，然后更新 EVENT 表标志此事件为已发布。</p> \n <p>此方法也是优缺点都有。优点是可以确保事件发布不依赖于 2PC，应用发布业务层级事件而不需要推断他们发生了什么;而缺点在于此方法由于开发人员必须牢记发布事件，因此有可能出现错误。</p> \n <ul> \n  <li><strong>使用事件源</strong></li> \n </ul> \n <p>Event sourcing (事件源)通过使用以事件中心的数据存储方式来保证业务实体的一致性。事件源保存了每个业务实体所有状态变化的事件，而不是存储实体当前的状态。应用可以通过重放事件来重建实体现在的状态。只要业务实体发生变化，新事件就会添加到事件表中。因为保存事件是单一操作，因此肯定是原子性的。</p> \n <p>为了理解事件源工作方式，考虑以事件实体作为一个例子说明。传统方式中，每个订单映射为 ORDER 表中一行。但是对于事件源方式，订单服务以事件状态改变方式存储一个订单：创建的，已批准的，已发货的，取消的;每个事件包括足够信息来重建订单的状态。</p> \n <p><img src=\"/assets/2017052711.jpg\" alt=\"\"></p> \n <p>事件源方法有很多优点：解决了事件驱动架构关键问题，使得业务实体更新和事件发布原子化，但是也存在缺点，因为是持久化事件而不是对象，导致数据查询时，必须使用 Command Query Responsibility Segregation (CQRS) 来完成查询业务，从开发角度看，存在一定挑战。</p> \n <h4 id=\"如何避免事件重复消费\"><a href=\"#如何避免事件重复消费\" class=\"headerlink\" title=\"如何避免事件重复消费?\"></a>如何避免事件重复消费?</h4>\n <p>要避免事件重复消费，需要消费事件的服务实现服务幂等，因为存在重试和错误补偿机制，不可避免的在系统中存在重复收到消息的场景，服务幂等能提高数据的一致性。在编程中,一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同，因此需要开发人员在功能设计实现时，需要特别注意服务的幂等性。</p> \n <h3 id=\"事件驱动架构之分布式数据查询\"><a href=\"#事件驱动架构之分布式数据查询\" class=\"headerlink\" title=\"事件驱动架构之分布式数据查询\"></a>事件驱动架构之分布式数据查询</h3>\n <p>微服务架构下，由于分布式数据库的存在，导致在执行用户业务数据查询时，通常需要跨多个微服务数据库进行数据查询，也就是分布式数据查询。那么问题来了，由于每个微服务的数据都是私有化的，只能通过各自的REST接口获取，如果负责业务查询的功能模块，通过调用各个微服务的REST接口来分别获取基础数据，然后在内存中再进行业务数据拼装后，再返回给用户。该方法无论从程序设计或是查询性能角度看，都不是一个很好的方法。那么如何解决微服务架构下的分布式数据查询问题呢? 在给出解决方案之前，需要读者首先了解下物化视图和命令查询职责分离等相关概念。</p> \n <h4 id=\"什么是物化视图-merialized-views\"><a href=\"#什么是物化视图-merialized-views\" class=\"headerlink\" title=\"什么是物化视图(merialized views)?\"></a>什么是物化视图(merialized views)?</h4>\n <p>物化视图是包括一个查询结果的数据库对像，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照。这个基本上就说出了物化视图的本质，它是一组查询的结果，这样势必为将来再次需要这组数据时大大提高查询性能。物化视图有两种刷新模式 ON DEMAND 和 ON COMMIT，用户可根据实际情况进行设置。</p> \n <p>物化视图对于应用层是透明的，不需要有任何的改动，终端用户甚至都感觉不到底层是用的物化视图。总之，使用物化视图的目的一个是提高查询性能，另一个是由于物化视图包含的数据是远程数据库的数据快照或拷贝，微服务可通过物化视图和命令查询职责分离(CQRS)技术(参见以下章节)实现分布式数据查询。</p> \n <h4 id=\"什么是命令查询职责分离-CQRS\"><a href=\"#什么是命令查询职责分离-CQRS\" class=\"headerlink\" title=\"什么是命令查询职责分离(CQRS)?\"></a>什么是命令查询职责分离(CQRS)?</h4>\n <p>在常用的单体应用架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题;另外更重要的是，在微服务架构下，通常需要跨多个微服务数据库来查询数据，此时，我们可借助命令查询职责分离(CQRS)来有效解决这些问题。</p> \n <p>CQRS 使用分离的接口将数据查询操作(Queries)和数据修改操作(Commands)分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了。使用 CQRS 分离了读写职责之后，可以对数据进行读写分离操作来改进性能，同时提高可扩展性和安全。如下图：</p> \n <p><img src=\"/assets/2017052712.jpg\" alt=\"\"></p> \n <p>主数据库处理 CUD，从库处理 R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成 ReportingDatabase，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。</p> \n <p><img src=\"/assets/2017052713.jpg\" alt=\"\"></p> \n <p>使用 ReportingDatabase 的一些优点通常可以使得查询变得更加简单高效：</p> \n <ul> \n  <li>ReportingDatabase 的结构和数据表会针对常用的查询请求进行设计。</li> \n  <li>ReportingDatabase 数据库通常会去正规化，存储一些冗余而减少必要的 Join 等联合查询操作，使得查询简化和高效，一些在主数据库中用不到的数据信息，在 ReportingDatabase 可以不用存储。</li> \n  <li>可以对 ReportingDatabase 重构优化，而不用去改变操作数据库。</li> \n  <li>对 ReportingDatabase 数据库的查询不会给操作数据库带来任何压力。</li> \n  <li>可以针对不同的查询请求建立不同的 ReportingDatabase 库。</li> \n </ul> \n <h4 id=\"如何实现事件驱动架构下的数据查询服务\"><a href=\"#如何实现事件驱动架构下的数据查询服务\" class=\"headerlink\" title=\"如何实现事件驱动架构下的数据查询服务?\"></a>如何实现事件驱动架构下的数据查询服务?</h4>\n <p>事件驱动不仅可以用于分布式数据一致性保证，还可以借助物化视图和命令查询职责分离技术，使用事件来维护不同微服务拥有数据预连接(pre-join)的物化视图，从而实现微服务架构下的分布式数据查询。维护物化视图的服务订阅了相关事件并在事件发生时更新物化视图。例如，客户订单视图更新服务(维护客户订单视图)会订阅由客户服务和订单服务发布的事件(您还可以使用事件来维护由多个微服务拥有的数据组成的物化视图。</p> \n <p><img src=\"/assets/2017052714.jpg\" alt=\"\"></p> \n <p>例如上图中间的 “客户订单视图更新”服务，主要负责客户订单视图的更新。该服务订阅了客户服务和订单服务发布的事件。当“客户订单视图更新”服务收到了上图左侧的客户或者订单更新事件，则会触发更新客户订单物化视图数据集。这里可以使用文档数据库(例如 MongoDB )来实现客户订单视图，为每个用户存储一个文档。而上图右侧的客户订单视图查询服务负责响应对客户以及最近订单(通过查询客户订单视图数据集)的查询。</p> \n <p>总之，上图所示业务逻辑，用到了事件驱动、物化视图和命令查询职责分离等技术，有效解决了微服务架构下分布式数据查询的问题。</p> \n <h3 id=\"事件驱动架构优缺点\"><a href=\"#事件驱动架构优缺点\" class=\"headerlink\" title=\"事件驱动架构优缺点\"></a>事件驱动架构优缺点</h3>\n <p>事件驱动架构既有优点也有缺点，此架构可以实现跨多个服务的事务实现，且提供最终数据一致性，并且使得服务能够自动维护查询视图;而缺点在于编程模式比传统基于事务的交易模式更加复杂，必须实现补偿事务以便从应用程序级故障中恢复，例如，如果信用检查不成功则必须取消订单;另外，应用必须应对不一致的数据，比如当应用读取未更新的最终视图时也会遇见数据不一致问题。另外一个缺点在于订阅者必须检测和忽略冗余事件，避免事件重复消费。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>在微服务架构中，每个微服务都有自己私有的数据集。不同微服务可能使用不同的SQL或者NoSQL数据库。尽管数据库架构有很强的优势，但是也面对数据分布式管理的挑战。第一个挑战就是如何在多服务之间维护业务数据一致性;第二个挑战是如何从多服务环境中获取一致性数据。</p> \n <p>最佳解决办法是采用事件驱动架构。其中碰到的一个挑战是如何原子性的更新状态和发布事件。有几种方法可以解决此问题，包括将数据库视为消息队列和事件源等。</p> \n <p>从目前技术应用范围和成熟度看，推荐使用第一种方式(本地事务发布事件)，来实现事件投递原子化，即可靠事件投递。</p> \n <h3 id=\"重要提醒\"><a href=\"#重要提醒\" class=\"headerlink\" title=\"重要提醒\"></a>重要提醒</h3>\n <p>数据一致性是微服务架构设计中唯恐避之不及却又不得不考虑的话题。通过保证事件驱动实现最终数据的一致性，此方案的优劣，也不能简单的一言而概之，而是应该根据场景定夺，适合的才是最好的。另外，我们在对微服务进行业务划分的时候就尽可能的避免“可能会产生一致性问题”的设计。如果这种设计过多，也许是时候考虑改改设计了。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(295,12,'如何应对微服务的链式调用异常',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>一般情况下，每个微服务之间是独立的，如果某个服务宕机，只会影响到当前服务，而不会对整个业务系统产生影响。但是，服务端可能会在多个微服务之间产生一条链式调用，并把整合后的信息返回给客户端。在调用过程中，如果某个服务宕机或者网络不稳定可能造成整个请求失败。因此，为了应对微服务的链式调用异常，我们需要在设计微服务调用链时不宜过长，以免客户端长时间等待，以及中间环节出现错误造成整个请求失败。此外，可以考虑使用消息队列进行业务解耦，并且使用缓存避免微服务的链式调用从而提高该接口的可用性。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(296,12,'谈谈业务中使用分布式的场景',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>首先，需要了解系统为什么使用分布式。</p> \n <p>随着互联网的发展，传统单工程项目的很多性能瓶颈越发凸显，性能瓶颈可以有几个方面：</p> \n <ol> \n  <li>应用服务层：随着用户量的增加，并发量增加，单项目难以承受如此大的并发请求导致的性能瓶颈。</li> \n  <li>底层数据库层：随着业务的发展，数据库压力越来越大，导致的性能瓶颈。</li> \n </ol> \n <h3 id=\"场景1：应用系统集群的-Session-共享\"><a href=\"#场景1：应用系统集群的-Session-共享\" class=\"headerlink\" title=\"场景1：应用系统集群的 Session 共享\"></a>场景1：应用系统集群的 Session 共享</h3>\n <p>应用系统集群最简单的就是服务器集群，比如：Tomcat 集群。应用系统集群的时候，比较凸显的问题是 Session 共享，Session 共享我们一是可以通过服务器插件来解决。另外一种也可以通过 Redis 等中间件实现。</p> \n <h3 id=\"场景2：应用系统的服务化拆分\"><a href=\"#场景2：应用系统的服务化拆分\" class=\"headerlink\" title=\"场景2：应用系统的服务化拆分\"></a>场景2：应用系统的服务化拆分</h3>\n <p>服务化拆分，是目前非常火热的一种方式。现在都在提微服务。通过对传统项目进行服务化拆分，达到服务独立解耦，单服务又可以横向扩容。服务化拆分遇到的经典问题就是分布式事务问题。目前，比较常用的分布式事务解决方案有几种：消息最终一致性、TCC 补偿型事务等。</p> \n <h3 id=\"场景3：底层数据库的压力分摊\"><a href=\"#场景3：底层数据库的压力分摊\" class=\"headerlink\" title=\"场景3：底层数据库的压力分摊\"></a>场景3：底层数据库的压力分摊</h3>\n <p>如果系统的性能压力出现在数据库，那我们就可以读写分离、分库分表等方案进行解决。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(297,12,'微服务的安全',1,'www.funtl.com/assets/201804100306001.png',1,'<div class=\"col-sm-12\"> \n <p>OAuth 是一个关于授权的开放网络标准，它允许第三方网站在用户授权的前提下访问用户在服务商那里存储的各种信息。实际上，OAuth 2.0 允许用户提供一个令牌给第三方网站，一个令牌对应一个特定的第三方网站，同时该令牌只能在特定的时间内访问特定的资源。用户在客户端使用用户名和密码在用户中心获得授权，然后客户端在访问应用是附上 Token 令牌。此时，应用接收到客户端的 Token 令牌到用户中心进行认证。</p> \n <p><img src=\"/assets/201804100306001.png\" alt=\"\"></p> \n <p>一般情况下，access token 会添加到 HTTP Header 的 Authorization 参数中使用，其中经常使用到的是 Bearer Token 与 Mac Token。其中，Bearer Token 适用于安全的网络下 API 授权。MAC Token 适用于不安全的网络下 API 授权。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:02','2018-12-20 22:06:02'),
(298,12,'Session 分布式方案',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"基于-nfs-net-filesystem-的-Session-共享\"><a href=\"#基于-nfs-net-filesystem-的-Session-共享\" class=\"headerlink\" title=\"基于 nfs(net filesystem) 的 Session 共享\"></a>基于 nfs(net filesystem) 的 Session 共享</h3>\n <p>将共享服务器目录 mount 各服务器的本地 session 目录，session 读写受共享服务器 io 限制，<strong>不能满足高并发</strong>。</p> \n <h3 id=\"基于关系数据库的-Session-共享\"><a href=\"#基于关系数据库的-Session-共享\" class=\"headerlink\" title=\"基于关系数据库的 Session 共享\"></a>基于关系数据库的 Session 共享</h3>\n <p>这种方案普遍使用。使用关系数据库存储 session 数据，对于 mysql 数据库，建议使用 heap 引擎。这种方案性能取决于数据库的性能，在高并发下容易造成表锁（虽然可以采用行锁的存储引擎，性能会下降），并且需要自己实现 session 过期淘汰机制。</p> \n <h3 id=\"基于-Cookie-的-Session-共享\"><a href=\"#基于-Cookie-的-Session-共享\" class=\"headerlink\" title=\"基于 Cookie 的 Session 共享\"></a>基于 Cookie 的 Session 共享</h3>\n <p>这种方案也在大型互联网中普遍使用，将用户的 session 加密序列化后以 cookie 的方式保存在网站根域名下（比如 taobao.com），当用户访问所有二级域名站点式，浏览器会传递所有匹配的根域名的 cookie 信息，这样实现了用户 cookie 化 session 的多服务共享。此方案能够节省大量服务器资源，缺点是存储的信息长度受到 http 协议限制；cookie 的信息还需要做加密解密；请求任何资源时都会将 cookie 附加到 http 头上传到服务器，占用了一定带宽。</p> \n <h3 id=\"基于-Web-容器的-Session-机制\"><a href=\"#基于-Web-容器的-Session-机制\" class=\"headerlink\" title=\"基于 Web 容器的 Session 机制\"></a>基于 Web 容器的 Session 机制</h3>\n <p>利用容器机制，通过配置即可实现。</p> \n <h3 id=\"基于-Zookeeper-的分布式-Session-存储\"><a href=\"#基于-Zookeeper-的分布式-Session-存储\" class=\"headerlink\" title=\"基于 Zookeeper 的分布式 Session 存储\"></a>基于 Zookeeper 的分布式 Session 存储</h3>\n <h3 id=\"基于-Redis-Memcached-的-Session-共享存储\"><a href=\"#基于-Redis-Memcached-的-Session-共享存储\" class=\"headerlink\" title=\"基于 Redis/Memcached 的 Session 共享存储\"></a>基于 Redis/Memcached 的 Session 共享存储</h3>\n <p>这些 key/value 非关系存储有较高的性能，轻松达到 2000 左右的 qps，内置的过期机制正好满足 session 的自动实效特性。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(299,12,'分布式事务',1,'www.funtl.com/assets/success.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"分布式一致性\"><a href=\"#分布式一致性\" class=\"headerlink\" title=\"分布式一致性\"></a>分布式一致性</h3>\n <p>在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的 CRUD 等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。</p> \n <p>为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有<strong>二阶提交协议（Two Phase Commitment Protocol）</strong>、<strong>三阶提交协议（Three Phase Commitment Protocol）</strong> 和 <strong>Paxos 算法</strong>。</p> \n <h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3>\n <blockquote> \n  <p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p> \n </blockquote> \n <p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足 ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该 commit 还是 rollback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。</p> \n <h3 id=\"XA-规范\"><a href=\"#XA-规范\" class=\"headerlink\" title=\"XA 规范\"></a>XA 规范</h3>\n <p>X/Open 组织（即现在的 Open Group ）定义了分布式事务处理模型。 X/Open DTP 模型（ 1994 ）包括应用程序（ AP ）、事务管理器（ TM ）、资源管理器（ RM ）、通信资源管理器（ CRM ）四部分。一般，常见的事务管理器（ TM ）是交易中间件，常见的资源管理器（ RM ）是数据库，常见的通信资源管理器（ CRM ）是消息中间件。 通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。 所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务，例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。 一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。</p> \n <blockquote> \n  <p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。 </p> \n </blockquote> \n <p>二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现 XA 分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)</p> \n <h3 id=\"2PC\"><a href=\"#2PC\" class=\"headerlink\" title=\"2PC\"></a>2PC</h3>\n <blockquote> \n  <p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p> \n </blockquote> \n <p>所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)</strong> 和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p> \n <h4 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h4>\n <p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一种“万事俱备，只欠东风”的状态。</p> \n <p>可以进一步将准备阶段分为以下三个步骤：</p> \n <ol> \n  <li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li> \n  <li>参与者节点执行询问发起为止的所有事务操作，并将 Undo 信息和 Redo 信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li> \n  <li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li> \n </ol> \n <h4 id=\"提交阶段\"><a href=\"#提交阶段\" class=\"headerlink\" title=\"提交阶段\"></a>提交阶段</h4>\n <p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚( Rollback )消息；否则，发送提交( Commit )消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p> \n <p>接下来分两种情况分别讨论提交阶段的过程。</p> \n <p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：</p> \n <p><img src=\"/assets/success.png\" alt=\"\"></p> \n <ol> \n  <li>协调者节点向所有参与者节点发出”正式提交( commit )”的请求。</li> \n  <li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li> \n  <li>参与者节点向协调者节点发送”完成”消息。</li> \n  <li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li> \n </ol> \n <p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p> \n <p><img src=\"/assets/fail.png\" alt=\"\"></p> \n <ol> \n  <li>协调者节点向所有参与者节点发出”回滚操作( rollback )”的请求。</li> \n  <li>参与者节点利用之前写入的 Undo 信息执行回滚，并释放在整个事务期间内占用的资源。</li> \n  <li>参与者节点向协调者节点发送”回滚完成”消息。</li> \n  <li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li> \n </ol> \n <p><strong>不管最后结果如何，第二阶段都会结束当前事务。</strong></p> \n <p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个<strong>缺点</strong>的：</p> \n <ol> \n  <li><strong>同步阻塞问题</strong>：执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li> \n  <li><strong>单点故障</strong>：由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li> \n  <li><strong>数据不一致</strong>：在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异常或者在发送 commit 请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了 commit 请求。而在这部分参与者接到 commit 请求之后就会执行 commit 操作。但是其他部分未接到 commit 请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li> \n  <li>二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li> \n </ol> \n <p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p> \n <h3 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h3>\n <blockquote> \n  <p>三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。</p> \n </blockquote> \n <p><img src=\"/assets/3pccommit.png\" alt=\"\"></p> \n <p>与两阶段提交不同的是，三阶段提交有两个改动点。</p> \n <ol> \n  <li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li> \n  <li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li> \n </ol> \n <p>也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 <code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code> 三个阶段。</p> \n <h4 id=\"CanCommit-阶段\"><a href=\"#CanCommit-阶段\" class=\"headerlink\" title=\"CanCommit 阶段\"></a>CanCommit 阶段</h4>\n <p>3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p> \n <ol> \n  <li><strong>事务询问</strong>：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</li> \n  <li><strong>响应反馈</strong>：参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</li> \n </ol> \n <h4 id=\"PreCommit-阶段\"><a href=\"#PreCommit-阶段\" class=\"headerlink\" title=\"PreCommit 阶段\"></a>PreCommit 阶段</h4>\n <p>协调者根据参与者的反应情况来决定是否可以记性事务的 PreCommit 操作。根据响应情况，有以下两种可能。</p> \n <p><strong>1. 假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。</strong></p> \n <ul> \n  <li>发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。</li> \n  <li>事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。</li> \n  <li>响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</li> \n </ul> \n <p><strong>2. 假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p> \n <ul> \n  <li>发送中断请求：协调者向所有参与者发送 abort 请求。</li> \n  <li>中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li> \n </ul> \n <h4 id=\"doCommit-阶段\"><a href=\"#doCommit-阶段\" class=\"headerlink\" title=\"doCommit 阶段\"></a>doCommit 阶段</h4>\n <p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p> \n <p><strong>1. 执行提交</strong></p> \n <ul> \n  <li>发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。</li> \n  <li>事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</li> \n  <li>响应反馈：事务提交完之后，向协调者发送 ACK 响应。</li> \n  <li>完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。</li> \n </ul> \n <p><strong>2. 中断事务</strong></p> \n <p>协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。</p> \n <ul> \n  <li>发送中断请求：协调者向所有参与者发送 abort 请求</li> \n  <li>事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</li> \n  <li>反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息</li> \n  <li>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</li> \n </ul> \n <blockquote> \n  <p>在 <code>doCommit</code> 阶段，如果参与者无法及时接收到来自协调者的 <code>doCommit</code> 或者 <code>abort</code> 请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了 <code>PreCommit</code> 请求，那么协调者产生 <code>PreCommit</code> 请求的前提条件是他在第二阶段开始之前，收到所有参与者的 <code>CanCommit</code> 响应都是 <code>Yes</code>。（一旦参与者收到了 <code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到 <code>commit</code> 或者 <code>abort</code> 响应，但是他有理由相信：成功提交的几率很大。）</p> \n </blockquote> \n <h3 id=\"2PC-与-3PC-的区别\"><a href=\"#2PC-与-3PC-的区别\" class=\"headerlink\" title=\"2PC 与 3PC 的区别\"></a>2PC 与 3PC 的区别</h3>\n <p>相对于 2PC，3PC 主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行 commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的 abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 commit 操作。这样就和其他接到 abort 命令并执行回滚的参与者之间存在数据不一致的情况。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(300,12,'集群与负载均衡的算法与实现',1,'www.funtl.com/assets/e58ab31f70ef56e074051ed24fa4e56ec19decce.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3>\n <p>什么是负载均衡呢？用户输入的流量通过负载均衡器按照某种负载均衡算法把流量均匀的分散到后端的多个服务器上，接收到请求的服务器可以独立的响应请求，达到负载分担的目的。从应用场景上来说，常见的负载均衡模型有全局负载均衡和集群内负载均衡，从产品形态角度来说，又可以分为硬件负载均衡和软件负载均衡。全局负载均衡一般通过DNS实现，通过将一个域名解析到不同VIP，来实现不同的region调度能力；硬件负载均衡器常见的有F5、A10、Array，它们的优缺点都比较明显，优点是功能强大，有专门的售后服务团队，性能比较好，缺点是缺少定制的灵活性，维护成本较高；现在的互联网更多的思路是通过软件负载均衡来实现，这样可以满足各种定制化需求，常见的软件负载均衡有 LVS、Nginx、Haproxy。</p> \n <p><img src=\"/assets/e58ab31f70ef56e074051ed24fa4e56ec19decce.png\" alt=\"\"></p> \n <p>阿里云高性能负载均衡使用 LVS 和 Tengine，我们在一个 region 区分不同的机房,每个机房都有 LVS 集群和 Tengine 集群，对于用户配置的四层监听，LVS 后面会直接挂载用户 ECS，七层用户监听 ECS 则挂载在 Tengine 上，四层监听的流量直接由 LVS 转发到 ECS，而 7 层监听的流量会经过 LVS 到 Tenigine 再到用户 ECS。每一个 region 里都会有多个可用区，达到主备容灾目的，每一个集群里都有多台设备，第一是为了提升性能，第二也是基于容灾考虑。</p> \n <p><img src=\"/assets/fc98cdbdb5e1c6f3f2bba08642b14aa5b95191cb.png\" alt=\"\"></p> \n <p>图为高性能负载均衡控制管理概要图，SLB 产品也有 SDN 概念，转发和控制是分离的，用户所有配置通过控制台先到控制器，通过集中控制器转换将用户配置推送到不同设备上，每台设备上都有 Agent 接收控制器下发的需求，通过本地转换成 LVS 和 Tengine 能够识别的配置，这个过程支持热配置，不影响用户转发，不需要 reload 才能使新配置生效。</p> \n <h3 id=\"LVS\"><a href=\"#LVS\" class=\"headerlink\" title=\"LVS\"></a>LVS</h3>\n <h4 id=\"LVS-支持的三种模式\"><a href=\"#LVS-支持的三种模式\" class=\"headerlink\" title=\"LVS 支持的三种模式\"></a>LVS 支持的三种模式</h4>\n <p><img src=\"/assets/bc742829577c79b6040b743e07d176e8d815e512.png\" alt=\"\"></p> \n <p>早期 LVS 支持三种模式，<strong>DR 模式</strong>、<strong>TUN 模式</strong>和 <strong>NAT 模式</strong>。</p> \n <h5 id=\"DR-模式\"><a href=\"#DR-模式\" class=\"headerlink\" title=\"DR 模式\"></a>DR 模式</h5>\n <p>DR 模式经过 LVS 之后，LVS 会将 MAC 地址更改、封装 MAC 头，内层 IP 报文不动，报文经过 LVS 负载均衡查找到 RS 之后，将源 MAC 头改成自己的，目的 MAC 改成 RS 地址，MAC 寻址是在二层网络里，对网络部署有一定的限定，在大规模分布式集群部署里，这种模式的灵活性没有办法满足需求；</p> \n <h5 id=\"TUN-模式\"><a href=\"#TUN-模式\" class=\"headerlink\" title=\"TUN 模式\"></a>TUN 模式</h5>\n <p>TUN 模式走在 LVS 之后，LVS 会在原有报文基础上封装 IP 头，到了后端 RS 之后，RS 需要解开 IP 报文封装，才能拿到原始报文，不管是 DR 模式还是 TUN 模式，后端 RS 都可以看到真实客户源 IP，目的 IP 是自己的 VIP，VIP 在 RS 设备上需要配置，这样可以直接绕过 LVS 返回给用户，TUN 模式问题在于需要在后端 ECS 上配置解封装模块，在 Linux 上已经支持这种模块，但是 Windows 上还没有提供支持，所以会对用户系统镜像选择有限定。</p> \n <h5 id=\"NAT-模式\"><a href=\"#NAT-模式\" class=\"headerlink\" title=\"NAT 模式\"></a>NAT 模式</h5>\n <p>NAT 模式用户访问的是 VIP，LVS 查找完后会将目的 IP 做 DNAT 转换，选择出 RS 地址，因为客户端的 IP 没变，在回包的时候直接向公网真实客户端 IP 去路由，NAT 的约束是因为 LVS 做了 DNAT 转换，所以回包需要走 LVS，把报文头转换回去，由于 ECS 看到的是客户端真实的源地址，我们需要在用户 ECS 上配置路由，将到 ECS 的默认路由指向 LVS 上，这对用户场景也做了限制。</p> \n <h4 id=\"LVS-基于-NetFilter-框架实现\"><a href=\"#LVS-基于-NetFilter-框架实现\" class=\"headerlink\" title=\"LVS 基于 NetFilter 框架实现\"></a>LVS 基于 NetFilter 框架实现</h4>\n <p><img src=\"/assets/43e30887518af02f3c95557141b905fabeec779f.png\" alt=\"\"></p> \n <p>NetFilter 是 Linux 提供的网络开放平台，基于平台可以开发自己的业务功能模块，早期好多安全厂商都是基于 NetFilter 做一些业务模型实现，这种模型比较灵活，但通用模型里更多的是兼容性考虑，路径会非常长；而且通用模型中没办法发挥多核特性，目前 CPU 的发展更多是向横向扩展，我们经常见到多路服务器，每路上有多少核，早期通用模型对多核支持并不是特别友善，在多核设计上有些欠缺，导致我们在通用模型上做一些应用开发时的扩展性是有限的，随着核的数量越来越多，性能不增反降。</p> \n <h4 id=\"LVS-的改进\"><a href=\"#LVS-的改进\" class=\"headerlink\" title=\"LVS 的改进\"></a>LVS 的改进</h4>\n <p><img src=\"/assets/f2111dd6c11e8dd6ffb32a4a2156361d461e0ebf.png\" alt=\"\"></p> \n <p>早期模式的各种限制制约了我们的发展，所以我们首先做了 FullNAT，相比原来的 NAT 方式，FullNAT 多了 SNAT 属性，将客户端的原 IP 地址作了转换；其次，我们在并行化上做了处理，充分利用多核实现性能线性提升；然后是快速路径，我们在做网络转发模型时很容易想到设计快速路径和慢速路径，慢速路径更多是解决首包如何通过设备问题，可能需要查ACL或路由，需要判断许多和策略相关的东西，后面所有报文都可以通过快速路径转发出去；还有指令相关优化，利用因特尔特殊指令提升性能；另外针对多核架构，NUMA 多节点内存访问，通过访问 Local 节点内存可能获得更好的延迟表现。</p> \n <p><img src=\"/assets/b8d1657ff0cfc1ff091443c345a3a7da1f602150.png\" alt=\"\"></p> \n <p>客户端进来 IP 首先访问 LVS 的 VIP，原 IP 是客户端的，目的 IP 是 LVS 的 VIP，经过 FullNAT 转换后，原 IP 变成 LVS 的 Local 地址，目的地址是 LVS 选择出来的 RS 地址，这样在 RS 回包时比较容易，只要路由可达，报文一定会交到 LVS 上，不需要在 RS 上做特殊的配置。右面就是 DNAT + SNAT 转换，报文就可以通过 LVS 转发回客户端，这种方式主要带来应用场景部署灵活性选择。</p> \n <p><img src=\"/assets/77941914a0f64ecc7fee32dd248a2df6bac00309.png\" alt=\"\"></p> \n <p>通过并行化实现对 LVS 性能的改善，性能没有办法得到线性提升更多的是因为每条路径都需要访问全局资源，就会不可避免引入锁的开箱，另外，同一条链接上的报文可能分散在不同的核上，大家去访问全局资源时也会导致 cache 的丢失。所以我们通过 RSS 技术把同一个五源组报文扔到同一个 CPU 上处理，保证入方向的所有相同连接上的报文都能交给相同 CPU 处理，每个核在转发出去时都用当前 CPU 上的 Local 地址，通过设置一些 fdir 规则，报文回来时后端 RS 访问的目的地址就是对应 CPU 上的 local 地址，可以交到指定的 CPU 上去处理，这样一条连接上左右方向报文都可以交给同一个 CPU 处理，将流在不同的 CPU 隔离开；另外，我们把所有配置资源包括动态缓存资源在每个 CPU 上作了拷贝，将资源局部化，这使整个流从进入 LVS 到转发出去访问的资源都是固定在一个核上的本地资源，使性能达到最大化，实现线性提升。</p> \n <p>改进后的 LVS 表现如下：</p> \n <ul> \n  <li>出于对容灾和性能提升的考虑，我们做了集群化部署，每个 region 有不同机房，每个机房有多个调度单元，每个单元有多台 LVS 设备；</li> \n  <li>每台 LVS 经过优化后，都能达到更高性能，大容量，单台 LVS 可以达到 <strong>4000W PPS</strong>，<strong>600W CPS</strong>、单个 group 可以到达 <strong>1亿</strong> 并发；</li> \n  <li>支持 region、IDC、集群和应用级的高可用；</li> \n  <li>实现了防攻击功能，并在原版 LVS 上提供了更丰富的功能，可以基于各个维度做管理控制，精确的统计，流量的分析等。</li> \n </ul> \n <h3 id=\"Tengine\"><a href=\"#Tengine\" class=\"headerlink\" title=\"Tengine\"></a>Tengine</h3>\n <p><img src=\"/assets/db1900a027c4c7f66e2560edfaa56ec69437d942.png\" alt=\"\"></p> \n <p>Tengine 在应用过程中也遇到了各种问题，最严重的就是性能问题，我们发现随着 CPU 数量越来越多，QPS 值并没有线性提升；Nginx 本身是多 worker 模型，每个 worker 是单进程模式，多 worker 架构做 CPU 亲和，内部基于事件驱动的模型，其本身已经提供了很高的性能，单核 Nginx 可以跑到 <strong>1W5～2W QPS</strong>。Nginx 往下第一层是 socket API，socket 往下有一层 VFS，再往下是 TCP、IP，socket 层比较薄，经过量化的分析和评估，性能开销最大的是 TCP 协议栈和 VFS 部分，因为同步开销大，我们发现横向扩展不行，对此，我们做了一些优化。</p> \n <p>七层反向代理的路径更长，处理更复杂，所以它的性能比 LVS 低很多，我们比较关注单机和集群的性能，集群性能可以靠堆设备去解决，单机如果不提升，成本会一直增加，从性能角度来看，有以下的优化思路和方向：</p> \n <ul> \n  <li>基于 Kernel 做开发，比如优化协议栈；</li> \n  <li>基于 AliSocket 的优化，AliSocket 是阿里研发的高性能 TCP 协议栈平台，底层是 DPDK，它将资源做了局部化处理，报文分发不同核处理，性能非常出色；</li> \n  <li>HTTPS 业务越来越多，流量逐步递增，我们采用硬件加速卡方式做一些加解密的性能提升，还有 HTTPS 的会话复用；</li> \n  <li>基于 Web 传输层的性能优化</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(301,12,'对于快速追踪与定位问题',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在微服务复杂的链式调用中，我们会比单体架构更难以追踪与定位问题。因此，在设计的时候，需要特别注意。一种比较好的方案是，当 RESTful API 接口出现非 2xx 的 HTTP 错误码响应时，采用全局的异常结构响应信息。其中，code 字段用来表示某类错误的错误码，在微服务中应该加上“{biz_name}/”前缀以便于定位错误发生在哪个业务系统上。我们来看一个案例，假设“用户中心”某个接口没有权限获取资源而出现错误，我们的业务系统可以响应“UC/AUTH_DENIED”，并且通过自动生成的 UUID 值的 request_id 字段，在日志系统中获得错误的详细信息。</p> \n <pre><code>HTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n</code></pre>\n <p>此外，我们需要在记录日志时，标记出错误来源以及错误详情便于更好地分析与定位问题。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(302,12,'你如何对需求原型进行理解和拆分',1,'www.funtl.com/assets/f7lRMoelw72Xzm1JGXtA.png',1,'<div class=\"col-sm-12\"> \n <p>某公司的产品面试，面试前该公司让面试者做一道笔试题，笔试题目为：</p> \n <blockquote> \n  <p>针对以下需求提供一个解决方案：在卡牛-信用卡管家APP里面，我们的用户需要一个寻找 附近银行网点/ATM 的功能：</p> \n  <ol> \n   <li>请交付你针对这个需求，设计的 Axure 原型界面的解决方案</li> \n   <li>在原型里面标明业务规则和你对这个需求的分析思考过程（脑图、流程图等等）</li> \n  </ol> \n </blockquote> \n <p>通过本道题目，将讲述为某产品添加一个功能需求，从策划到上线将会走那些流程。</p> \n <p>在一家小型的创业公司，从项目的需求——项目的落实——项目的上线，他们大致会走这样的流程：<code>产品策划</code> – <code>UI设计</code> – <code>研发评审</code> – <code>测试评审</code> – <code>研发阶段</code> – <code>测试阶段</code> – <code>上线</code>。结合那个面试题，详细的讲述产品策划这块，简要的描述一下后续几个流程。</p> \n <p><img src=\"/assets/f7lRMoelw72Xzm1JGXtA.png\" alt=\"\"></p> \n <p>根据以上笔试题，我们可以得知：卡牛-信用卡管家 APP 的用户反馈得知，用户希望在卡牛 APP 有一个可以寻找 附近银行网点／ATM的功能。</p> \n <h3 id=\"产品策划\"><a href=\"#产品策划\" class=\"headerlink\" title=\"产品策划\"></a>产品策划</h3>\n <p>在产品策划中，首先是获取产品需求、然后对产品需求进行筛选、评估。获取产品需求主要来源可以分为<strong>内部渠道和外部渠道。外部渠道的来源于“用户反馈、用户调研、竞品分析、市场、合作伙伴”；内部渠道的来源于“公司战略、产品经理本身、产品数据分析、其他部门的反馈”</strong>。</p> \n <p>当获取到产品需求时，接下就会进行需求评估，<strong>需求评估将会利用以下方法：客户满意度、马斯洛需求、重要紧急四项型、调研强制排序、维度评分排序</strong>。</p> \n <p><strong>维度需求排序的话，一般的排序：企业的发展战略、产品的定位、需求价值度（企业价值、用户价值等）、核心用户占有比例、需求频率的程度等方面</strong>。在这种情况下，一般产品部门都会把所有需求都写在需求评估表中，然后对需求进行评估，如图。在创业型公司来说，大部分的需求一般都是公司战略层次的需求（正所谓老板需求）。</p> \n <p><img src=\"/assets/nEr2nG1D50mXOrfwUUM8.png\" alt=\"\"></p> \n <p>有时候在产品需求的前面，会有一次产品需求调研，这是为了进一步确认此<strong>产品需求的必要性</strong>。在创业型公司来说，一般都是直接省去，直接确定产品需求，然后开始落实。</p> \n <p>当需求确定后，我们进入<strong>产品需求功能的落实</strong>（也就是将产品需求画出来，然后去研发）。在笔试题中已经确定了产品需求，所以我们只需要考虑产品功能如何落实。</p> \n <p>产品功能的落实，<strong>一般会走以下流程：竞品分析（产品功能调研）—绘制流程图—产品原型图的制作—产品部门内部评审</strong>。</p> \n <p>现在我们需要对卡牛 APP 中开发一个“寻找附近银行网点／ATM的功能”。</p> \n <h4 id=\"产品功能调研\"><a href=\"#产品功能调研\" class=\"headerlink\" title=\"产品功能调研\"></a>产品功能调研</h4>\n <ol> \n  <li>挑选竞品。几款地图 APP——百度地图、高德地图</li> \n  <li>分析竞品的功能。在进行功能性调研中，我们需要探讨他们功能的入口、功能的逻辑、及他们功能有哪些值得借鉴学习的地方。</li> \n  <li>创想差异化／专属特色功能。</li> \n </ol> \n <p>以下调研的结果：</p> \n <ol> \n  <li>根据卡牛产品现有的功能和框架，将入口配置“信用卡—我的”功能区域中。</li> \n  <li>在附近-银行页面中，我们可以提供了银行的基本信息，包括（营业厅／ATM名称、具体地点位置、电话号码、距离）。</li> \n  <li>为了增加用户黏性，可以设置“评价服务功能”，时刻了解到该银行的服务情况。</li> \n  <li>开设特色服务功能，在卡牛中设置银行排队预约功能。这个功能的创想主要是来源生活中的观察和留意，大家可以回忆自己平日去银行办理业务时，都需要进行长时间的排队，而且预约的地点只能在规定的银行预约排队，整个体验下来是不是特别低效。</li> \n </ol> \n <h4 id=\"绘制流程图和原型图\"><a href=\"#绘制流程图和原型图\" class=\"headerlink\" title=\"绘制流程图和原型图\"></a>绘制流程图和原型图</h4>\n <p>在绘制流程图的过程中，团子建议大家<strong>不要先急着绘制流程图，先用思维导图绘制一些产品功能的模块，哪些功能需要展现到那些页面，那个区域包括那些信息，理顺思路，然后绘制流程图</strong>，如图。</p> \n <p>画流程是一个锻炼逻辑的活，以下是我画产品功能的逻辑图，分三大块：附近主流程、评价流程、预约流程。大家可以借鉴参考一下。</p> \n <h5 id=\"思维导图\"><a href=\"#思维导图\" class=\"headerlink\" title=\"思维导图\"></a>思维导图</h5>\n <p><img src=\"/assets/ONXZIubgzBvcy84Xx4ed.png\" alt=\"\"></p> \n <h5 id=\"主流程图——附近\"><a href=\"#主流程图——附近\" class=\"headerlink\" title=\"主流程图——附近\"></a>主流程图——附近</h5>\n <p><img src=\"/assets/QjCZNjWkPmo1kJh4ilC8.png\" alt=\"\"></p> \n <h5 id=\"流程图——评价\"><a href=\"#流程图——评价\" class=\"headerlink\" title=\"流程图——评价\"></a>流程图——评价</h5>\n <p><img src=\"/assets/z6gJbfOvbGobGWS8TAb5.png\" alt=\"\"></p> \n <h5 id=\"流程图——预约\"><a href=\"#流程图——预约\" class=\"headerlink\" title=\"流程图——预约\"></a>流程图——预约</h5>\n <p><img src=\"/assets/6kbBXwoXLkuzcCnodwrL.png\" alt=\"\"></p> \n <h4 id=\"原型交互\"><a href=\"#原型交互\" class=\"headerlink\" title=\"原型交互\"></a>原型交互</h4>\n <p>在原型交互的过程中，有些公司需要你在产品原型图上做动态交互，有些公司只需要你在产品原型图上做好交互标明。对此评价一下没做交互动态和做了交互动态的优缺点。</p> \n <p><img src=\"/assets/KVQx3NfESBUeBz4EzHr5.jpg\" alt=\"\"></p> \n <h5 id=\"整体原型图\"><a href=\"#整体原型图\" class=\"headerlink\" title=\"整体原型图\"></a>整体原型图</h5>\n <p><img src=\"/assets/Il1UYXXpYvxzH6lAlabI.png\" alt=\"\"></p> \n <h5 id=\"交互原型图\"><a href=\"#交互原型图\" class=\"headerlink\" title=\"交互原型图\"></a>交互原型图</h5>\n <p><img src=\"/assets/NNOPJZI0E53bdkhe9gGG.png\" alt=\"\"></p> \n <p><img src=\"/assets/TBUwHwDcwQZzJGcdgcM9.png\" alt=\"\"></p> \n <p><img src=\"/assets/rTWtwz6hiWhpUyGJN4eI.png\" alt=\"\"></p> \n <h4 id=\"搜集产品部门内部意见\"><a href=\"#搜集产品部门内部意见\" class=\"headerlink\" title=\"搜集产品部门内部意见\"></a>搜集产品部门内部意见</h4>\n <p>完成原型图的绘制，产品策划也就完成了 90% 的工作，随后就是产品部门的审核，这一项工作将会召集产品部、运营部、UI部门进行讨论和点评，对产品原型图进行进一步优化，此刻你需要搜集其他同事及其他部门的意见，然后收集回来进行整理，筛选出可以优化的需求。</p> \n <h3 id=\"UI设计\"><a href=\"#UI设计\" class=\"headerlink\" title=\"UI设计\"></a>UI设计</h3>\n <p>当面对一般 UI 时，如果你对一般的 UI 说“我需要你帮我设计一款简洁、大气、稳重严肃、不需要太多的色彩的页面”，此时 UI 会一面懵逼，他会反问你一句：“你到告诉我啥叫简洁、大气、稳重严肃”。</p> \n <p>面对公司这样的 UI 时，<strong>最好的解决方式就是自己去找素材，然后找到你喜欢的素材发给 UI</strong>，对着 UI 说“我就要这种风格”。此时 UI 就不会怼你，他就会照着这个做。</p> \n <h3 id=\"研发评审\"><a href=\"#研发评审\" class=\"headerlink\" title=\"研发评审\"></a>研发评审</h3>\n <p>完成以上工作流程之后，在此就会召开研发测试需求评审，这块主要是对此<strong>需求进行排期和了解制作此需求所需要花的时间、此产品需求的可用性</strong>。</p> \n <p>作为产品狗，需要了解目前整个产品的大致动态和产品后期迭代的内容，对此该功能应放在那期迭代中。了解研发部门的情况，确定了研发的时间。</p> \n <h3 id=\"测试评审\"><a href=\"#测试评审\" class=\"headerlink\" title=\"测试评审\"></a>测试评审</h3>\n <p>接下来到了测试评审，在研发中这是一个很重要的环节，需要对<strong>理想期的产品原型图测试和规划</strong>，等到时候研发开发完成了后，需要测试部门进行测试，测试部门会对照理想型的产品图与测试版产品进行比较，写下测试日志文档，为后期的产品功能迭代做好铺垫和准备。因此测试人员会在前期与产品人员进行一次详细的讨论，关于产品原型图的事项，在讨论的过程中<strong>需要对每一个细节和动态进行说明</strong>，所以产品在此要多和测试交流沟通，时刻传达信息给测试人员，做好同步信息。</p> \n <h3 id=\"研发阶段\"><a href=\"#研发阶段\" class=\"headerlink\" title=\"研发阶段\"></a>研发阶段</h3>\n <p>在产品研发过程中，测试和研发是一起进行的。有时候研发要改动产品原型图的需求，研发首先会通知产品，他们要对需求进行改动，一般的改动大概就是“<strong>砍需求、改动态（为什么研发不喜欢看高保证原型）</strong>”，所以产品需要对改动的需求进行快速决策。研发这边改需求，此时产品就要和测试那边沟通，将信息传达给测试。<strong>工作信息要进行时刻同步</strong>。</p> \n <h3 id=\"测试阶段\"><a href=\"#测试阶段\" class=\"headerlink\" title=\"测试阶段\"></a>测试阶段</h3>\n <p>当研发完成初稿后，会提交转测邮件，测试部门会接收此文档进行测试，如有问题，就会将产品测试的 BUG 进行整理，让研发继续修补 BUG，研发修好后，在会进行转测，直到可以上线为止。如果功能越复杂，一般会走好几个来回。</p> \n <p>有人会问，为什么要在研发测试的过程中，平凡发邮件。其实这样是为了进行<strong>权责分明</strong>，同时可以进行工作上的同步。</p> \n <h3 id=\"上线\"><a href=\"#上线\" class=\"headerlink\" title=\"上线\"></a>上线</h3>\n <p>当测试完成后就到了，负责人就要对产品进行申请，发布提交上线邮件将公布给全公司，然后完成了产品的上线。此时是产品狗最幸福的时刻。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(303,12,'分布式锁的场景与实现',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3>\n <p>首先，我们看这样一个场景：客户下单的时候，我们调用库存中心进行减库存，那我们一般的操作都是：</p> \n <pre><code>update store set num = $num where id = $id\n</code></pre>\n <p>这种通过设置库存的修改方式，我们知道在并发量高的时候会存在数据库的丢失更新，比如 a, b 当前两个事务，查询出来的库存都是 5，a 买了 3 个单子要把库存设置为 2，而 b 买了 1 个单子要把库存设置为 4，那这个时候就会出现 a 会覆盖 b 的更新，所以我们更多的都是会加个条件：</p> \n <pre><code>update store set num = $num where id = $id and num = $query_num\n</code></pre>\n <p>即乐观锁的方式来处理，当然也可以通过版本号来处理乐观锁，都是一样的，但是这是更新一个表，如果我们牵扯到多个表呢，我们希望和这个单子关联的所有的表同一时间只能被一个线程来处理更新，多个线程按照不同的顺序去更新同一个单子关联的不同数据，出现死锁的概率比较大。对于非敏感的数据，我们也没有必要去都加乐观锁处理，我们的服务都是多机器部署的，要保证多进程多线程同时只能有一个进程的一个线程去处理，这个时候我们就需要用到分布式锁。分布式锁的实现方式有很多，我们今天分别通过数据库，Zookeeper, Redis 以及 Tair 的实现逻辑。</p> \n <h3 id=\"数据库实现\"><a href=\"#数据库实现\" class=\"headerlink\" title=\"数据库实现\"></a>数据库实现</h3>\n <h4 id=\"加-xx-锁\"><a href=\"#加-xx-锁\" class=\"headerlink\" title=\"加 xx 锁\"></a>加 xx 锁</h4>\n <p>更新一个单子关联的所有的数据，先查询出这个单子，并加上排他锁，在进行一系列的更新操作</p> \n <pre><code>begin transaction；\nselect ...for update；\ndoSomething()；\ncommit();\n</code></pre>\n <p>这种处理主要依靠排他锁来阻塞其他线程，不过这个需要注意几点：</p> \n <ol> \n  <li>查询的数据一定要在数据库里存在，如果不存在的话，数据库会加 gap 锁，而 gap 锁之间是兼容的，这种如果两个线程都加了gap 锁，另一个再更新的话会出现死锁。不过一般能更新的数据都是存在的</li> \n  <li>后续的处理流程需要尽可能的时间短，即在更新的时候提前准备好数据，保证事务处理的时间足够的短，流程足够的短，因为开启事务是一直占着连接的，如果流程比较长会消耗过多的数据库连接的</li> \n </ol> \n <h4 id=\"唯一键\"><a href=\"#唯一键\" class=\"headerlink\" title=\"唯一键\"></a>唯一键</h4>\n <p>通过在一张表里创建唯一键来获取锁，比如执行 saveStore 这个方法</p> \n <pre><code>insert table lock_store (\'method_name\') values($method_name)\n</code></pre>\n <p>其中 <code>method_name</code> 是个唯一键，通过这种方式也可以做到，解锁的时候直接删除改行记录就行。不过这种方式，锁就不会是阻塞式的，因为插入数据是立马可以得到返回结果的。</p> \n <p>那针对以上数据库实现的两种分布式锁，存在什么样的优缺点呢？</p> \n <h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4>\n <p>简单，方便，快速实现</p> \n <h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>\n <ul> \n  <li>基于数据库，开销比较大，性能可能会存在影响</li> \n  <li>基于数据库的当前读来实现，数据库会在底层做优化，可能用到索引，可能不用到索引，这个依赖于查询计划的分析</li> \n </ul> \n <h3 id=\"Zookeeper-实现\"><a href=\"#Zookeeper-实现\" class=\"headerlink\" title=\"Zookeeper 实现\"></a>Zookeeper 实现</h3>\n <h4 id=\"获取锁\"><a href=\"#获取锁\" class=\"headerlink\" title=\"获取锁\"></a>获取锁</h4>\n <ol> \n  <li>先有一个锁跟节点，lockRootNode，这可以是一个永久的节点</li> \n  <li>客户端获取锁，先在 lockRootNode 下创建一个顺序的瞬时节点，保证客户端断开连接，节点也自动删除</li> \n  <li>调用 lockRootNode 父节点的 getChildren() 方法，获取所有的节点，并从小到大排序，如果创建的最小的节点是当前节点，则返回 true,获取锁成功，否则，关注比自己序号小的节点的释放动作(exist watch)，这样可以保证每一个客户端只需要关注一个节点，不需要关注所有的节点，避免羊群效应。</li> \n  <li>如果有节点释放操作，重复步骤 3</li> \n </ol> \n <h4 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h4>\n <p>只需要删除步骤 2 中创建的节点即可</p> \n <p>使用 Zookeeper 的分布式锁存在什么样的优缺点呢？</p> \n <h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4>\n <ul> \n  <li>客户端如果出现宕机故障的话，锁可以马上释放</li> \n  <li>可以实现阻塞式锁，通过 watcher 监听，实现起来也比较简单</li> \n  <li>集群模式，稳定性比较高</li> \n </ul> \n <h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4>\n <ul> \n  <li>一旦网络有任何的抖动，Zookeeper 就会认为客户端已经宕机，就会断掉连接，其他客户端就可以获取到锁。当然 Zookeeper 有重试机制，这个就比较依赖于其重试机制的策略了</li> \n  <li>性能上不如缓存</li> \n </ul> \n <h3 id=\"Redis-实现\"><a href=\"#Redis-实现\" class=\"headerlink\" title=\"Redis 实现\"></a>Redis 实现</h3>\n <p>我们先举个例子，比如现在我要更新产品的信息，产品的唯一键就是 productId</p> \n <h4 id=\"简单实现-1\"><a href=\"#简单实现-1\" class=\"headerlink\" title=\"简单实现 1\"></a>简单实现 1</h4>\n <pre><code>public boolean lock(String key, V v, int expireTime){\n        int retry = 0;\n        //获取锁失败最多尝试10次\n        while (retry &lt; failRetryTimes){\n            //获取锁\n            Boolean result = redis.setNx(key, v, expireTime);\n            if (result){\n                return true;\n            }\n\n            try {\n                //获取锁失败间隔一段时间重试\n                TimeUnit.MILLISECONDS.sleep(sleepInterval);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                return false;\n            }\n\n        }\n\n        return false;\n    }\n    public boolean unlock(String key){\n        return redis.delete(key);\n    }\n    public static void main(String[] args) {\n        Integer productId = 324324;\n        RedisLock&lt;Integer&gt; redisLock = new RedisLock&lt;Integer&gt;();\n        redisLock.lock(productId+\"\", productId, 1000);\n    }\n}\n</code></pre>\n <p>这是一个简单的实现，存在的问题：</p> \n <ol> \n  <li>可能会导致当前线程的锁误被其他线程释放，比如 a 线程获取到了锁正在执行，但是由于内部流程处理超时或者 gc 导致锁过期，这个时候b线程获取到了锁，a 和 b 线程处理的是同一个 productId，b还在处理的过程中，这个时候 a 处理完了，a 去释放锁，可能就会导致 a 把 b 获取的锁释放了。</li> \n  <li>不能实现可重入</li> \n  <li>客户端如果第一次已经设置成功，但是由于超时返回失败，此后客户端尝试会一直失败</li> \n </ol> \n <p>针对以上问题我们改进下：</p> \n <ol> \n  <li>v 传 requestId，然后我们在释放锁的时候判断一下，如果是当前 requestId，那就可以释放，否则不允许释放</li> \n  <li>加入 count 的锁计数，在获取锁的时候查询一次，如果是当前线程已经持有的锁，那锁技术加 1，直接返回 true</li> \n </ol> \n <h4 id=\"简单实现-2\"><a href=\"#简单实现-2\" class=\"headerlink\" title=\"简单实现 2\"></a>简单实现 2</h4>\n <pre><code>private static volatile int count = 0;\npublic boolean lock(String key, V v, int expireTime){\n    int retry = 0;\n    //获取锁失败最多尝试10次\n    while (retry &lt; failRetryTimes){\n        //1.先获取锁,如果是当前线程已经持有，则直接返回\n        //2.防止后面设置锁超时，其实是设置成功，而网络超时导致客户端返回失败，所以获取锁之前需要查询一下\n        V value = redis.get(key);\n        //如果当前锁存在，并且属于当前线程持有，则锁计数+1，直接返回\n        if (null != value &amp;&amp; value.equals(v)){\n            count ++;\n            return true;\n        }\n\n        //如果锁已经被持有了，那需要等待锁的释放\n        if (value == null || count &lt;= 0){\n            //获取锁\n            Boolean result = redis.setNx(key, v, expireTime);\n            if (result){\n                count = 1;\n                return true;\n            }\n        }\n\n        try {\n            //获取锁失败间隔一段时间重试\n            TimeUnit.MILLISECONDS.sleep(sleepInterval);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n\n    }\n\n    return false;\n}\npublic boolean unlock(String key, String requestId){\n    String value = redis.get(key);\n    if (Strings.isNullOrEmpty(value)){\n        count = 0;\n        return true;\n    }\n    //判断当前锁的持有者是否是当前线程，如果是的话释放锁，不是的话返回false\n    if (value.equals(requestId)){\n        if (count &gt; 1){\n            count -- ;\n            return true;\n        }\n\n        boolean delete = redis.delete(key);\n        if (delete){\n            count = 0;\n        }\n        return delete;\n    }\n\n    return false;\n}\npublic static void main(String[] args) {\n    Integer productId = 324324;\n    RedisLock&lt;String&gt; redisLock = new RedisLock&lt;String&gt;();\n    String requestId = UUID.randomUUID().toString();\n    redisLock.lock(productId+\"\", requestId, 1000);\n}\n</code></pre>\n <p>这种实现基本解决了误释放和可重入的问题，这里说明几点：</p> \n <ol> \n  <li>引入 count 实现重入的话，看业务需要，并且在释放锁的时候，其实也可以直接就把锁删除了，一次释放搞定，不需要在通过 count 数量释放多次，看业务需要吧</li> \n  <li>关于要考虑设置锁超时，所以需要在设置锁的时候查询一次，可能会有性能的考量，看具体业务吧</li> \n  <li>目前获取锁失败的等待时间是在代码里面设置的，可以提出来，修改下等待的逻辑即可</li> \n </ol> \n <h4 id=\"错误实现\"><a href=\"#错误实现\" class=\"headerlink\" title=\"错误实现\"></a>错误实现</h4>\n <p>获取到锁之后要检查下锁的过期时间，如果锁过期了要重新设置下时间,大致代码如下：</p> \n <pre><code>public boolean tryLock2(String key, int expireTime){\n    long expires = System.currentTimeMillis() + expireTime;\n\n    // 获取锁\n    Boolean result = redis.setNx(key, expires, expireTime);\n    if (result){\n        return true;\n    }\n\n    V value = redis.get(key);\n    if (value != null &amp;&amp; (Long)value &lt; System.currentTimeMillis()){\n        // 锁已经过期\n        String oldValue = redis.getSet(key, expireTime);\n        if (oldValue != null &amp;&amp; oldValue.equals(value)){\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre>\n <p>这种实现存在的问题，过度依赖当前服务器的时间了，如果在大量的并发请求下，都判断出了锁过期，而这个时候再去设置锁的时候，最终是会只有一个线程，但是可能会导致不同服务器根据自身不同的时间覆盖掉最终获取锁的那个线程设置的时间。</p> \n <h3 id=\"Tair-实现\"><a href=\"#Tair-实现\" class=\"headerlink\" title=\"Tair 实现\"></a>Tair 实现</h3>\n <p>通过 Tair 来实现分布式锁和 Redis 的实现核心差不多，不过 Tair 有个很方便的 api，感觉是实现分布式锁的最佳配置，就是 Put api 调用的时候需要传入一个 version，就和数据库的乐观锁一样，修改数据之后，版本会自动累加，如果传入的版本和当前数据版本不一致，就不允许修改。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:03','2018-12-20 22:06:03'),
(304,12,'说说你对非功能性需求的理解',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>非功能性需求是指依一些条件判断系统运作情形或其特性，而不是针对系统特定行为的需求。包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(305,12,'说说你对功能性需求的理解',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"用户需求\"><a href=\"#用户需求\" class=\"headerlink\" title=\"用户需求\"></a>用户需求</h3>\n <p>是从某一类用户的视角看他使用这个软件的需求。比如，作为用户你用淘宝，找东西，拍货，付款，你有怎样的需求。作为卖家，你用淘宝怎么收款，发货，管理订单。这就是一个个的 <code>use case</code> 或者 <code>user story</code>。 所以写 <code>user story</code> ， 开头第一句就是 <code>As a xxx</code>. 这都是从个人视角去看需求的。</p> \n <h3 id=\"业务需求\"><a href=\"#业务需求\" class=\"headerlink\" title=\"业务需求\"></a>业务需求</h3>\n <p>你整理完不同视角的需求，就要一个更高层面，更全局话的角度看需求。就要把这些需求串联起来。特别是把全局的流程梳理出来。从个人角度，是看不到全局的流程的。但是要想把业务梳理清楚，特别是数据流。就需要这种全局视角下的梳理。我们才清楚 <code>use case/user story</code> 是在什么场景下。 特别是有时候，不同的用户的需求可能存在冲突。通过这种全局性的业务需求梳理，可以去发现潜在冲突，并平衡需求。</p> \n <h3 id=\"功能需求\"><a href=\"#功能需求\" class=\"headerlink\" title=\"功能需求\"></a>功能需求</h3>\n <p>就是把具体的用户需求，变成软件的功能要求。比如客户要把交通事故照片通过 APP 发给保险公司。这是用户需求。 那么功能需求就是在这个模块下，要具有提交报险事故照片功能，上传现场照片。如果再具体下去，就是界面交互图。现在互联网公司一提产品管理，需求设计，基本就是 UX。需求过于碎片化。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(306,12,'说说你在项目中使用过的 UML 图',1,'www.funtl.com/assets/1004000.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3>\n <p>在 OOA 与 OOD 大行其道的今天，UML 在系统分析与设计中得到了广泛的采用。而在 UML 的 9 种图中，类图是最重要也是使用最普遍的图之一。但是，在与一些朋友，特别是初学者的聊天当中，我发现很多朋友对类图的作用及使用方法存在一定的误解和困惑。希望本文能在一定程度上帮助这些朋友更好的认识和使用类图。</p> \n <h3 id=\"A-vs-D\"><a href=\"#A-vs-D\" class=\"headerlink\" title=\"A vs D\"></a>A vs D</h3>\n <p>要想正确认识与使用类图，我们首先要正确认识两个概念——“A”和“D”。</p> \n <p>A是Analyse的缩写，即我们所说的“分析”；而D是Design的缩写，即“设计”。一般来说，一个系统在编码前，都要经过分析与设计两个步骤。而对这两个概念认识的模糊不清，正是导致很多朋友无法正确使用类图的原因。</p> \n <p>分析，我对其的解释是：根据用户的需求，做出一系列与业务领域相关而和计算机技术无关的整理与识别。</p> \n <p>很多朋友有个错误的认识，认为软件开发工作一定要由懂计算机的人完成，不懂计算机的人怎么能进行软件开发呢？当然，对于设计和编码等工作，当然是这样，但是唯有“分析”这一工作，可以由完全不懂计算机的人来进行，甚至从某种程度上说，不懂计算机的人更适合做软件分析师的工作。因为想要把分析做好，一定要仅与业务相关，而抛开具体技术。一个满脑子计算机技术的程序员去做分析时，很容易想到编码、实现、平台、数据库设计等具体细节，这种思维形式恰恰成为做好分析的最大障碍。此为误解一：只有懂计算机技术的人才能做系统分析师。我现在所在的研究所（北京航空航天大学计算机学院软件工程研究所）曾经接过一个日本项目，当时日方那边派来一个系统分析师对计算机就完全是外行，而是一个领域专家，但是他很好的完成了系统分析的工作。</p> \n <p>另外一个误解就是UML图，特别是类图，就是给开发人员用的。很多人觉得UML是计算机业内专业语言，不懂计算机的怎么能用它呢？用了做什么呢？但是很多不懂计算机的系统分析师在进行分析工作时，也在使用UML图，而类图就是其中一种。一般情况下，分析师在进行分析时，确实会绘制一套类图。但是，它所画的类图不管是从视角还是作用，与设计师所做的类图是不同的，具体将在下面介绍。此为误解二：只有计算机人士才使用UML图。</p> \n <p>分析说完了，下面说设计。与分析不同，我对设计的解释是：根据分析材料与技术平台，确定软件系统的架构结构、编码方式及一切与具体技术有关的宏观问题。</p> \n <p>这里可以看到，设计与分析不同，它必须由计算机方面的人来完成，因为它和具体技术是息息相关的。而且，设计师在进行设计时，也会绘制一套类图。</p> \n <p>到这里，我们明确了，原来软件在分析与设计两个阶段各自会绘制一套类图，而且是由分析师和设计师两个不同的角色绘制的。那么这两套类图有什么异同呢？下面将解释这个问题。</p> \n <h3 id=\"领域类图-vs-实现类图\"><a href=\"#领域类图-vs-实现类图\" class=\"headerlink\" title=\"领域类图 vs 实现类图\"></a>领域类图 vs 实现类图</h3>\n <p>上文提到，在软件分析与设计过程中，会由两种角色产生两套类图。一般情况下，分析师绘制的类图叫做“领域类图”，而设计师绘制的类图叫做“实现类图”。这里要声明，这两个名词是我的习惯性叫法，并不是大家都认同的通用叫法。下面，我对这两种类图给出我的定义：</p> \n <p>领域类图：产生于分析阶段，由系统分析师绘制，主要作用是描述业务实体的静态结构，包括业务实体、各个业务实体所具有的业务属性及业务操作、业务实体之间具有的关系。</p> \n <p>虽然这个类图也叫“类图”，但是说实话，它和编程中的“类”实在是没啥关系，因为最后的系统中可能根本没有类和它们对应，而且很多最后系统中的类如控制类和界面类这套类图中也没有。也就是说这套图和具体技术无关，也不是画给程序员看的，它只是表达业务领域中的一个静态结构。下面给个例子：</p> \n <p><img src=\"/assets/1004000.jpg\" alt=\"\"></p> \n <p>这是一个选课系统的简单领域分析类图。可以看到，主要实体有教师、学生、课程和开课安排。每个实体标注了其在业务上具有的属性和方法。而且图中还标明了实体间的关系。</p> \n <p>但是，最终系统中可能没有一个学生类和其对应。因为最终系统中有哪些类、各个类有什么属性、方法依赖于所选择的平台和架构。例如，如果使用了 Struts2，则会存在很多 Action 类，而使用了 ASP.NET MVC，则会有很多 Controller 类等，所以，领域类图只于业务有关，和具体实现及编码等计算机技术无关。</p> \n <p><strong>下面该说说实现类图了：</strong></p> \n <p>现类图：产生于设计阶段，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码。它包括系统中所有有必要指明的实体类、控制类、界面类及与具体平台有关的所有技术性信息。</p> \n <p>就像上面的领域类图，如果你把它交给程序员编码，我想程序员会疯掉，因为它没有提供任何编码的依据。假如我们使用的是.NET平台分层架构，并使用ASP.NET MVC，则设计师应该在实现类图中绘制出所有的实体类、数据访问类、业务逻辑类和界面类，界面类又分为视图类、控制器类等等，还要表示出IoC和Aop等信息，并明确指出各个类的属性、方法，不能有遗漏，因为最终程序员实现程序的依据就是实现类图。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>最后，我们总结一下本文的要点：</p> \n <ol> \n  <li>软件分析与设计是编码前的两个阶段，其中分析仅与业务有关，而与技术无关。设计以分析为基础，主要与具体技术有关。</li> \n  <li>分析阶段由分析师绘制领域类图，设计阶段由设计师绘制实现类图。</li> \n  <li>领域类图表示系统的静态领域结构，其中的类不与最终程序中的类对应；设计类图表示系统的技术架构，是程序员的编码依据，其中的类与系统中的类对应。</li> \n  <li>领域类图中类的属性与操作仅关注与业务相关的部分，实现类图中的属性与操作要包括最终需要实现的全部方法与操作。</li> \n </ol> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(307,12,'你针对产品提出哪些交互和改进意见',1,'www.funtl.com/assets/f0fcd6e5-874f-4894-9e0c-39fb1574c6de.jpg',1,'<div class=\"col-sm-12\"> \n <blockquote> \n  <p>过度设计，一般是说过度满足用户需求的设计。用户想要 A，你给了他 ABCDE，结果 BCDE 全部用不上。既让用户选择困难，又浪费了团队开发时间。</p> \n </blockquote> \n <p>即使是有经验的设计师，有时也容易陷入自己的「小循环」中难以自拔，过度追求一些体验的完美，或者需求的满足，而导致最终的实际使用体验下降，或者偏离产品设计初衷的悲剧结果。</p> \n <h3 id=\"过度追求精准\"><a href=\"#过度追求精准\" class=\"headerlink\" title=\"过度追求精准\"></a>过度追求精准</h3>\n <h4 id=\"例1：我们都知道载入内容时需要-loading-状态，如下图：\"><a href=\"#例1：我们都知道载入内容时需要-loading-状态，如下图：\" class=\"headerlink\" title=\"例1：我们都知道载入内容时需要 loading 状态，如下图：\"></a>例1：我们都知道载入内容时需要 loading 状态，如下图：</h4>\n <p><img src=\"/assets/f0fcd6e5-874f-4894-9e0c-39fb1574c6de.jpg\" alt=\"\"></p> \n <p>现实的业务场景中，需要加载的内容往往不只一个。如下图：虽然图表比较多，但排列整齐有序，所以看上去还是比较舒适的。</p> \n <p><img src=\"/assets/6759f77b-6cfb-4b29-9eb7-66252f5e8d27.jpg\" alt=\"\"></p> \n <p>再来看第三张：这样的 loading，是你想要的吗？</p> \n <p><img src=\"/assets/780646e1-86ff-4479-999a-01268f83213c.jpg\" alt=\"\"></p> \n <p>这是一个曾真实存在过的业务场景图，仪表盘中的图表排版是用户自行构建的。大部分仪表盘中的图表都不少于 5 张，且大小不一。每张图表中的数据来源于不同的数据模型，模型大小会影响加载速度，所以加载速度有快有慢，再加上网速等一些客观原因，有时就是会出现参差不齐一片 loading 的场景，而且出现的频率还不低。</p> \n <p>这时，就不应该过于追求每张图表与其 loading 状态一一对应。用户需要的是反馈，虽然精准提示了反馈来自于哪张图表，但如果界面展示反而让用户烦躁和混乱，那就得不偿失了。</p> \n <p>比较合理的做法是，把局部 loading 设计成全局 loading，起到反馈作用就可以了。如图：虽然牺牲了一点精确性，但在体验上用户会更容易接受。</p> \n <p><img src=\"/assets/88cfa64c-41be-4911-9309-09f5050f63f3.jpg\" alt=\"\"></p> \n <h4 id=\"例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\"><a href=\"#例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\" class=\"headerlink\" title=\"例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向\"></a>例2：这是一个筛选器控件的样式设置页面，有两种样式：纵向、横向</h4>\n <p><img src=\"/assets/a1344109-2ef8-46e7-94b7-c5f619189506.jpg\" alt=\"\"></p> \n <p>纵向的列表筛选器，相信大部分人都能理解。如下图：当你勾选了需要筛选的内容时，相对应的内容就会被展示。</p> \n <p><img src=\"/assets/8f0a71ee-44cc-4996-be6b-b36e109d4122.jpg\" alt=\"\"></p> \n <p>好了，现在来想象一下，横向是什么？是这样的：</p> \n <p><img src=\"/assets/1c320f4a-e8eb-4f75-9986-4223227b0caf.jpg\" alt=\"\"></p> \n <p>会发现，横向的列表筛选器比较难理解，甚至之前根本没有看到过，仅仅从文案很难联想到最终的展示形式。横向和纵向，从文案上来说是一个精准的表达，同样的功能，只是方向发生了改变，所以你不能说他错。但用户理解不了，就得换个设计思维。</p> \n <p>重新从用户的使用场景着手，大部分用户习惯将横向列表筛选器和图表搭配在一起这么使用：</p> \n <p><img src=\"/assets/7f4136e0-c0b3-4672-926f-90a64dc4bb9c.jpg\" alt=\"\"></p> \n <p>这非常像一个导航，切换导航就是筛选的过程。最终，我们把设置面板改成了下图：「列表」和「导航」。虽然从含义上不如前者精准，但对用户来说，看到文案能够直观地联想到最终展现形式，体验上会更友好。</p> \n <p><img src=\"/assets/d597677f-fdcd-45f8-9241-ef37a443b8df.jpg\" alt=\"\"></p> \n <h3 id=\"死板遵循设计法则\"><a href=\"#死板遵循设计法则\" class=\"headerlink\" title=\"死板遵循设计法则\"></a>死板遵循设计法则</h3>\n <p>几乎所有的设计师，在入门时都会接触设计法则，设计法则为我们提供设计规范和评判标准，运用这些法则，能让我们在设计时更得心应手，在阐述自己的方案时也会更有底气。但所有的法则都不能盲目的遵守，得根据不同的场景灵活运用。</p> \n <p>尼而森可用性原则中有一条叫做，一致性原则。同一用语、功能、操作需要保持一致。 这可以帮助我们的产品看起来更加统一和规范，但一些设计师会机械的执行这条原则。如下图：这是一个数据格式的设定弹窗，通过点击 btn，能够激活该面板。</p> \n <p><img src=\"/assets/d1a5ebb5-c5d0-4dac-ae00-9d90fa3210eb.jpg\" alt=\"\"></p> \n <p>在另一个界面，也有数据格式的设置，为了遵循操作方式一致，设计成了这样，如图：</p> \n <p><img src=\"/assets/dc2d1135-86cf-4315-9d8c-34a5060cd7d0.jpg\" alt=\"\"></p> \n <p>细看后是否觉得有些地方比较违和？虽然都是通过点击操作激活设置弹窗，但表单中的链接一般不会孤零零的出现在某一个条目中。其次，在弹窗中应该尽量避免再出现一层弹窗，所以设置入口放在这里，是不合适的。</p> \n <p><img src=\"/assets/065f380e-5446-471c-abda-735d11c53662.jpg\" alt=\"\"></p> \n <p>修改一下，这样看上去是不是顺眼多了？</p> \n <p>虽然操作方式没有完全统一，但弹窗和下拉菜单面板中的内容布局是一致的。除此之外，下拉框和上一个表单条目也保持了形式统一，整体更和谐。灵活而不机械的运用设计法则，才能将其作用发挥到最大。</p> \n <h3 id=\"过度假设用户行为\"><a href=\"#过度假设用户行为\" class=\"headerlink\" title=\"过度假设用户行为\"></a>过度假设用户行为</h3>\n <p>在设计的过程中，经常会走着走着就进入了一个误区。「用户可能会如何操作，所以我们应该….」这样的想法经常会伴随着大量的竞品参考愈演愈烈，竞品如果有的，而自己没有就会觉得似乎少了什么。</p> \n <p>举个例子：渐变色的设置面板。有的色板是如下图这样的，类型、方向、角度、透明度、亮度等等，一眼看过去十分专业。</p> \n <p><img src=\"/assets/56e64473-aa07-42ae-b10d-d17bb6abb6a4.jpg\" alt=\"\"></p> \n <p>并不是每一个颜色设置场景都需要使用到渐变色板，相对于一般的纯色色板，它的使用门槛更高。对于这类设置较多的模块，有时我们并不能确定是所有内容全部提供还是只提供其中最常用的一部分，毕竟每一个功能似乎都有需求，难以舍弃。再加上设计迭代周期短，没有足够的时间做一次完整的可用性测试，来研究和验证用户到底想要哪些功能，所以就会陷入纠结。</p> \n <p>可以试着先将所有的内容归类，同类组合，视觉上精简内容，内容一旦形成区块就比较容易区分出优先级，优先级低的内容暂时先不放出来。如图：</p> \n <p><img src=\"/assets/d55ba135-b8b6-4478-af61-c154cc3e7a57.jpg\" alt=\"\"></p> \n <p>建议刚开始选择较为简单的方案，同时留出可扩展的空间。如果简单的设计方案已经能满足用户了，就不用盲目做加法。如果根据后期的可用性测试验证用户还有新的需求，再逐步添加。不要一下子就把用户行为想得太复杂，设计太多，吃力还不讨好。</p> \n <h3 id=\"过多展示内在业务逻辑\"><a href=\"#过多展示内在业务逻辑\" class=\"headerlink\" title=\"过多展示内在业务逻辑\"></a>过多展示内在业务逻辑</h3>\n <p>To b 产品往往业务属性较强，内部逻辑比较复杂，概念定义也多。如图：</p> \n <p><img src=\"/assets/4e2160f2-0fca-4c40-b402-8912376ccbcd.jpg\" alt=\"\"></p> \n <p>报告设置针对的是全局的内容，页面设置针对的是当前页的内容。由于技术是按照两个入口实现该功能的，逻辑上也清晰，所以设计时两个入口都暴露给了用户。但经过可用性测试，这两者的概念区别对用户来说都需要一定的理解时间，首次选择时也容易疑惑。其实这些定义产品内部分清就足够了，不需要额外暴露给用户。</p> \n <p><img src=\"/assets/84531c2b-f7a2-4b0f-8310-540fcac304b4.jpg\" alt=\"\"></p> \n <p>把两个概念合二为一，直接进入当前页面设置，如果有需要，再勾选应用到全局，用户不需要在不同的入口之间犹豫选择，体验上会好很多。</p> \n <h3 id=\"过于把用户当「小白」\"><a href=\"#过于把用户当「小白」\" class=\"headerlink\" title=\"过于把用户当「小白」\"></a>过于把用户当「小白」</h3>\n <p>产品设计中经常会强调，把「用户当小白」，但这更多适合 to c 类产品，to c 产品的操作流程更有规律性，做好引导或者在操作过程中自然的提示，的确能够帮助用户更快上手。</p> \n <p>而 to b 类产品，尤其是工具类产品，使用者本身是有一定的专业基础的，再加上操作频繁，形式多样，想要预判用户的下一步操作并不容易。如果老抱着一种我要去教用户使用的想法，每一步都去提示、引导，只会不停打断操作流程，降低用户体验。</p> \n <p>对于工具类的 to b 产品，与其不断提醒，造成大量提示文案，不如在一些复杂概念或者复杂操作旁提供帮助，供用户自己查阅学习。</p> \n <p>例如：提供搜索入口帮助用户快速定位到问题。</p> \n <p><img src=\"/assets/28155d54-6ff7-4abf-8ead-a209b6b7fab1.jpg\" alt=\"\"></p> \n <p>如果注释框难以解释清楚复杂问题，可以直接提供帮助手册的链接，点击跳转到新页面查看详细说明。</p> \n <p><img src=\"/assets/ba2f83ec-27f7-4121-b58f-13be143353a2.jpg\" alt=\"\"></p> \n <p>对于有一定专业基础的用户来说，提供工具书，当他遇到问题时自行查阅，比强制性的手把手教往往作用更大。</p> \n <h3 id=\"盲目满足用户需求\"><a href=\"#盲目满足用户需求\" class=\"headerlink\" title=\"盲目满足用户需求\"></a>盲目满足用户需求</h3>\n <p>参与过用户访谈和可用性测试的设计师可能会有一个体会，经常会出现「希望马上把这个用户提出的问题解决掉」的心理，「这个用户提出的问题很有价值，一定要记录下来」，「那个用户提出的抱怨确实忽略了，马上去改」。</p> \n <p>这其实是对用户的声音缺乏筛选，很多用户并不是产品人员，对于一些设计的考虑是缺乏理性的，只是片面的在抱怨一些主观意见，夹杂了很多个人的喜好。「我不喜欢这个设计，感觉怪怪的」，「这个icon我看不懂，不知道什么意思」。如果不加筛选的就听取意见，很容易就被上面的问题牵着鼻子走，造成不必要的过度设计。不仅会增加开发成本，还会丧失自己最初的设计原则。</p> \n <p>在听取用户的声音时，一定要保持冷静和理智的头脑，推演一遍真实的使用场景，判断出哪些问题是普遍存在的，哪些问题只是个人主观偏好，哪些问题改动成本小、见效快，哪些改动牵一发而动全身。不要过度满足用户需求。</p> \n <h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3>\n <p>设计不足，显得粗糙，设计过度，显得花哨。刚刚好的精妙设计与这两者的差别往往就在一念之间。对于度的把握，是需要设计师不断积累和总结才能有所提升的，注意尽量不要用自己的标准来衡量大部份用户。当一个方案考虑过多时，需要暂时重新思考，检查思维有没有陷入死胡同或者越跑越偏。想出一个解决方案时，尽量不要直接下定论，可以多与他人讨论，观察别人是否能直观、迅速地理解设计。如果没有，不要第一时间去争论和捍卫自己的方案，应该询问别人哪里觉得违和，然后不断调整和完善，慢慢找到最恰到好处的设计。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(308,12,'你如何理解用户痛点',1,'www.funtl.com/assets/QQ20150819154634.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是用户“痛点”\"><a href=\"#什么是用户“痛点”\" class=\"headerlink\" title=\"什么是用户“痛点”\"></a>什么是用户“痛点”</h3>\n <p><img src=\"/assets/QQ20150819154634.jpg\" alt=\"\"></p> \n <p><strong>本文讲的“痛点”，就是指让目标用户付出某种行动的最大阻碍。</strong></p> \n <p>比如在美图秀秀之前，大部分图像处理软件（比如 PS）都专注于提高处理图像的性能，这个时候，让用户使用图像处理软件的最大阻碍是什么呢？</p> \n <p>我想可能并不是图像处理的性能——对大多数人来说，PS 的性能已经足够好</p> \n <p><strong>这时，让用户使用图像处理软件最大的阻碍可能是易用性，因此“易用性”可能就是痛点，而抓住这一痛点，专注于提高易用性的美图秀秀就取得了初期成功。</strong></p> \n <p>好了，那么如何像当初的美图秀秀一样发现用户的痛点呢？</p> \n <p><strong>其实，只要你具备了基础信息，画一张图就够了。</strong></p> \n <p><strong>首先，画一个横向的箭头，把用户使用图像处理软件的全过程：</strong></p> \n <p><img src=\"/assets/QQ20150819154645.jpg\" alt=\"\"></p> \n <p>上面应该是一个正常用户使用图像处理软件的全部过程：先下载，然后学会怎么用，然后使用它做图片。</p> \n <p><strong>然后，你需要找出在每个阶段，影响用户行为的关键因素有哪些？</strong></p> \n <p><img src=\"/assets/QQ20150819154656.jpg\" alt=\"\"></p> \n <p>一般来说，可能影响用户行为的因素有：</p> \n <ul> \n  <li><strong>性能/效用：</strong> 这东西能不能达到我想要的效果？</li> \n  <li><strong>形象：</strong> 是不是符合我个人形象的？</li> \n  <li><strong>可靠：</strong> 是否存在风险？是否用起来不稳定？</li> \n  <li><strong>容易：</strong> 做出该行为是否很容易、不需要思考？</li> \n  <li><strong>价格：</strong> 做出该行为花钱多不多？</li> \n </ul> \n <p><strong>接着，你先把过去市场上产品聚焦点描成“橙色”：</strong></p> \n <p><img src=\"/assets/QQ20150819154835.jpg\" alt=\"\"></p> \n <p>如果具备行业的了解，你就会发现：过去，以 PS 为主的图像处理软件专注于提高性能和可靠性，同时能够帮助它的使用者塑造“专家”的积极形象。</p> \n <p>这个时候，你就需要问自己这样一个问题：</p> \n <blockquote> \n  <p>在图中的15块方格内，阻碍用户的最大因素是什么？（也就是痛点）</p> \n </blockquote> \n <p>你就会发现：下载、学习和使用 3 个过程都不够容易，而且在下载过程，往往需要付出价格。</p> \n <p><strong>然后，你就可以定位用户痛点了：</strong></p> \n <p><img src=\"/assets/QQ20150819154845.jpg\" alt=\"\"></p> \n <p><strong>为什么我们需要不停地寻找痛点？</strong></p> \n <p><strong>因为用户需求和行业都在不断变化，过去被所有人“想当然”认为是痛点的属性，很快可能就不再是痛点，而这时在大多数厂商一窝蜂聚焦于“曾经的痛点”时，你挖掘了新痛点，就可能逆流而上。</strong></p> \n <p>大多数人的思维是“基于原有的问题，我的解决方案是对的吗？”——“如何比别人更好地提高性能？”</p> \n <p>而“寻找痛点”则是考虑“我是否提出了正确的问题？”——“提高性能是不是一个好问题？如果不是，应该问什么新问题？”</p> \n <p><strong>所以，寻找用户痛点的过程，往往意味着“提出新的问题”，而不是“原有问题提出正确的解决方案。”</strong></p> \n <p>如何寻找？你可以用上面讲过的方法，画出用户的整张“痛点定位图”，寻找对用户的最大障碍来源。</p> \n <h3 id=\"纵向寻找\"><a href=\"#纵向寻找\" class=\"headerlink\" title=\"纵向寻找\"></a>纵向寻找</h3>\n <p><strong>在同一个过程中，纵向寻找阻碍用户的最大因素。</strong></p> \n <p>比如过去的胰岛素（病人买回家自己注射，用来治疗糖尿病）市场，大部分公司的聚焦点在于使用过程中的“性能”和“风险”，致力于研发更高纯度、更高稳定性的胰岛素产品。</p> \n <p>这在过去是合理的，因为比起纯度 10% 的胰岛素，纯度 50% 的胰岛素显然更能解决病人问题。</p> \n <p>但是随着大部分知名品牌胰岛素纯度都提高到 99% 以上，继续提高 0.1 个百分点的纯度虽然耗费巨额资金，但是对消费者的使用却影响甚微。</p> \n <p>这个时候，同类品牌都加入了胰岛素纯度的竞争（类似现在手机轻薄、屏幕等竞争），而 Novo Nordisk 却重新问自己这个问题：</p> \n <p><strong>此时，阻碍消费者使用最大的因素是什么？</strong></p> \n <p>然后它发现其实并不是“性能”和“风险”，而是“形象”和“容易程度”。</p> \n <ul> \n  <li><strong>形象：</strong> 胰岛素消费者其实都不想让别人知道他们是糖尿病。</li> \n  <li><strong>容易：</strong> 过去的注射器非常麻烦，需要提前消毒并且注射。</li> \n </ul> \n <p><strong>所以他们转变了战略的聚焦点，不再花费大量精力提高纯度和稳定性，而是帮助消费者提升形象和容易程度。</strong></p> \n <p><img src=\"/assets/QQ20150819154856.jpg\" alt=\"\"></p> \n <p>最终，他们研发出了这种“笔形”的胰岛素，不容易被识别，帮患者遮盖了“糖尿病人”的形象，同时不需要用针注射，提高了使用的容易程度。</p> \n <p><img src=\"/assets/QQ20150819154906.jpg\" alt=\"\"></p> \n <p>所以，纵向寻找痛点，你需要先找出影响某个环节的全部因素，然后看哪个因素是消费者现在的最大阻碍。</p> \n <h3 id=\"横向寻找\"><a href=\"#横向寻找\" class=\"headerlink\" title=\"横向寻找\"></a>横向寻找</h3>\n <p><strong>你还可以横向寻找：如果所有的竞争者都在关注用户的“使用”阶段，那么我可能应该看看其他阶段有没有痛点机会。</strong></p> \n <p>比如汽车行业，用户前后经过了购买、使用、修理、抛弃（转售）这几个环节。</p> \n <p>而在大众甲壳虫之前，欧洲所有的汽车公司几乎都聚焦于用户的“使用环节”。为用户造出性能越来越好、也越来越让人有面子的汽车。</p> \n <p><img src=\"/assets/QQ20150819154921.jpg\" alt=\"\"></p> \n <p>而甲壳虫却发现：这并不是当时对用户的最大障碍。因此适当降低了在使用阶段“效用”和“形象”上的投入，转而优化所有阶段的容易程度，同时提高使用阶段的适用性（适应更多的路面情况）。</p> \n <p><img src=\"/assets/QQ20150819154930.jpg\" alt=\"\"></p> \n <p>因此大众造出的甲壳虫外观常年不变，也不能让开车的人更有面子，但是容易买到（销售渠道）、容易驾驶、维修方便（因为使用了标准化配件）同时容易转售（因为样子常年不变）。</p> \n <p>再比如，70 年代在美国主打性价比的汽车品牌，在痛点定位图上是这样的：</p> \n <p><img src=\"/assets/QQ20150819154939.jpg\" alt=\"\"></p> \n <p>这个时候如果问：<strong>价格敏感用户的最大阻碍是什么？</strong></p> \n <p>就会发现这个关键阻碍并不发生在“购买阶段”，而是发生在“使用阶段”——因为石油危机，不论买的车多便宜，高昂的油价让人“买得起开不起”。</p> \n <p>所以，主打省油的日系车大举进入美国市场，大获成功。</p> \n <p><img src=\"/assets/QQ20150819154948.jpg\" alt=\"\"></p> \n <p>所以，寻找痛点时，可以问自己：<strong>消费者用我的产品分为哪几个阶段？现在哪个阶段是他们的关键障碍？</strong></p> \n <p>比如过去中国的手机市场是渠道为王，手机厂商几乎一半的利润分给了渠道商。通过大量的渠道，手机厂商提供了购买的便利性：</p> \n <blockquote> \n  <p>“消费者随时随地都能买到手机，可以拿在手上一一比较，而且可以当场买走，不用等待。”</p> \n </blockquote> \n <p>那么同样是1000-2000价位的手机，消费者的主要障碍发生在什么阶段呢？</p> \n <p>其实很容易发现，<strong>主要障碍发生在使用阶段（2000的手机性能太差），而不是购买阶段（想要很便利地买到）</strong>。</p> \n <p>所以这就是最初的小米手机，大部分厂商努力的重点在渠道（“购买阶段”），小米的努力重点在产品性能（“使用阶段”）。</p> \n <p><img src=\"/assets/QQ20150819155001.jpg\" alt=\"\"></p> \n <p><strong>不光可以用于寻找产品痛点，还可以用于文案痛点</strong></p> \n <p>比如肯德基搞过一个在线优惠活动，文案如下：</p> \n <p><img src=\"/assets/QQ20150819155026.jpg\" alt=\"\"></p> \n <p>如何分析这个广告呢？</p> \n <p><strong>首先我们先列出消费的行动过程：先看到文案，然后参加活动。</strong></p> \n <p><img src=\"/assets/QQ20150819155044.jpg\" alt=\"\"></p> \n <p><strong>然后找出每个阶段的主要驱动因素，比如：有兴趣、很容易做到等。</strong></p> \n <p>就会发现这个文案的聚焦点在于：提高活动的吸引力，让人产生兴趣（比如足够的优惠）。</p> \n <p><img src=\"/assets/QQ20150819155055.jpg\" alt=\"\"></p> \n <p><strong>但是如果问：现在限制消费者参加活动的关键因素是什么？</strong></p> \n <p>答案应该是：整个过程太复杂，不够容易。</p> \n <p><img src=\"/assets/QQ20150819155104.jpg\" alt=\"\"></p> \n <p><strong>这就意味着：刺激人参加活动，痛点应该是“降低复杂性”，如果不降低复杂性，一味提高奖励可能也没有作用。</strong></p> \n <p>灵活运用方法，还可以换一种方式，分析文案的有效性。</p> \n <p><strong>比如这个公益广告文案“真正的男人，不需要海豹鞭”。</strong></p> \n <p><img src=\"/assets/QQ20150819155114.jpg\" alt=\"\"></p> \n <p>首先，我们先看人认知这一广告信息的过程：</p> \n <ul> \n  <li><strong>注意：</strong> 注意到这个信息，激发了头脑的相关联想。比如看到“壮阳”联想到“性”等印象。</li> \n  <li><strong>理解：</strong> 理解这个信息的意思。</li> \n  <li><strong>信服：</strong> 信服刚刚所理解的信息。</li> \n  <li><strong>刺激行动：</strong> 因为信任这个信息而改变了行动。</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155122.jpg\" alt=\"\"></p> \n <p><strong>然后我们在纵向写上广告想要让人接受的信息。</strong></p> \n <p>比如“真正的男人不需要海豹鞭”实际上包含 2 层信息：</p> \n <ul> \n  <li>海豹鞭被认为可以壮阳</li> \n  <li>吃海豹鞭的不是真男人</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155130.jpg\" alt=\"\"></p> \n <p>然后把这个广告产生的所有影响涂成橙色，就会发现是这样的：</p> \n <p><img src=\"/assets/QQ20150819155139.jpg\" alt=\"\"></p> \n <p>用海豹鞭不是真男人”这个信息缺乏说服力，基本上只是引起了注意并且让人理解。</p> \n <p><strong>然而，通过隐含“海豹鞭被认为可以壮阳”这个信息，让很多本来没听说过海豹鞭的人，第一次知道了海豹鞭可以壮阳，并且更加信服</strong>（否则怎么会打广告说不要吃呢）。</p> \n <p>所以，这个文案很可能会起到反面效果——为海豹鞭打了广告。</p> \n <p>毕竟，如果是海豹鞭销售公司的广告文案，估计也可以这么写：</p> \n <blockquote> \n  <p>真正的男人不需要海豹鞭<br>但，如果你没有他们那么强<br>请联系我们购买：XXXX.com</p> \n </blockquote> \n <p>这也是为什么自杀相关的新闻曝光后，自杀的人会变多。</p> \n <p>总之，既然文案是为了改变用户的行为，那么设计文案的时候也要分析：</p> \n <p><strong>限制用户改变行为的关键障碍是什么？</strong></p> \n <h3 id=\"改变用户的某个习惯\"><a href=\"#改变用户的某个习惯\" class=\"headerlink\" title=\"改变用户的某个习惯\"></a>改变用户的某个习惯</h3>\n <p>除了产品设计、文案设计，其实几乎任何一种涉及改变的活动，都需要分析痛点，找到影响对方的关键障碍。</p> \n <p>比如假设你想帮助人戒烟，那么首先列出吸烟的全部过程：</p> \n <p><img src=\"/assets/QQ20150819155150.jpg\" alt=\"\"></p> \n <p>然后列出每个过程对应的影响因素，比如：</p> \n <ul> \n  <li><strong>效用：</strong> 给人带来正面体验</li> \n  <li><strong>形象：</strong> 提升形象</li> \n  <li><strong>风险：</strong> 是否有风险</li> \n  <li><strong>容易：</strong> 过程是否容易做</li> \n  <li><strong>价格：</strong> 是否需要花费很大成本</li> \n </ul> \n <p><img src=\"/assets/QQ20150819155200.jpg\" alt=\"\"></p> \n <p>找到了这个矩阵，你就会发现过去几乎所有的戒烟干预方式，都聚焦于“吸烟”这个过程，而且是“吸烟”的风险这个过程：</p> \n <p>（强调：吸烟有害健康）</p> \n <p><img src=\"/assets/QQ20150819155212.jpg\" alt=\"\"></p> \n <p>比如这个创意广告：</p> \n <p><img src=\"/assets/QQ20150819155219.jpg\" alt=\"\"></p> \n <p>而其实可以有效干预的痛点有很多：</p> \n <p><img src=\"/assets/QQ20150819155228.jpg\" alt=\"\"></p> \n <p>比如降低送烟的形象，想办法让送烟变成一种丢脸的行为。</p> \n <p>比如降低吸烟的效用，让大众相信吸烟其实并不会提高注意力，等。</p> \n <p><img src=\"/assets/QQ20150819155236.jpg\" alt=\"\"></p> \n <p><strong>甚至，构思这篇文章本身，李叫兽也在定位痛点：</strong></p> \n <p>我的目标是让读者更多地学会如何定位用户的痛点。</p> \n <p><strong>首先，我列出了定位用户痛点的过程：</strong></p> \n <p>收集信息、了解哪些感受可以改变行为（心理学理论）、综合利用信息和理论。</p> \n <p><strong>然后每个过程，都需要让读者“想要”这样做，并且“容易”做到（讲技巧）</strong></p> \n <p>最终，我发现读者看文章只有 3 分钟时间，不可能把所有的心理学理论概括清楚，也讲不完用户调查方法。而且发现大部分人的关键问题并不是信息或者知识太少，而是没有巧妙地利用这些知识。</p> \n <p><strong>所以把这篇文章解决的痛点定位成了最右下角的一部分：</strong></p> \n <p><img src=\"/assets/QQ20150819155245.jpg\" alt=\"\"></p> \n <h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3>\n <p>很多人没有找到用户的痛点，并不是因为欠缺信息（比如不知道用户怎么想的），而是没有有效地利用已有信息。</p> \n <p>而如果你重新思考自己已经知道的，分析用户的每个动作过程，就会发现：痛点更容易找到！</p> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(309,12,'你如何考虑组件化',1,'www.funtl.com/assets/组件化.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"组件化与模块化\"><a href=\"#组件化与模块化\" class=\"headerlink\" title=\"组件化与模块化\"></a>组件化与模块化</h3>\n <p>首先来谈两个前端和移动端比较常见的词：<code>组件化</code> 和 <code>模块化</code></p> \n <p>首先，可以肯定的是，组件化和模块化的中心思想都是 <code>分而治之</code>。目的都是将一个庞大的系统拆分成多个组件或者说是模块。</p> \n <p><img src=\"/assets/组件化.jpg\" alt=\"\"></p> \n <h4 id=\"组件化\"><a href=\"#组件化\" class=\"headerlink\" title=\"组件化\"></a>组件化</h4>\n <p>组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是 <strong>减少耦合</strong>。</p> \n <blockquote> \n  <p>一个独立的组件可以是一个软件包、WEB 服务、WEB 资源或者是封装了一些函数的模块。这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件。</p> \n </blockquote> \n <h4 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h4>\n <p>模块化的目的在于将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容，模块之间通过接口调用。将一个大的系统模块化之后，每个模块都可以被高度复用。</p> \n <h4 id=\"模块化和组件化的区别\"><a href=\"#模块化和组件化的区别\" class=\"headerlink\" title=\"模块化和组件化的区别\"></a>模块化和组件化的区别</h4>\n <p>从上面的定义中可以看出，组件化和模块化的意思差不多，主要思想都是分而治之。只是一个把拆分之后的每个片段叫做组件、另一个把拆分之后的片段叫做模块。那么这两种拆分在拆分方式上是不是有什么不同的？</p> \n <p>关于组件化和模块化的区别，我在网上看了好多资料，也没有人能给出准确的回答。其实没有准确回答的原因也比较明显，那就是大多数时候我们真的不需要严格的区分这两个名字。我们要学习的是其中的解耦和分治的思想和目的。</p> \n <p>从另外一个角度来讲，如果真的要区分一下组件化和模块化的话，那么可以认为这两种分而治之的目的稍有区别：</p> \n <ul> \n  <li>模块化的目的是为了 <code>重用</code>，模块化后可以方便重复使用和插拨到不同的平台，不同的业务逻辑过程中。</li> \n  <li>组件化的目的是为了 <code>解耦</code>，把系统拆分成多个组件，分离组件边界和责任，便于独立升级和维护。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(310,12,'你如何划分领域边界',1,'www.funtl.com/assets/201112241000166739.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"【领域驱动设计】浅谈聚合的划分与设计\"><a href=\"#【领域驱动设计】浅谈聚合的划分与设计\" class=\"headerlink\" title=\"【领域驱动设计】浅谈聚合的划分与设计\"></a>【领域驱动设计】浅谈聚合的划分与设计</h3>\n <p>聚合以及聚合根是领域驱动设计中的重要概念，根据定义，聚合是针对数据变化可以考虑成一个单元的一组相关的对象。聚合使用边界将内部和外部的对象划分开来。每个聚合有一个根。这个根是一个实体，并且它是外部可以访问的唯一的对象。根可以保持对任意聚合对象的引用，并且其他的对象可以持有任意其他的对象，但一个外部对象只能持有根对象的引用。如果边界内有其他的实体，那些实体的标识符是本地化的，只在聚合内有意义（参见《领域驱动设计-精简版》第42页）。从定义上看，貌似针对特定上下文的领域模型来讲，聚合的划分与设计并不那么困难，但事实却并非如此。在本文中，我将大致总结一下自己的经验，同时也欢迎关注领域驱动设计的朋友能够提出自己的见解。</p> \n <h3 id=\"聚合划分与设计其实与并发和事务性并不矛盾\"><a href=\"#聚合划分与设计其实与并发和事务性并不矛盾\" class=\"headerlink\" title=\"聚合划分与设计其实与并发和事务性并不矛盾\"></a>聚合划分与设计其实与并发和事务性并不矛盾</h3>\n <p>首先需要了解的是，合理地划分和设计聚合，并不会产生任何并发和事务性问题。我们所讨论的文章中之所以第一个设计方案会出现并发和事务性问题，就是因为它的聚合设计本身就不合理。这其实在本文一开始就明确了这个问题：聚合是针对数据变化可以考虑成一个单元的一组相关的对象。因此，必须承认对于一个聚合，其中包含的所有对象必须“同生死，共存亡”，基于聚合的数据操作应该就是原子操作，基础结构机制需要保证以聚合为单位的数据一致性。换句话说，聚合在数据一致性方面的表现，应该与基础结构机制所保证的并发和事务的正确性是等价的。数据访问时出现的事务失效现象，其实是源于聚合的不合理划分。比如，在《Effective Aggregate Design》一文中的例子里，事实上 Product 并不一定要依赖于 Release 才能存在，因此，在 Product 的聚合中，就不应该包含对 Release 的引用，然而相反，Release 是没法脱离 Product 而单独存在的，因为如果是这样的话，Release 也就失去了本身的含义，所以，Release 可以定义成一个聚合，而 Product 则是这个聚合中的一个实体。</p> \n <p>至此，我们可以得知，聚合的划分和设计必须依赖对通用语言、领域概念和模型的正确把握。接下来再让我们看两个我们经常遇到的例子：销售订单和论坛主题。</p> \n <h3 id=\"两个例子：销售订单（Sales-Order）-订单明细（Sales-Line）-vs-论坛主题（Post）-回复（Reply）\"><a href=\"#两个例子：销售订单（Sales-Order）-订单明细（Sales-Line）-vs-论坛主题（Post）-回复（Reply）\" class=\"headerlink\" title=\"两个例子：销售订单（Sales Order）/订单明细（Sales Line） vs. 论坛主题（Post）/回复（Reply）\"></a>两个例子：销售订单（Sales Order）/订单明细（Sales Line） vs. 论坛主题（Post）/回复（Reply）</h3>\n <p>很多网友会在这两个领域的建模上感到纠结，如果我们从数据库设计上考虑（以数据库驱动的开发方式进行思考），两者非常相似，都是主从表结构，都是1对多（1:N）的关系：一个销售订单对应多条订单明细，一个论坛主题对应多条回复。但如果我们用领域驱动的思想来考虑这个问题，我们会发现，这是两个截然不同的例子！两个例子中实体之间的关系完全不同。</p> \n <p>首先分析销售订单（Sales Order）/订单明细（Sales Line）：对于一张销售订单来说，订单明细是不可缺少的，否则就不成其为销售订单。试想，一张订单没有包含任何购买的货品信息，这意味着什么？因此，销售订单和订单明细之间的关系是一种固定的不可变（invariant）的关系，就像《领域驱动设计》一书中所讲的汽车与车轮之间的关系那样，汽车少了轮子就不成其为汽车了。反过来看，订单明细也离不开销售订单，这很简单，因为很明细订单明细是描述销售订单的一个不可或缺的部分。于是，在这个例子中，我们有一个聚合根为销售订单，其中包含一条或多条订单明细的聚合，聚合及其实体间的关系可以用下图表示：</p> \n <p><img src=\"/assets/201112241000166739.png\" alt=\"\"></p> \n <p>对于论坛主题（Post）/回复（Reply）之间的关系，情况却完全不同。论坛的主题是可以脱离回复单独存在的（一个主题可以没有任何人对其进行回复），而回复却不能脱离主题（没有主题的回复是没有意义的）。鉴于这样的事实，实际上在主题与回复这部分模型中，存在两个聚合：第一个聚合是以主题（Post）为聚合根，且仅包含其本身一个对象的聚合；另一个聚合是以回复（Reply）为聚合根，其中包含了对主题（Post）的引用的聚合。其关系可以如下表示：</p> \n <p><img src=\"/assets/201112241000175966.png\" alt=\"\"></p> \n <p>这样的设计，会让有些朋友感到不适应，原因是我们无法直接从Post实体获得其下所有的Reply实体，那么对于“通过给定的Post，获得与它相关的所有Reply信息”这样的用例，在实现上就不那么直接。此时，我们需要在应用层，通过Reply的仓储来获得，比如：</p> \n <pre><code>public IEnumerable&lt;ReplyDataObject&gt; GetRepliesForPost(Guid postId)\n{\n    using (IRepositoryContext context = IoCFactory.GetService&lt;IRepositoryContext&gt;();\n    {\n        ISpecification&lt;Reply&gt; spec = Specification&lt;Reply&gt;.Eval(r =&gt; r.Post.Id == postId);\n        IRepository&lt;Reply&gt; replyRepository = context.GetRepository&lt;Reply&gt;();\n        IEnumerable&lt;Reply&gt; replies = replyRepository.FindAll(spec);\n        List&lt;ReplyDataObject&gt; result = new List&lt;ReplyDataObject&gt;();\n        if (replies != null)\n        {\n                replies.ToList().ForEach(r =&gt; result.Add(DataObjectMapper.MapToDataObject(r));\n        }\n        return result;\n    }\n}\n</code></pre>\n <p>这部分内容牵涉到了应用层，或许你会觉得，这样做是不是把业务逻辑迁移到了应用层，导致领域模型失血。其实不然，在这里，应用层并没有参与任何业务逻辑，从仓储读取领域对象以及将领域对象转换成数据传输对象（DTO），这些并不属于业务逻辑的范畴：因为从领域模型和业务逻辑的角度看，它们并不能知道什么是仓储、什么是规约、什么是数据传输对象。应用层在这里起到了任务协调、数据转换等作用。不仅如此，应用层甚至还可以包含业务规则引擎以及工作流的实现（workflow）。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:04','2018-12-20 22:06:04'),
(311,12,'说说概要设计',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>概要设计是一个设计师根据用户交互过程和用户需求来形成交互框架和视觉框架的过程，其结果往往以反映交互控件布置、界面元素分组以及界面整体板式的页面框架图的形式来呈现。这是一个在用户研究和设计之间架起桥梁，使用户研究和设计无缝结合，将对用户目标与需求转换成具体界面设计解决方案的重要阶段。</p> \n <p>概要设计的主要任务是把需求分析得到的系统扩展用例图转换为软件结构和数据结构。设计软件结构的具体任务是：将一个复杂系统按功能进行模块划分、建立模块的层次结构及调用关系、确定模块间的接口及人机界面等。数据结构设计包括数据特征的描述、确定数据的结构特性、以及数据库的设计。显然，概要设计建立的是目标系统的逻辑模型，与计算机无关。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:05','2018-12-20 22:06:05'),
(312,12,'你如何考虑服务化',1,'www.funtl.com/assets/fenbu.jpg',1,'<div class=\"col-sm-12\"> \n <h3 id=\"集中式与分布式\"><a href=\"#集中式与分布式\" class=\"headerlink\" title=\"集中式与分布式\"></a>集中式与分布式</h3>\n <p>要谈微服务，那么必须建立在分布式的基础上，对于一个集中式系统也无需谈微服务。</p> \n <p><img src=\"/assets/fenbu.jpg\" alt=\"\"></p> \n <h4 id=\"集中式\"><a href=\"#集中式\" class=\"headerlink\" title=\"集中式\"></a>集中式</h4>\n <p>集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力，仅负责数据的录入和输出。而运算、存储等全部在主机上进行。</p> \n <p>集中式系统的最大的特点就是部署结构非常简单，底层一般采用从IBM、HP等厂商购买到的昂贵的大型主机。因此无需考虑如何对服务进行多节点的部署，也就不用考虑各节点之间的分布式协作问题。但是，由于采用单机部署。很可能带来系统大而复杂、难于维护、发生单点故障（单个点发生故障的时候会波及到整个系统或者网络，从而导致整个系统或者网络的瘫痪）、扩展性差等问题。</p> \n <h4 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h4>\n <p>分布式就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p> \n <p>拿电商网站来说，我们一般把一个电商网站横向拆分成商品模块、订单模块、购物车模块、消息模块、支付模块等。然后我们把不同的模块部署到不同的机器上，各个模块之间通过远程服务调用(<code>RPC</code>)等方式进行通信。以一个分布式的系统对外提供服务。</p> \n <h3 id=\"服务化\"><a href=\"#服务化\" class=\"headerlink\" title=\"服务化\"></a>服务化</h3>\n <p>提到分布式，一个不得不提的词就是服务化，服务化架构使搭建分布式系统成为了可能。</p> \n <p>传统的软件开发面临着很多的问题，比如： 代码重复率高、代码庞大难以维护、无法快速迭代、测试成本高、可伸缩性差、可靠性差、模块间高度依赖。为了解决上面这些问题，我们一般采用拆分、解耦、分层、独立等方式来解决。有了服务化架构，我们就可以在很大程度上解决这些问题。</p> \n <blockquote> \n  <p>服务化是一种粗粒度、松耦合的以服务为中心的架构，服务之间通过定义明确的协议和接口进行通信。</p> \n </blockquote> \n <p>这里说到的“服务”，本质上来说，就是指“RPC”。单纯的RPC功能实现，其实很简单，无非就是client发起调用，中间某个组件（甚至就是client本身）拦截调用信息，序列化后将信息传输到server端，server端收到调用请求后反序列化，根据请求详细发起实际调用后返回响应传输回给client端。这样的RPC很常见，比如常见的存储过程调用就是一例。但是在一个复杂的业务环境，如何管理和协同这些大量的RPC才是最麻烦的事情。所以，一般提到的“服务化”更多指的是对RPC的管理。服务化一般关注服务注册，服务协调，服务可用性，服务通讯协议和内容交换等。</p> \n <p><img src=\"/assets/RPC.jpg\" alt=\"\"></p> \n <h3 id=\"面向服务的架构\"><a href=\"#面向服务的架构\" class=\"headerlink\" title=\"面向服务的架构\"></a>面向服务的架构</h3>\n <p>面向服务架构（Service-Oriented Architecture，<code>SOA</code>）又称“面向服务的体系结构”，是Gartner于2O世纪9O年代中期提出的面向服务架构的概念。</p> \n <blockquote> \n  <p>面向服务架构，从语义上说，它与面向过程、面向对象、面向组件一样，是一种软件组建及开发的方式。与以往的软件开发、架构模式一样，SOA 只是一种体系、一种思想，而不是某种具体的软件产品。</p> \n </blockquote> \n <p><img src=\"/assets/SOA.jpg\" alt=\"\"></p> \n <p>这里，我们通过一个例子来解释一下到底什么是 SOA？如何做到 SOA？</p> \n <h4 id=\"什么是-SOA\"><a href=\"#什么是-SOA\" class=\"headerlink\" title=\"什么是 SOA\"></a>什么是 SOA</h4>\n <p>SOA 也可以说是一种是设计原则（模式），那么它包含哪些内容呢？事实上，这方面并没有最标准的答案，多数是遵从著名 SOA 专家 Thomas Erl 的归纳：</p> \n <ul> \n  <li>标准化的服务契约 Standardized service contract</li> \n  <li>服务的松耦合 Service loose coupling</li> \n  <li>服务的抽象 Service abstraction</li> \n  <li>服务的可重用性 Service reusability</li> \n  <li>服务的自治性 Service autonomy</li> \n  <li>服务的无状态性 Service statelessness</li> \n  <li>服务的可发现性 Service discoverability</li> \n  <li>服务的可组合性 Service composability</li> \n </ul> \n <p>这些原则总的来说要达到的目的是：提高软件的重用性，减少开发和维护的成本，最终增加一个公司业务的敏捷度。既然是面向服务的架构，那么我们就先来定义一个服务，</p> \n <pre><code>public interface Echo {\n    String echo(String text);\n}\n\npublic class EchoImpl implements Echo {\n    public String echo(String text) {\n        return text;\n    }\n}\n</code></pre>\n <p>上面这段代码相信有过 JavaWeb 开发经验的人都不会陌生。就是定义了一个服务的接口和实现。</p> \n <p>那么，定义了服务，我们就做到了 SOA 了么？</p> \n <p>我们用 Thomas Erl 定义的原则来对比一下，用松耦合和可重用这几个原则来尝试分析一下上面 Echo 示例：</p> \n <ul> \n  <li>Echo 的服务契约是用 Java 接口定义，而不是一种与平台和语言无关的标准化协议，如 WSDL，CORBA IDL。当然可以抬杠，Java 也是行业标准，甚至全国牙防组一致认定的东西也是行业标准。</li> \n  <li>Java 接口大大加重了与 Service 客户端的耦合度，即要求客户端必须也是 Java，或者 JVM 上的动态语言（如Groovy、Jython）等等……</li> \n  <li>同时，Echo 是一个 Java 的本地接口，就要求调用者最好在同一个 JVM 进程之内……</li> \n  <li>Echo 的业务逻辑虽然简单独立，但以上技术方面的局限就导致它无法以后在其他场合被轻易重用，比如分布式环境，异构平台等等 ESB 是 SCA 思想实现的基础设施。ESB 主要作用是集中注册发布服务，为服务与传输协议之间解耦。并不是所有的 SOA 架构都需要 ESB，ESB 是 SCA 特有的。当然任何符合 ESB 特征的解决方式都可以称之为 ESB，也不仅仅是 SCA 内部的。</li> \n </ul> \n <p>因此，我们可以认为 Echo 并不太符合 SOA 的基本设计原则。</p> \n <h4 id=\"实现-SOA\"><a href=\"#实现-SOA\" class=\"headerlink\" title=\"实现 SOA\"></a>实现 SOA</h4>\n <p>修改一下上面的 Echo，添加 Java EE 的 <code>@WebServices</code> 注解</p> \n <pre><code>@WebServices\npublic class EchoImpl implements Echo {\n    public String echo(String text) {\n        return text;\n    }\n}\n</code></pre>\n <p>现在将 Echo 发布为 Java WebServices，并由底层框架自动生成 WSDL 来作为标准化的服务契约，这样就能与远程的各种语言和平台互操作了，较好的解决了上面提到的松耦合和可重用的问题。按照一般的理解，Echo 似乎就成为比较理想的 SOA service了。</p> \n <p>使用 WebServices 只是一种相对简单的方案，SOA 的最常见的解决方案是 SCA，其次还有 JBI，BPEL 等。ESB 是 SCA 思想实现的基础设施。ESB 主要作用是集中注册发布服务，为服务与传输协议之间解耦。关于 SCA 和 ESB 并不是本文的重点，感兴趣的朋友可以从网络上获取更多资料。(可以从上图中看到 ESB 在整个 SOA 架构中所扮演的角色)</p> \n <h3 id=\"面向对象和面向服务的对比\"><a href=\"#面向对象和面向服务的对比\" class=\"headerlink\" title=\"面向对象和面向服务的对比\"></a>面向对象和面向服务的对比</h3>\n <p>面向对象（<code>OO</code>）和面向服务（<code>SO</code>）在基础理念上有大量共通之处，比如都尽可能追求抽象、封装和低耦合。</p> \n <p>但 SO 相对于 OO，又有非常不同的典型应用场景，比如：</p> \n <ul> \n  <li>多数 OO 接口（interface）都只被有限的人使用（比如团队和部门内），而 SO 接口（或者叫契约）一般来说都不应该对使用者的范围作出太多的限定和假设（可以是不同部门，不同企业，不同国家）。还记得贝佐斯原则吗？“团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外”。</li> \n  <li>多数 OO 接口都只在进程内被访问，而 SO 接口通常都是被远程调用。</li> \n </ul> \n <p>简单讲，就是 SO 接口使用范围比一般 OO 接口可能广泛得多。我们用网站打个比方：一个大型网站的 web 界面就是它整个系统入口点和边界，可能要面对全世界的访问者（所以经常会做国际化之类的工作），而系统内部传统的 OO 接口和程序则被隐藏在 web 界面之后，只被内部较小范围使用。而理想的 SO 接口和 web 界面一样，也是变成系统入口和边界，可能要对全世界开发者开放，因此 SO 在设计开发之中与 OO 相比其实会有很多不同。</p> \n <h3 id=\"微服务架构\"><a href=\"#微服务架构\" class=\"headerlink\" title=\"微服务架构\"></a>微服务架构</h3>\n <p>微服务架构(<code>MicroService</code>)是一种服务化架构风格，通过将功能分散到各个离散的服务中以实现对解决方案的解耦。微服务架构强调的第一个重点就是业务系统需要彻底的组件化和服务化（这也是我们为什么要先介绍组件化和服务化的原因）。微服务的诞生并非偶然。它是互联网高速发展，敏捷、精益、持续交付方法论的深入人心，虚拟化技术与 DevOps 文化的快速发展以及传统单块架构无法适应快速变化等多重因素的推动下所诞生的产物。</p> \n <p>微服务的流行，Martin 功不可没，先看看他是如何定义微服务的：</p> \n <ul> \n  <li>一些列的独立的服务共同组成系统</li> \n  <li>单独部署，跑在自己的进程里</li> \n  <li>每个服务为独立的业务开发</li> \n  <li>分布式的管理</li> \n </ul> \n <p>Martin 自己也说了，每个人对微服务都可以有自己的理解，不过大概的标准还是有一些的。</p> \n <ul> \n  <li>分布式服务组成的系统</li> \n  <li>按照业务而不是技术来划分组织</li> \n  <li>做有生命的产品而不是项目</li> \n  <li>Smart endpoints and dumb pipes（我的理解是强服务个体和弱通信）</li> \n  <li>自动化运维（DevOps）</li> \n  <li>容错</li> \n  <li>快速演化</li> \n </ul> \n <h3 id=\"SOA-和微服务\"><a href=\"#SOA-和微服务\" class=\"headerlink\" title=\"SOA 和微服务\"></a>SOA 和微服务</h3>\n <p>看了 SOA 和微服务，很多人会认为这不就是一回事儿么。其实 SOA 和微服务就是差不多的。</p> \n <ul> \n  <li>SOA 关注的是服务重用，微服务在关注服务重用的同时，也同时关注快速交付；</li> \n  <li>微服务不再强调传统 SOA 架构里面比较重的 ESB 企业服务总线。微服务把所有的“思考”逻辑包括路由、消息解析等放在服务内部，去掉一个大一统的 ESB，服务间轻通信，是比 SOA 更彻底的拆分。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:05','2018-12-20 22:06:05'),
(313,12,'你如何进行领域建模',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"运用四色建模法进行领域分析\"><a href=\"#运用四色建模法进行领域分析\" class=\"headerlink\" title=\"运用四色建模法进行领域分析\"></a>运用四色建模法进行领域分析</h3>\n <p>领域建模有很多种方法，对于同样的问题域使用不同的建模手段得到的模型可能也不尽相同。于是我经常听到这样一个问题：怎么才能保证建模的正确性？</p> \n <p>这听起来是个合理的质疑，但实际上却不是那么有道理。首先我们需要明白建模的目的是什么？如果仅仅是为了描画问题，那么并没有什么对错之分——仅仅是立场和角度的差别；而如果是为了企业业务系统而进行建模，那么这个问题应该变为：如何保证模型能够支撑企业的运营？</p> \n <p><strong>我想用下面这个例子来简要的回答一下这个问题。</strong></p> \n <p>在开始分析和建模之前，我们需要知道企业业务系统的目的是什么；而企业业务系统的目的往往跟决策者或者管理的诉求相关。我们现在需要移情到一位管理者身上，看看他的诉求到底是什么。</p> \n <p>现在假想你是一家在线电子书店的 COO。突然有一天，有一位顾客向你投诉，说他订购的书少了一本，并且价钱算错了，他多给了钱。在你承诺理赔之前，你需要核对一下这位顾客说的是否属实。那么这个时候你需要知道什么样的信息才能做出准确的判断呢？</p> \n <p>简单来说，你需要知道这位顾客订购了那些书籍，付了多少钱以及书店到底为这个顾客递送了那些书籍。不幸的是，由于科技不够发达，你无法直接驾驶时间机器回到从前去亲眼看看发生了那些事。但幸运的是，你并不需要这么做，你只需要看看这位顾客的订单，和网银的支付记录以及你们书店交给EMS的快递单存根，就应该知道这些信息了。</p> \n <p>你找到了订单和 EMS 快递存根。发现这位顾客是在三天前订购的书，而你们在前天就已经将书邮寄出去了。并在订单上看到这位顾客一共订购了7本书，但是在EMS的快递存根上，并没有任何书籍的信息，只有地址，包裹号，邮费和重量什么的信息。这时候你觉得应该去询问一下配送部门，看看他们做了什么。</p> \n <p>在配送部门你根据包裹号查到了那个包裹的信息，果然里面只有6本书。同时你在包裹部门发现了一张延期交货单。上面说明由于缺货，这位顾客另外一本书正在等待发货。</p> \n <p>那么剩下的问题就是支付问题了，从网银的记录上看，客户不含邮费一共支付了132.5。订单上显示的价钱也是132.5，显然这位顾客并没有多付钱。</p> \n <p>为了保证准确，你重新从网站上选了这7本书，想看看是否也会是这个价钱。但你却意外的发现，一共只需要128.3。仔细辨认后，你发现有一本图书现在是促销。那么现在的问题是，促销到底是什么时候开始的？</p> \n <p>你到了市场部，市场部给了你一份近期促销计划。你发现那本书是昨天才开始促销的，也就是说在那位顾客在下订单的时候，促销还没有开始。</p> \n <p>这个时候，你觉得应该给你的顾客打一个电话致歉，商讨如何后续邮寄的问题，并向他说明促销的事情。</p> \n <p>你是否觉得这个 COO 当得有点累呢？这当然是虚构的。但是从这故事里面我们看到什么呢？</p> \n <p><strong>任何的业务事件都会以某种数据的形式留下足迹</strong></p> \n <p>我们对于事件的追溯可以通过对数据的追溯来完成。正如上面这个故事里，你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度的还原当时事情发生的场景。当我们把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰的推测出这个在过往的一段时间内到底发生了那些事情。</p> \n <p>那么为什么这些数据形成的链条能够成帮助我们追溯业务的营运呢？</p> \n <p>因为这些数据并不是随便挑选的。如果我们回顾一下你作为COO检查这个疏漏的过程，你首先选择了订单和EMS快递存根，换句话说，如果订单出现差错，或者EMS快递存根上说明你的确邮寄了7本书，那么这个疏漏的责任并不在你。所以这两个订单实际上这个你这个企业法律责任的起点和终点。</p> \n <p>当你确定这个疏漏的责任在你之后，你选择审查一些<strong>流程执行的结果</strong>，比如包裹存根。从而验证一些主要的业务流程执行的结果是否正确。换句话讲，这些数据是<strong>支撑你运营体系的关键流程的执行结果</strong>。</p> \n <p>正是由于这些数据是流程执行的结果，它们才使我们可以在不了解流程细节的前提下，对某些突发事件进行追述和分析。</p> \n <p>除了上面那个极端的例子（投诉），对于任何一笔正常的经济往来，我们都需要知道：</p> \n <ol> \n  <li>如果我付出一笔资金，那么我的权益是什么？</li> \n  <li>如果我收到一笔资金，那么我的义务是什么？</li> \n </ol> \n <p>而这些问题都需要业务系统捕捉到相应的足迹才能够回答。所以企业的业务系统主要的目的之一，就是记录这些足迹，并将这些足迹形成一条有效的追溯链。</p> \n <p>而作为业务分析师的你，则应该知道那些事件在运营上是需要追溯的，这些事件都留下了什么足迹。</p> \n <p>这些足迹通常都具有一个有意思的特性，即它们都是时标性对象（moment-interval）。发现这些时标性对象就是建模的起点。对于这些时标性对象稍加整理，我们就得到了整个领域模型的骨干：</p> \n <p>在得到骨干之后，我们需要丰富这个模型，使它可以更好的描述业务概念。这时候，我们需要补充一些实体对象。通常实体对象有三类：人，地点， 物（party/place/thing）。</p> \n <p>在这个基础上，我们可以进一步抽象这些实体事如果参与到各种不同的流程中去的，这时候，我们就需要用到角色（role）：</p> \n <p>最后再把一些需要描述的信息放入描述对象（description）。</p> \n <p>我们就得了应用四色建模方法（color modeling）建立的一套领域模型。</p> \n <p><strong>简要回顾一下上面的过程，不难发现我们建模的次序和重点：</strong></p> \n <ol> \n  <li>首先以满足管理和运营的需要为前提，寻找需要追溯的事件。</li> \n  <li>根据这些需要追溯，寻找足迹以及相应的时标性对象。</li> \n  <li>寻找时标对象周围的人／事／物</li> \n  <li>从中抽象角色</li> \n  <li>把一些信息用描述对象补足。</li> \n </ol> \n <p>由于在第一步中，我们就将管理和运营目标做为建模的出发点。因此，整套模型实际上是围绕这些“如何有效地追踪这些目标”而建立的，这样的模型可以保证模型支撑企业的运营。</p> \n <h3 id=\"四色建模法\"><a href=\"#四色建模法\" class=\"headerlink\" title=\"四色建模法\"></a>四色建模法</h3>\n <p>(Color UML)是由 Peter Coad 发明的一种建模方法，将抽象出来的对象分成四种原型（archetype）：</p> \n <ol> \n  <li>moment-interval：这种对象表示那些在某个时间点存在，或者会存在一段时间的，这样的对象往往表示了一次外界的请求，比如一次询价（Quotation），一次购买（Sale），这样的对象表示的都是系统的价值所在，所以也是最重要的一类对象，一般用粉红色来表示。这样的对象一般都有一个起始时间和终止时间，以及一个唯一的标识号，用来唯一的标识这一次客户请求，比如 PolicyNo.</li> \n  <li>Role：这种对象表示的是一种角色，往往由人或者物来承担，会有相应的责任和权利，一般一个 moment-interval 对象会关联多个 Role,比如说一次询价（Quotation）涉及到两个 Role, 询价人（Quoter）和询价的产品（Product for Quotation）, 这类对象是除 moment-interval 对象外最重要的一类对象，一般用黄色来表示。这类对象一般都有一些被 moment-interval 对象请求的操作，用来完成它们的职责。</li> \n  <li>Party：Place or Thing, 这种对象往往表示的是一种客观存在的事物，例如：人，组织，产品，配件等等，这些事物往往会在一种 moment-interval 中扮演某个 Role, 比如某个人会在一次购买中扮演 Customer 的角色，也可以在询价中扮演询价人的角色。这类对象第三重要，所以一般用绿色来表示。这类对象一般都有 Name, Address 等属性。</li> \n  <li>Description：这种对象一般是分类用或者描述性的对象，一般某个 Thing, Place，Party会属于某个 Description，主要用来表示一类事物，它的属性一般都是这一类事物都有的属性，这类对象一般用蓝色来表示。这类对象一般都有 type, defaultValue 等属性。</li> \n </ol> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>通过将分析得到的领域对象分别归入这四类原型，能让我们更加深刻的理解每个对象的职责，以及对象之间的相互关系，通过四种颜色，能表达出比一般的黑白模型更加丰富的领域信息。</p> \n <p>四色建模法和别的建模方法相比，更倾向于作为一种分析方法，而不是设计方法，它也可以看作是一种分析模式，和 Martin Fowler 的《分析模式》有异曲同工之妙。在《Java Modeling in Color with UML》这本书中，Peter Coad 给出了多个行业的通用对象模型，包括制造业，资源管理，人力资源管理，财务管理等等，当然都是用四色建模法表示的，确实有耳目一新之感。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:05','2018-12-20 22:06:05'),
(314,3,'Java 单体应用',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24437270/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-上</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437288/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-中</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437300/\" target=\"_blank\" rel=\"noopener\">【视频】开篇-程序员的玄学与佛学-下</a></li> \n </ul> \n <h3 id=\"第-01-章-使用-Intellij-IDEA\"><a href=\"#第-01-章-使用-Intellij-IDEA\" class=\"headerlink\" title=\"第 01 章 使用 Intellij IDEA\"></a>第 01 章 使用 Intellij IDEA</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24437425/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/IDEA-简介/\">IDEA 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437719/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/第一个-IDEA-应用程序/\">第一个 IDEA 应用程序</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24437746/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-使用 Markdown 记笔记</a></li> \n </ul> \n <h3 id=\"第-02-章-使用-Maven-构建应用\"><a href=\"#第-02-章-使用-Maven-构建应用\" class=\"headerlink\" title=\"第 02 章 使用 Maven 构建应用\"></a>第 02 章 使用 Maven 构建应用</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24451433/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-简介/\">Maven 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24451908/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-安装配置/\">Maven 安装配置</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24451974/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-本地仓库/\">Maven 本地仓库</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24454166/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-中央仓库/\">Maven 中央仓库</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455290/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-依赖机制/\">Maven 依赖机制</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455333/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-POM/\">Maven POM</a></li> \n  <li><a href=\"/2018/06/03/monolithic/Maven-插件/\">Maven 插件</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455373/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/Maven-快照/\">Maven 快照</a></li> \n  <li><a href=\"/2018/06/03/monolithic/Maven-常用命令/\">Maven 常用命令</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24455466/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/03/monolithic/第一个-Maven-应用程序/\">第一个 Maven 应用程序</a></li> \n </ul> \n <h3 id=\"第-03-章-三层架构-MVC\"><a href=\"#第-03-章-三层架构-MVC\" class=\"headerlink\" title=\"第 03 章 三层架构 + MVC\"></a>第 03 章 三层架构 + MVC</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24480245/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/04/monolithic/什么是三层架构/\">什么是三层架构</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480269/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/04/monolithic/什么是-MVC-模式/\">什么是 MVC 模式</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480283/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-高内聚，低耦合</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480296/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-三层架构-1</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24480336/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-三层架构-2</a></li> \n </ul> \n <h3 id=\"第-04-章-使用-Bootstrap\"><a href=\"#第-04-章-使用-Bootstrap\" class=\"headerlink\" title=\"第 04 章 使用 Bootstrap\"></a>第 04 章 使用 Bootstrap</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24480397/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-关于如何自学的一些心得</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24481998/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-简介/\">Bootstrap 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482476/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-环境安装/\">Bootstrap 环境安装</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482487/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-网格系统/\">Bootstrap 网格系统</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482488/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/媒体查询的用法/\">媒体查询的用法</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482490/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-表格/\">Bootstrap 表格</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24482495/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/06/monolithic/Bootstrap-字体图标/\">Bootstrap 字体图标</a></li> \n </ul> \n <h3 id=\"第-05-章-基础框架入门\"><a href=\"#第-05-章-基础框架入门\" class=\"headerlink\" title=\"第 05 章 基础框架入门\"></a>第 05 章 基础框架入门</h3>\n <ul> \n  <li><h4 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509363/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-简介/\">Spring 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509385/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-体系结构/\">Spring 体系结构</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509422/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-的特点/\">Spring 的特点</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509478/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Spring-与-IoC/\">Spring 与 IoC</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509521/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-Spring-应用程序/\">第一个 Spring 应用程序</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"JUnit-单元测试\"><a href=\"#JUnit-单元测试\" class=\"headerlink\" title=\"JUnit 单元测试\"></a>JUnit 单元测试</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509803/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-什么是 TDD 及常见的测试方式</a> </li> \n    <li><a href=\"https://www.bilibili.com/video/av24509763/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/JUnit-简介/\">JUnit 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509731/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-JUnit-单元测试/\">第一个 JUnit 单元测试</a></li> \n    <li><a href=\"/2018/06/07/monolithic/JUnit-注解/\">JUnit 注解</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509691/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/JUnit-断言/\">JUnit 断言</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"Log4j-日志框架\"><a href=\"#Log4j-日志框架\" class=\"headerlink\" title=\"Log4j 日志框架\"></a>Log4j 日志框架</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24509656/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-简介/\">Log4j 简介</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509628/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-日志级别/\">Log4j 日志级别</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509595/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/Log4j-日志输出控制文件/\">Log4j 日志输出控制文件</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24509552/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/07/monolithic/第一个-Log4j-日志文件/\">第一个 Log4j 日志文件（使用 Slf4j 输出）</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"综合复习\"><a href=\"#综合复习\" class=\"headerlink\" title=\"综合复习\"></a>综合复习</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24556086/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-本周知识总结</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556138/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-创建项目</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556250/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-Bootstrap 管理模板-AdminLTE</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556294/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-Bootstrap 管理模板-创建登录页</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556338/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-实现登录功能-完成后台编码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24556196/\" target=\"_blank\" rel=\"noopener\">【视频】综合复习-实现登录功能-增强用户体验</a></li> \n </ul> \n <h3 id=\"第-06-章-Spring-Web-与-Bean-装配\"><a href=\"#第-06-章-Spring-Web-与-Bean-装配\" class=\"headerlink\" title=\"第 06 章 Spring Web 与 Bean 装配\"></a>第 06 章 Spring Web 与 Bean 装配</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24698265/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/Spring-整合-Web/\">Spring 整合 Web</a></li> \n  <li><a href=\"/2018/06/11/monolithic/ApplicationContextAware/\">ApplicationContextAware</a></li> \n  <li><a href=\"/2018/06/11/monolithic/Bean-的装配方式/\">Bean 的装配方式</a>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24698287/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/容器中-Bean-的作用域/\">容器中 Bean 的作用域</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24698302/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/基于注解的装配方式/\">基于注解的装配方式</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av24698335/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/11/monolithic/浏览器端存储技术简介/\">浏览器端存储技术简介（课后作业：记住我）</a></li> \n </ul> \n <h3 id=\"第-07-章-Spring-MVC-与-Maven-模块化开发\"><a href=\"#第-07-章-Spring-MVC-与-Maven-模块化开发\" class=\"headerlink\" title=\"第 07 章 Spring MVC 与 Maven 模块化开发\"></a>第 07 章 Spring MVC 与 Maven 模块化开发</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24741954/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-MVC-简介/\">Spring MVC 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24741988/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-整合-Spring-MVC/\">Spring 整合 Spring MVC</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742021/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/第一个-Controller-控制器/\">第一个 Controller 控制器</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742046/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Spring-MVC-拦截器的使用/\">Spring MVC 拦截器的使用</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742070/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/12/monolithic/Maven-模块化开发/\">Maven 模块化开发</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24742106/\" target=\"_blank\" rel=\"noopener\">【视频】课后练习-重新完善功能代码</a></li> \n </ul> \n <h3 id=\"第-08-章-MyBatis-数据持久化\"><a href=\"#第-08-章-MyBatis-数据持久化\" class=\"headerlink\" title=\"第 08 章 MyBatis 数据持久化\"></a>第 08 章 MyBatis 数据持久化</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24818342/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/MyBatis-简介/\">MyBatis 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818369/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Druid-简介/\">Druid 简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818402/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Spring-整合-Druid/\">Spring 整合 Druid</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818423/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/Spring-整合-MyBatis/\">Spring 整合 MyBatis</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818453/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-utf8 与 utf8mb4 字符集</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24818481/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/第一个-MyBatis-对象关系映射/\">第一个 MyBatis 对象关系映射</a></li> \n </ul> \n <h3 id=\"第-09-章-MyBatis-表操作\"><a href=\"#第-09-章-MyBatis-表操作\" class=\"headerlink\" title=\"第 09 章 MyBatis 表操作\"></a>第 09 章 MyBatis 表操作</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av24883965\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/13/monolithic/MyBatis-单表-CRUD-操作/\">MyBatis 单表 CRUD 操作</a>\n   <ul> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-INSERT-新增/\">INSERT 新增</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-DELETE-删除/\">DELETE 删除</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-查询单个对象/\">查询单个对象</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-UPDATE-更新/\">UPDATE 更新</a></li> \n    <li><a href=\"/2018/06/13/monolithic/MyBatis-使用模糊查询/\">使用模糊查询</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av24884003\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现用户登录功能</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24884030\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现首页布局</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av24884062\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-用户列表展示</a></li> \n </ul> \n <h3 id=\"第-10-章-项目实战相关知识点补充\"><a href=\"#第-10-章-项目实战相关知识点补充\" class=\"headerlink\" title=\"第 10 章 项目实战相关知识点补充\"></a>第 10 章 项目实战相关知识点补充</h3>\n <ul> \n  <li><a href=\"/2018/06/16/monolithic/Spring-MVC-表单标签库/\">Spring MVC 表单标签库</a></li> \n  <li><a href=\"/2018/06/16/monolithic/Spring-MVC-ModelAttribute-注解/\">Spring MVC @ModelAttribute 注解</a></li> \n  <li><a href=\"/2018/06/18/monolithic/Spring-MVC-ResponseBody-注解/\">Spring MVC @ResponseBody 注解</a></li> \n  <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL/\">MyBatis 动态 SQL</a>\n   <ul> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-if-标签/\">if 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-where-标签/\">where 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-choose-标签/\">choose 标签</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-foreach-标签-遍历数组/\">foreach 标签-遍历数组</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-foreach-标签-遍历集合/\">foreach 标签-遍历集合</a></li> \n    <li><a href=\"/2018/06/17/monolithic/MyBatis-动态-SQL-sql-标签/\">sql 标签</a></li> \n   </ul> </li> \n  <li><a href=\"/2018/06/26/monolithic/Spring-Validation-简化服务端验证/\">Spring Validation 简化服务端验证</a></li> \n </ul> \n <h3 id=\"项目实战视频集合（上）\"><a href=\"#项目实战视频集合（上）\" class=\"headerlink\" title=\"项目实战视频集合（上）\"></a>项目实战视频集合（上）</h3>\n <ul> \n  <li><h4 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24884003\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现用户登录功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av24884030\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现首页布局</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av24884062\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-用户列表展示</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236054\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现新增用户功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236061\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 Spring MVC 表单标签简化表单开发</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25236065\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 jQuery Validation 实现表单验证</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25259516\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用动态 SQL 实现搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25259997\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-优化搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25260018\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 jQuery iCheck 插件实现全选反选功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340288\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现批量删除功能1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340326\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现批量删除功能2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340368\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 DataTables 插件实现分页功能1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25340407\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-使用 DataTables 插件实现分页功能2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25405331\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-实现编辑和查看功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25426189\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-重新实现搜索功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25426237\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-用户管理功能-最后的收尾工作</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"内容管理\"><a href=\"#内容管理\" class=\"headerlink\" title=\"内容管理\"></a>内容管理</h4>\n   <ul> \n    <li><a href=\"https://www.bilibili.com/video/av25555223\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-内容分类功能准备</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25555266\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 TreeTable 展示树形表格</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25584822\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-内容列表功能准备</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25584906\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 zTree 展示内容分类数据</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693473\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Lombok 插件简化 Bean 代码</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693494\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Spring Validation 简化服务端验证</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693524\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-Spring MVC + Dropzone 实现图片上传</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25693551\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-封装 Dropzone 插件</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740747\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-使用 wangEditor 富文本编辑器</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740776\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现 wangEditor 文件上传功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740833\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现关联关系查询</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25740876\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-提取统一的数据访问和业务接口</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827541\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-内容管理功能-实现内容分类的新增功能</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827584\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-深度封装业务逻辑层1</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827617\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-深度封装业务逻辑层2</a></li> \n    <li><a href=\"https://www.bilibili.com/video/av25827661\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-重构代码-封装控制器层</a></li> \n   </ul> </li> \n </ul> \n <h3 id=\"第-11-章-Spring-的事务管理\"><a href=\"#第-11-章-Spring-的事务管理\" class=\"headerlink\" title=\"第 11 章 Spring 的事务管理\"></a>第 11 章 Spring 的事务管理</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av25827750\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/28/monolithic/Spring-事务管理简介/\">Spring 事务管理简介</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25827857\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/29/monolithic/使用-AspectJ-的-AOP-配置管理事务/\">使用 AspectJ 的 AOP 配置管理事务</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25827802\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/06/29/monolithic/使用-Spring-注解管理事务/\">使用 Spring 注解管理事务</a></li> \n </ul> \n <h3 id=\"第-12-章-解决模块间的通信问题\"><a href=\"#第-12-章-解决模块间的通信问题\" class=\"headerlink\" title=\"第 12 章 解决模块间的通信问题\"></a>第 12 章 解决模块间的通信问题</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av25992351\" target=\"_blank\" rel=\"noopener\">【视频】项目改动说明</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25992450\" target=\"_blank\" rel=\"noopener\">【视频】后台管理与门户数据展示说明</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av25992502\" target=\"_blank\" rel=\"noopener\">【视频】为什么存在通信问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109195\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/07/03/monolithic/使用-Apache-HttpClient-解决通信问题/\">使用 Apache HttpClient 解决通信问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109207\" target=\"_blank\" rel=\"noopener\">【视频】Apache HttpClient 使用实例</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109218/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/07/03/monolithic/使用-Jackson-处理-JSON-数据/\">使用 Jackson 处理 JSON 数据</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109230/\" target=\"_blank\" rel=\"noopener\">【视频】创建 API 接口模块</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109239/\" target=\"_blank\" rel=\"noopener\">【视频】小知识-POJO、VO、DTO、Entity、Domain 的区别</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26109248/\" target=\"_blank\" rel=\"noopener\">【视频】</a> <a href=\"/2018/04/09/interview/Java-面试宝典-你怎么理解-RESTful/\">使用 RESTFul 风格设计 API</a>\n   <ul> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-说说如何设计一个良好的-API/\">如何设计一个良好的 API</a></li> \n    <li><a href=\"/2018/04/09/interview/Java-面试宝典-如何理解-RESTful-API-的幂等性/\">如何理解 RESTful API 的幂等性</a></li> \n   </ul> </li> \n  <li><a href=\"https://www.bilibili.com/video/av26109258/\" target=\"_blank\" rel=\"noopener\">【视频】使用 Spirng MVC 实现 RESTful 风格的 API</a></li> \n </ul> \n <h3 id=\"项目实战视频集合（下）\"><a href=\"#项目实战视频集合（下）\" class=\"headerlink\" title=\"项目实战视频集合（下）\"></a>项目实战视频集合（下）</h3>\n <ul> \n  <li><a href=\"https://www.bilibili.com/video/av26166835\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-创建 Web UI 门户模块</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26166862\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现 UI 模块与 API 模块的通信</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26166882\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户首页的幻灯片展示</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298091\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-实现 API</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298138\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-对接 API</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298192\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-使用拦截器禁止重复登录</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298238\" target=\"_blank\" rel=\"noopener\">【视频】小知识-验证码的作用与如何打码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298288\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-解决 Maven 无法下载依赖的问题</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298347\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-实现门户登录-增加 Kaptcha 验证码</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298426\" target=\"_blank\" rel=\"noopener\">【视频】项目实战-MyShop-使用 Apache Commons Email 发送邮件</a></li> \n  <li><a href=\"https://www.bilibili.com/video/av26298518\" target=\"_blank\" rel=\"noopener\">【视频】课程完结-阶段总结，撒花，撒花，可喜可贺，可喜可贺</a></li> \n </ul> \n <h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3>\n <ul> \n  <li><h4 id=\"常用工具类（Java）\"><a href=\"#常用工具类（Java）\" class=\"headerlink\" title=\"常用工具类（Java）\"></a>常用工具类（Java）</h4>\n   <ul> \n    <li><a href=\"/2018/06/17/appose/CookieUtils/\">CookieUtils Cookie 工具类</a></li> \n    <li><a href=\"/2018/06/17/appose/RegexpUtils/\">RegexpUtils 正则表达式工具类</a></li> \n    <li><a href=\"/2018/07/03/appose/MapperUtils-Jackson-工具类/\">MapperUtils Jackson 工具类</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用工具类（JS）\"><a href=\"#常用工具类（JS）\" class=\"headerlink\" title=\"常用工具类（JS）\"></a>常用工具类（JS）</h4>\n   <ul> \n    <li><a href=\"/2018/06/25/appose/DateTimeJS/\">DateTime 日期工具类</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用-JS-插件\"><a href=\"#常用-JS-插件\" class=\"headerlink\" title=\"常用 JS 插件\"></a>常用 JS 插件</h4>\n   <ul> \n    <li><a href=\"/2018/06/17/appose/jQuery-Validation/\">jQuery Validation 表单验证插件</a></li> \n    <li><a href=\"/2018/06/18/appose/jQuery-iCheck/\">jQuery iCheck 复选/单选美化插件</a></li> \n    <li><a href=\"/2018/06/21/appose/jQuery-Datatables/\">jQuery Datatables 表格插件</a></li> \n    <li><a href=\"/2018/06/25/appose/jQuery-TreeTable/\">jQuery TreeTable 树表格插件</a></li> \n    <li><a href=\"/2018/06/25/appose/jQuery-zTree/\">jQuery zTree 树形结构插件</a></li> \n    <li><a href=\"/2018/06/27/appose/Dropzone-图片上传插件/\">Dropzone 图片上传插件</a></li> \n    <li><a href=\"/2018/06/28/appose/wangEditor-富文本编辑器/\">wangEditor 富文本编辑器</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"常用-IDEA-插件\"><a href=\"#常用-IDEA-插件\" class=\"headerlink\" title=\"常用 IDEA 插件\"></a>常用 IDEA 插件</h4>\n   <ul> \n    <li><a href=\"/2018/06/26/appose/JRebel-热部署插件/\">JRebel 热部署插件</a></li> \n    <li><a href=\"/2018/06/26/appose/Lombok-简化臃肿代码/\">Lombok 简化臃肿代码</a><br><br></li> \n   </ul> </li> \n  <li><h4 id=\"其它知识点补充\"><a href=\"#其它知识点补充\" class=\"headerlink\" title=\"其它知识点补充\"></a>其它知识点补充</h4>\n   <ul> \n    <li><a href=\"/2018/07/05/appose/使用-Google-Kaptcha-生成验证码/\">使用 Kaptcha 生成验证码</a></li> \n    <li><a href=\"/2018/07/06/appose/解决-Maven-无法自动下载依赖的问题/\">解决 Maven 无法自动下载依赖的问题</a></li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:05','2018-12-20 22:06:05'),
(315,3,'Maven 本地仓库',1,'www.funtl.com/assets/Lusifer1511452605.png',1,'<div class=\"col-sm-12\"> \n <p>Maven 的本地资源库是用来存储所有项目的依赖关系(插件 Jar 和其他文件，这些文件被 Maven 下载)到本地文件夹。很简单，当你建立一个 Maven 项目，所有相关文件将被存储在你的 Maven 本地仓库。</p> \n <p>默认情况下，Maven 的本地资源库默认为 <code>.m2</code> 目录文件夹：</p> \n <ul> \n  <li>Unix/Mac OS X：<code>~/.m2</code></li> \n  <li>Windows：<code>C:\\Documents and Settings\\{your-username}\\.m2</code></li> \n </ul> \n <h3 id=\"配置-Maven-的本地库\"><a href=\"#配置-Maven-的本地库\" class=\"headerlink\" title=\"配置 Maven 的本地库\"></a>配置 Maven 的本地库</h3>\n <p>通常情况下，可改变默认的 <code>.m2</code> 目录下的默认本地存储库文件夹到其他更有意义的名称，例如， maven-repo 找到 <code>{M2_HOME}\\conf\\setting.xml</code>, 更新 <code>localRepository</code> 到其它名称。</p> \n <p><img src=\"/assets/Lusifer1511452605.png\" alt=\"\"></p> \n <p>执行之后，新的 Maven 本地存储库现在改为 <code>D:/apache-maven-3.5.2/repo</code></p> \n <p><img src=\"/assets/Lusifer1511452727.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(316,3,'Maven 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。</p> \n <p>在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。</p> \n <p>Maven 提供了开发人员的方式来管理：</p> \n <ul> \n  <li>Builds</li> \n  <li>Documentation</li> \n  <li>Reporting</li> \n  <li>Dependencies</li> \n  <li>SCMs</li> \n  <li>Releases</li> \n  <li>Distribution</li> \n  <li>mailing list</li> \n </ul> \n <p>概括地说，Maven 简化和标准化项目建设过程。处理编译，分配，文档，团队协作和其他任务的无缝连接。 Maven 增加可重用性并负责建立相关的任务。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(317,3,'IDEA 简介',1,'www.funtl.com/assets/4afbfbedab64034f72b616b4a5c379310a551d0c.jpg',1,'<div class=\"col-sm-12\"> \n <p><img src=\"/assets/4afbfbedab64034f72b616b4a5c379310a551d0c.jpg\" alt=\"\"></p> \n <p>IDEA 全称 IntelliJ IDEA，是 Java 语言开发的集成环境，IntelliJ 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具(<code>git</code>、<code>svn</code>、<code>github</code> 等)、JUnit、CVS 整合、代码分析、 创新的 GUI 设计等方面的功能可以说是超常的。IDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持 HTML，CSS，PHP，MySQL，Python 等。免费版只支持 Java 等少数语言。</p> \n <h3 id=\"特色功能\"><a href=\"#特色功能\" class=\"headerlink\" title=\"特色功能\"></a>特色功能</h3>\n <ul> \n  <li>智能的选取：在很多时候我们要选取某个方法，或某个循环或想一步一步从一个变量到整个类慢慢扩充着选取，IDEA就提供这种基于语法的选择，在默认设置中 <code>Ctrl + W</code>，可以实现选取范围的不断扩充，这种方式在重构的时候尤其显得方便。</li> \n  <li>丰富的导航模式：IDEA 提供了丰富的导航查看模式，例如 <code>Ctrl + E</code> 显示最近打开过的文件，<code>Ctrl + N</code> 显示你希望显示的类名查找框（该框同样有智能补充功能，当你输入字母后IDEA将显示所有候选类名）。在最基本的 Project 视图中，你还可以选择多种的视图方式。</li> \n  <li>历史记录功能：不用通过版本管理服务器，单纯的 IDEA 就可以查看任何工程中文件的历史记录，在版本恢复时你可以很容易的将其恢复。</li> \n  <li>JUnit 的完美支持</li> \n  <li>对重构的优越支持：IDEA 是所有 IDE 中最早支持重构的，其优秀的重构能力一直是其主要卖点之一。</li> \n  <li>编码辅助：Java 规范中提倡的 <code>toString()</code>、<code>hashCode()</code>、<code>equals()</code> 以及所有的 <code>get/set</code> 方法，你可以不用进行任何的输入就可以实现代码的自动生成，从而把你从无聊的基本方法编码中解放出来。</li> \n  <li>灵活的排版功能：基本所有的 IDE 都有重排版功能，但仅有 IDEA 的是人性的，因为它支持排版模式的定制，你可以根据不同的项目要求采用不同的排版方式。</li> \n  <li>XML 的完美支持：XML 全提示支持：所有流行框架的 XML 文件都支持全提示，谁用谁知道。</li> \n  <li>动态语法检测：任何不符合 Java 规范、自己预定义的规范、累赘都将在页面中加亮显示。</li> \n  <li>代码检查：对代码进行自动分析，检测不符合规范的，存在风险的代码，并加亮显示。</li> \n  <li>对 JSP 的完全支持：不需要任何的插件，完全支持 JSP。</li> \n  <li>智能编辑：代码输入过程中，自动补充方法或类。</li> \n  <li>EJB 支持：不需要任何插件完全支持 EJB(6.0 支持 EJB 3.0)</li> \n  <li>列编辑模式：用过 UtralEdit 的肯定对其的列编辑模式赞赏不已，因为它减少了很多无聊的重复工作，而 IDEA 完全支持该模式，从而更加提高了编码效率。</li> \n  <li>预置模板：预置模板可以让你把经常用到的方法编辑进模板，使用时你只用输入简单的几个字母就可以完成全部代码的编写。例如使用比较高的 <code>public static void main(String[] args){}</code> 你可以在模板中预设 <code>pm</code> 为该方法，输入时你只要输入 <code>pm</code> 再按代码辅助键，IDEA 将完成代码的自动输入。</li> \n  <li>完美的自动代码完成：智能检查类中的方法，当发现方法名只有一个时自动完成代码输入，从而减少剩下代码的编写工作。</li> \n  <li>版本控制完美支持：集成了目前市面上常见的所有版本控制工具插件，包括 <code>git</code>、<code>svn</code>、<code>github</code>，让开发人员在编程的工程中直接在 Intellij IDEA 里就能完成代码的提交、检出、解决冲突、查看版本控制服务器内容等等。</li> \n  <li>不使用代码的检查：自动检查代码中不使用的代码，并给出提示，从而使代码更高效。</li> \n  <li>智能代码：自动检查代码，发现与预置规范有出入的代码给出提示，若程序员同意修改自动完成修改。例如代码：<code>String str = \"Hello Intellij \" + \"IDEA\";</code> IDEA 将给出优化提示，若程序员同意修改 IDEA 将自动将代码修改为：<code>String str = \"Hello Intellij IDEA\";</code></li> \n  <li>正则表达式的查找和替换功能：查找和替换支持正则表达式，从而提高效率。</li> \n  <li>JavaDoc 预览支持：支持 JavaDoc 的预览功能，在 JavaDoc 代码中 <code>Ctrl + Q</code> 显示 JavaDoc 的结果，从而提高 DOC 文档的质量。</li> \n  <li>程序员意图支持：程序员编码时 IDEA 时时检测你的意图，或提供建议，或直接帮你完成代码。</li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(318,3,'Maven 中央仓库',1,'www.funtl.com/assets/Lusifer1511452924.png',1,'<div class=\"col-sm-12\"> \n <p>当你建立一个 Maven 的项目，Maven 会检查你的 <code>pom.xml</code> 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 <a href=\"http://repo1.maven.org/maven2/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/</a> 查找下载。</p> \n <p><img src=\"/assets/Lusifer1511452924.png\" alt=\"\"></p> \n <p>使用 MVNrepository 搜索：<a href=\"https://mvnrepository.com/\" target=\"_blank\" rel=\"noopener\">https://mvnrepository.com/</a></p> \n <p><img src=\"/assets/Lusifer1511453035.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(319,3,'Maven 依赖机制',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在 Maven 依赖机制的帮助下自动下载所有必需的依赖库，并保持版本升级。让我们看一个案例研究，以了解它是如何工作的。假设你想使用 Log4j 作为项目的日志。这里你要做什么？</p> \n <h3 id=\"传统方式\"><a href=\"#传统方式\" class=\"headerlink\" title=\"传统方式\"></a>传统方式</h3>\n <ul> \n  <li><p>访问 <a href=\"http://logging.apache.org/log4j/\" target=\"_blank\" rel=\"noopener\">http://logging.apache.org/log4j/</a></p> </li> \n  <li><p>下载 Log4j 的 jar 库</p> </li> \n  <li><p>复制 jar 到项目类路径</p> </li> \n  <li><p>手动将其包含到项目的依赖</p> </li> \n  <li><p>所有的管理需要一切由自己做</p> </li> \n </ul> \n <p>如果有 Log4j 版本升级，则需要重复上述步骤一次。</p> \n <h3 id=\"Maven-的方式\"><a href=\"#Maven-的方式\" class=\"headerlink\" title=\"Maven 的方式\"></a>Maven 的方式</h3>\n <ul> \n  <li>你需要知道 log4j 的 Maven 坐标，例如：</li> \n </ul> \n <pre><code>&lt;groupId&gt;log4j&lt;/groupId&gt;\n&lt;artifactId&gt;log4j&lt;/artifactId&gt;\n&lt;version&gt;1.2.17&lt;/version&gt;\n</code></pre>\n <ul> \n  <li>它会自动下载 log4j 的 1.2.17 版本库</li> \n  <li>声明 Maven 的坐标转换成 <code>pom.xml</code> 文件</li> \n </ul> \n <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n    &lt;groupId&gt;log4j&lt;/groupId&gt;\n    &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n <ul> \n  <li><p>当 Maven 编译或构建，log4j 的 jar 会自动下载，并把它放到 Maven 本地存储库</p> </li> \n  <li><p>所有由 Maven 管理</p> </li> \n </ul> \n <h3 id=\"解释说明\"><a href=\"#解释说明\" class=\"headerlink\" title=\"解释说明\"></a>解释说明</h3>\n <p>看看有什么不同？那么到底在 Maven 发生了什么？当建立一个 Maven 的项目，pom.xml 文件将被解析，如果看到 log4j 的 Maven 坐标，然后 Maven 按此顺序搜索 log4j 库：</p> \n <ul> \n  <li>在 Maven 的本地仓库搜索 log4j </li> \n  <li>在 Maven 中央存储库搜索 log4j</li> \n  <li>在 Maven 远程仓库搜索 log4j(如果在 pom.xml 中定义)</li> \n </ul> \n <p>Maven 依赖库管理是一个非常好的工具，为您节省了大量的工作</p> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(320,3,'第一个 IDEA 应用程序',1,'www.funtl.com/assets/Lusifer1528017464.png',1,'<div class=\"col-sm-12\"> \n <p>下面我们来学习如何使用 IDEA 创建一个 Java Web 应用程序</p> \n <h4 id=\"新建-Java-Web-项目\"><a href=\"#新建-Java-Web-项目\" class=\"headerlink\" title=\"新建 Java Web 项目\"></a>新建 Java Web 项目</h4>\n <p>打开 <code>IDEA</code> -&gt; <code>Create New Project</code></p> \n <p><img src=\"/assets/Lusifer1528017464.png\" alt=\"\"></p> \n <p>选择 <code>Java</code> -&gt; <code>Java EE</code> -&gt; <code>Web Application</code></p> \n <p><img src=\"/assets/Lusifer1528017638.png\" alt=\"\"></p> \n <h4 id=\"选择工作空间\"><a href=\"#选择工作空间\" class=\"headerlink\" title=\"选择工作空间\"></a>选择工作空间</h4>\n <p>项目命名后选择存放的工作空间，项目就创建完成了</p> \n <p><img src=\"/assets/Lusifer1528018627.png\" alt=\"\"></p> \n <h4 id=\"配置-JDK\"><a href=\"#配置-JDK\" class=\"headerlink\" title=\"配置 JDK\"></a>配置 JDK</h4>\n <p>选择 <code>File</code> -&gt; <code>Project Structure...</code></p> \n <p><img src=\"/assets/Lusifer1528018777.png\" alt=\"\"></p> \n <p>选择 JDK 的安装路径即可</p> \n <p><img src=\"/assets/Lusifer1528018883.png\" alt=\"\"></p> \n <h4 id=\"配置-Tomcat\"><a href=\"#配置-Tomcat\" class=\"headerlink\" title=\"配置 Tomcat\"></a>配置 Tomcat</h4>\n <p>选择 <code>Run</code> -&gt; <code>Edit Configurations...</code></p> \n <p><img src=\"/assets/Lusifer1528019007.png\" alt=\"\"></p> \n <p>选择 <code>+</code> 号 -&gt; <code>Tomcat Server</code> -&gt; <code>Local</code></p> \n <p><img src=\"/assets/Lusifer1528019058.png\" alt=\"\"></p> \n <p>选择 Tomcat 的安装路径即可</p> \n <p><img src=\"/assets/Lusifer1528019181.png\" alt=\"\"></p> \n <h4 id=\"配置-Tomcat-本地部署\"><a href=\"#配置-Tomcat-本地部署\" class=\"headerlink\" title=\"配置 Tomcat 本地部署\"></a>配置 Tomcat 本地部署</h4>\n <p>继续上一步，选择 <code>Deployment</code> -&gt; <code>+</code> 号 -&gt; <code>Artifact...</code></p> \n <p><img src=\"/assets/Lusifer1528019373.png\" alt=\"\"></p> \n <p><img src=\"/assets/Lusifer1528019572.png\" alt=\"\"></p> \n <p>选择 <code>Server</code> 配置自动更新</p> \n <p><img src=\"/assets/Lusifer1528020264.png\" alt=\"\"></p> \n <h4 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h4>\n <p>选择需要运行的项目，点击 <code>运行</code> 图标</p> \n <p><img src=\"/assets/Lusifer1528020413.png\" alt=\"\"></p> \n <p>浏览器打开：<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 显示如下</p> \n <pre><code>$END$\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(321,3,'Maven 安装配置',1,'www.funtl.com/assets/Lusifer1511451715.png',1,'<div class=\"col-sm-12\"> \n <p>想要安装 Apache Maven 在 Windows 系统上, 需要下载 Maven 的 zip 文件，并将其解压到你想安装的目录，并配置 Windows 环境变量。</p> \n <p>注意：请尽量使用 JDK 1.8 及以上版本</p> \n <h3 id=\"JDK-和-JAVA-HOME\"><a href=\"#JDK-和-JAVA-HOME\" class=\"headerlink\" title=\"JDK 和 JAVA_HOME\"></a>JDK 和 JAVA_HOME</h3>\n <p>确保已安装 JDK，并设置 <code>JAVA_HOME</code> 环境变量到 Windows 环境变量。</p> \n <p><img src=\"/assets/Lusifer1511451715.png\" alt=\"\"></p> \n <h3 id=\"下载-Apache-Maven\"><a href=\"#下载-Apache-Maven\" class=\"headerlink\" title=\"下载 Apache Maven\"></a>下载 Apache Maven</h3>\n <p>下载地址：<a href=\"http://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/download.cgi</a></p> \n <p><img src=\"/assets/Lusifer1511451890.png\" alt=\"\"></p> \n <p>下载 Maven 的 zip 文件，例如： apache-maven-3.5.2-bin.zip，将它解压到你要安装 Maven 的文件夹。假设你解压缩到文件夹 – D:\\apache-maven-3.5.2</p> \n <p><img src=\"/assets/Lusifer1511452022.png\" alt=\"\"></p> \n <p>注意：在这一步，只是文件夹和文件，安装不是必需的。</p> \n <h3 id=\"添加-MAVEN-HOME\"><a href=\"#添加-MAVEN-HOME\" class=\"headerlink\" title=\"添加 MAVEN_HOME\"></a>添加 MAVEN_HOME</h3>\n <p>添加 <code>MAVEN_HOME</code> 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。</p> \n <p><img src=\"/assets/Lusifer1511452135.png\" alt=\"\"></p> \n <h3 id=\"添加到环境变量-PATH\"><a href=\"#添加到环境变量-PATH\" class=\"headerlink\" title=\"添加到环境变量 - PATH\"></a>添加到环境变量 - PATH</h3>\n <p><img src=\"/assets/Lusifer1511452190.png\" alt=\"\"></p> \n <h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3>\n <p>使用命令：<code>mvn -version</code></p> \n <p>输出：</p> \n <pre><code>C:\\Users\\Lusifer&gt;mvn -version\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)\nMaven home: D:\\apache-maven-3.5.2\\bin\\..\nJava version: 1.8.0_152, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_152\\jre\nDefault locale: zh_CN, platform encoding: GBK\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"windows\"\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:06','2018-12-20 22:06:06'),
(322,3,'什么是三层架构',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是系统架构\"><a href=\"#什么是系统架构\" class=\"headerlink\" title=\"什么是系统架构\"></a>什么是系统架构</h3>\n <p>所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。</p> \n <h3 id=\"什么是三层架构\"><a href=\"#什么是三层架构\" class=\"headerlink\" title=\"什么是三层架构\"></a>什么是三层架构</h3>\n <p>三层架构是指：视图层 View、服务层 Service，与持久层 DAO。它们分别完成不同的功能。</p> \n <ul> \n  <li><p>View 层：用于接收用户提交请求的代码</p> </li> \n  <li><p>Service 层：系统的业务逻辑主要在这里完成</p> </li> \n  <li><p>DAO 层：直接操作数据库的代码</p> </li> \n </ul> \n <p>为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。</p> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090001.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(323,3,'Bootstrap 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。它是一个 CSS/HTML 框架。Bootstrap 提供了优雅的 HTML 和 CSS 规范。Bootstrap 一经推出后颇受欢迎，一直是 GitHub 上的热门开源项目。</p> \n <h3 id=\"为什么使用-Bootstrap？\"><a href=\"#为什么使用-Bootstrap？\" class=\"headerlink\" title=\"为什么使用 Bootstrap？\"></a>为什么使用 Bootstrap？</h3>\n <ul> \n  <li><p>移动设备优先：自 Bootstrap 3 起，框架包含了贯穿于整个库的移动设备优先的样式。</p> </li> \n  <li><p>浏览器支持：所有的主流浏览器都支持 Bootstrap。</p> </li> \n  <li><p>容易上手：只要您具备 HTML 和 CSS 的基础知识，您就可以开始学习 Bootstrap。</p> </li> \n  <li><p>响应式设计：Bootstrap 的响应式 CSS 能够自适应于台式机、平板电脑和手机。</p> </li> \n  <li><p>它为开发人员创建接口提供了一个简洁统一的解决方案。</p> </li> \n  <li><p>它包含了功能强大的内置组件，易于定制。</p> </li> \n  <li><p>它还提供了基于 Web 的定制。</p> </li> \n  <li><p>它是开源的。</p> </li> \n </ul> \n <h3 id=\"Bootstrap-包的内容\"><a href=\"#Bootstrap-包的内容\" class=\"headerlink\" title=\"Bootstrap 包的内容\"></a>Bootstrap 包的内容</h3>\n <ul> \n  <li><p>基本结构：Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。</p> </li> \n  <li><p>CSS：Bootstrap 自带以下特性，全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。</p> </li> \n  <li><p>组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框等等。</p> </li> \n  <li><p>JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。您可以直接包含所有的插件，也可以逐个包含这些插件。</p> </li> \n  <li><p>定制：您可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到您自己的版本。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(324,3,'Maven POM',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>POM 代表项目对象模型。它是 Maven 中工作的基本单位，这是一个 XML 文件。它始终保存在该项目基本目录中的 pom.xml 文件。</p> \n <p>POM 包含的项目是使用 Maven 来构建的，它用来包含各种配置信息。</p> \n <p>POM 也包含了目标和插件。在执行任务或目标时，Maven 会使用当前目录中的 POM。它读取POM得到所需要的配置信息，然后执行目标。部分的配置可以在 POM 使用如下：</p> \n <ul> \n  <li>project dependencies</li> \n  <li>plugins</li> \n  <li>goals</li> \n  <li>build profiles</li> \n  <li>project version</li> \n  <li>developers</li> \n  <li>mailing list</li> \n </ul> \n <p>创建一个POM之前，应该要先决定项目组(groupId)，它的名字(artifactId)和版本，因为这些属性在项目仓库是唯一标识的。</p> \n <h3 id=\"POM-的例子\"><a href=\"#POM-的例子\" class=\"headerlink\" title=\"POM 的例子\"></a>POM 的例子</h3>\n <pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n   http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n   &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n   &lt;groupId&gt;com.lusifer&lt;/groupId&gt;\n   &lt;artifactId&gt;project&lt;/artifactId&gt;\n   &lt;version&gt;1.0&lt;/version&gt;\n&lt;project&gt;\n</code></pre>\n <p>要注意的是，每个项目只有一个 POM 文件</p> \n <ul> \n  <li><p>所有的 POM 文件要项目元素必须有三个必填字段: groupId，artifactId，version</p> </li> \n  <li><p>在库中的项目符号是：<code>groupId:artifactId:version</code></p> </li> \n  <li><p><code>pom.xml</code> 的根元素是 project，它有三个主要的子节点。</p> </li> \n </ul> \n <table> \n  <thead> \n   <tr> \n    <th>节点</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>groupId</td> \n    <td>这是项目组的编号，这在组织或项目中通常是独一无二的。 例如，一家银行集团 <code>com.company.bank</code> 拥有所有银行相关项目。</td> \n   </tr> \n   <tr> \n    <td>artifactId</td> \n    <td>这是项目的 ID。这通常是项目的名称。 例如，<code>consumer-banking</code>。 除了 groupId 之外，artifactId 还定义了 artifact 在存储库中的位置。</td> \n   </tr> \n   <tr> \n    <td>version</td> \n    <td>这是项目的版本。与 groupId 一起使用，artifact 在存储库中用于将版本彼此分离。 例如：<code>com.company.bank:consumer-banking:1.0</code>，<code>com.company.bank:consumer-banking:1.1</code></td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(325,3,'什么是 MVC 模式',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MVC，即 Model 模型、View 视图，及 Controller 控制器。</p> \n <ul> \n  <li><p>View：视图，为用户提供使用界面，与用户直接进行交互。</p> </li> \n  <li><p>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、User 等。而业务处理 Bean 则是指 Service 或 Dao 对象， 专门用于处理用户提交请求的。</p> </li> \n  <li><p>Controller：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。</p> </li> \n </ul> \n <h3 id=\"MVC-架构程序的工作流程\"><a href=\"#MVC-架构程序的工作流程\" class=\"headerlink\" title=\"MVC 架构程序的工作流程\"></a>MVC 架构程序的工作流程</h3>\n <ul> \n  <li><p>用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等</p> </li> \n  <li><p>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理</p> </li> \n  <li><p>Model 处理后，将处理结果再交给 Controller</p> </li> \n  <li><p>Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。</p> </li> \n </ul> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090002.png\">\n  <br>\n </div> \n <h3 id=\"三层架构-MVC-示意图\"><a href=\"#三层架构-MVC-示意图\" class=\"headerlink\" title=\"三层架构 + MVC 示意图\"></a>三层架构 + MVC 示意图</h3>\n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018060421090003.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(326,3,'Maven 快照',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>大型应用软件一般由多个模块组成，一般它是多个团队开发同一个应用程序的不同模块，这是比较常见的场景。例如，一个团队正在对应用程序的应用程序，用户界面项目(<code>app-ui.jar:1.0</code>) 的前端进行开发，他们使用的是数据服务工程 (<code>data-service.jar:1.0</code>)。</p> \n <p>现在，它可能会有这样的情况发生，工作在数据服务团队开发人员快速地开发 bug 修复或增强功能，他们几乎每隔一天就要释放出库到远程仓库。</p> \n <p>现在，如果数据服务团队上传新版本后，会出现下面的问题：</p> \n <ul> \n  <li>数据服务团队应该发布更新时每次都告诉应用程序 UI 团队，他们已经发布更新了代码。</li> \n  <li>UI 团队需要经常更新自己 <code>pom.xml</code> 以获得更新应用程序的版本。</li> \n </ul> \n <p>为了处理这类情况，引入快照的概念，并发挥作用。</p> \n <h3 id=\"什么是快照？\"><a href=\"#什么是快照？\" class=\"headerlink\" title=\"什么是快照？\"></a>什么是快照？</h3>\n <p>快照（SNAPSHOT）是一个特殊版本，指出目前开发拷贝。不同于常规版本，Maven 每生成一个远程存储库都会检查新的快照版本。</p> \n <p>现在，数据服务团队将在每次发布代码后更新快照存储库为：<code>data-service:1.0-SNAPSHOT</code> 替换旧的 SNAPSHOT jar。</p> \n <h3 id=\"快照与版本\"><a href=\"#快照与版本\" class=\"headerlink\" title=\"快照与版本\"></a>快照与版本</h3>\n <p>在使用版本时，如果 Maven 下载所提到的版本为 <code>data-service:1.0</code>，那么它永远不会尝试在库中下载已经更新的版本 1.0。要下载更新的代码，data-service 的版本必须要升级到 1.1。</p> \n <p>在使用快照（SNAPSHOT）时，Maven 会在每次应用程序 UI 团队建立自己的项目时自动获取最新的快照（<code>data-service:1.0-SNAPSHOT</code>）。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(327,3,'Bootstrap 环境安装',1,'www.funtl.com/assets/Lusifer1526581943.png',1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 安装是非常容易的。本章将讲解如何下载并安装 Bootstrap，讨论 Bootstrap 文件结构，并通过一个实例演示它的用法。</p> \n <h3 id=\"下载-Bootstrap\"><a href=\"#下载-Bootstrap\" class=\"headerlink\" title=\"下载 Bootstrap\"></a>下载 Bootstrap</h3>\n <p>您可以从 <a href=\"http://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">http://getbootstrap.com/</a> 上下载 Bootstrap 的最新版本。</p> \n <h3 id=\"文件结构\"><a href=\"#文件结构\" class=\"headerlink\" title=\"文件结构\"></a>文件结构</h3>\n <h4 id=\"预编译的-Bootstrap\"><a href=\"#预编译的-Bootstrap\" class=\"headerlink\" title=\"预编译的 Bootstrap\"></a>预编译的 Bootstrap</h4>\n <p>当您下载了 Bootstrap 的已编译的版本，解压缩 ZIP 文件，您将看到下面的文件/目录结构：</p> \n <p><img src=\"/assets/Lusifer1526581943.png\" alt=\"\"></p> \n <p>如上图所示，可以看到已编译的 CSS 和 JS（bootstrap.<em>），以及已编译压缩的 CSS 和 JS（bootstrap.min.</em>）。同时也包含了 Glyphicons 的字体，这是一个可选的 Bootstrap 主题。</p> \n <h3 id=\"HTML-模板\"><a href=\"#HTML-模板\" class=\"headerlink\" title=\"HTML 模板\"></a>HTML 模板</h3>\n <p>一个使用了 Bootstrap 的基本的 HTML 模板如下所示：</p> \n <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n   &lt;head&gt;\n      &lt;title&gt;Bootstrap 模板&lt;/title&gt;\n      &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n      &lt;!-- 引入 Bootstrap --&gt;\n      &lt;link href=\"https://maxcdn.bootstrapcdn.com/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n\n      &lt;!-- HTML5 Shiv 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 --&gt;\n      &lt;!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 --&gt;\n      &lt;!--[if lt IE 9]&gt;\n         &lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;\n         &lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt;\n      &lt;![endif]--&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n\n      &lt;!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) --&gt;\n      &lt;script src=\"https://code.jquery.com/jquery.js\"&gt;&lt;/script&gt;\n      &lt;!-- 包括所有已编译的插件 --&gt;\n      &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;\n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n <p>在这里，您可以看到包含了 jquery.js、bootstrap.min.js 和 bootstrap.min.css 文件，用于让一个常规的 HTML 文件变为使用了 Bootstrap 的模板。</p> \n <h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3>\n <p>现在让我们尝试使用 Bootstrap 输出 “Hello, world!”：</p> \n <pre><code>&lt;h1&gt;Hello, world!&lt;/h1&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(328,3,'媒体查询的用法',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"media-媒体查询的用法\"><a href=\"#media-媒体查询的用法\" class=\"headerlink\" title=\"@media 媒体查询的用法\"></a><code>@media</code> 媒体查询的用法</h3>\n <p>媒体查询能在不同的条件下使用不同的样式，使页面在不同在终端设备下达到不同的渲染效果。</p> \n <h3 id=\"浏览器支持\"><a href=\"#浏览器支持\" class=\"headerlink\" title=\"浏览器支持\"></a>浏览器支持</h3>\n <p>表格中的数字表示支持 <code>@media</code> 规则的第一个浏览器的版本号</p> \n <table> \n  <thead> \n   <tr> \n    <th>Chrome</th> \n    <th>IE</th> \n    <th>Firefox</th> \n    <th>Safari</th> \n    <th>Opera</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>21</td> \n    <td>9</td> \n    <td>3.5</td> \n    <td>4.0</td> \n    <td>9</td> \n   </tr> \n  </tbody> \n </table> \n <h3 id=\"媒体类型\"><a href=\"#媒体类型\" class=\"headerlink\" title=\"媒体类型\"></a>媒体类型</h3>\n <p>媒体类型在 CSS2 中是一个常见属性，可以通过媒体类型对不同设备指定不同样式。</p> \n <ul> \n  <li><p>ALL：所有设备</p> </li> \n  <li><p>Braille：盲人用点子法触觉回馈设备</p> </li> \n  <li><p>Embossed：盲文打印机</p> </li> \n  <li><p>Handheld：便携设备</p> </li> \n  <li><p>Print：打印用纸或打印预览视图</p> </li> \n  <li><p>Projection：各种投影设备</p> </li> \n  <li><p>Screen：电脑显示器</p> </li> \n  <li><p>Speech：语音或音频合成器</p> </li> \n  <li><p>Tv：电视机类型设备</p> </li> \n  <li><p>Tty：使用固定密度字母栅格的媒介，比如电传打字机和终端 </p> </li> \n </ul> \n <p><strong>Screen</strong>、<strong>All</strong>、<strong>Print</strong> 为最常见的三种媒体类型。</p> \n <h3 id=\"媒体特性\"><a href=\"#媒体特性\" class=\"headerlink\" title=\"媒体特性\"></a>媒体特性</h3>\n <p>媒体查询中的大部分接受 <code>min/max</code> 前缀，用来表达其逻辑关系，表示应用大于等于或小于等于某个值的情况。没有特殊说明都支持 <code>min/max</code>。</p> \n <ul> \n  <li><p>width：Length 渲染界面的宽度 </p> </li> \n  <li><p>height：Length 渲染界面的高度</p> </li> \n  <li><p>color：整数，表示色彩的字节数 </p> </li> \n  <li><p>color-index：整数， 色彩表中的色彩数 </p> </li> \n  <li><p>device-aspct-ratio：整数/整数，宽高比例 </p> </li> \n  <li><p>device-height：Length 设备屏幕的输出高度 </p> </li> \n  <li><p>device-width：Length 设备屏幕的输出宽度 </p> </li> \n  <li><p>grid（不支持 <code>min/max</code> 前缀）：整数，是否基于栅格的设备 </p> </li> \n  <li><p>monochrome：整数，单色帧缓冲器中每像素字节数 </p> </li> \n  <li><p>resolution：分辨率（dpi/dpcm）分辨率 </p> </li> \n  <li><p>scan（不支持 <code>min/max</code> 前缀）：Progressive interlaced，Tv 媒体类型的扫描方式 </p> </li> \n  <li><p>orientation（不支持 <code>min/max</code> 前缀）：Portrait//landscape 横屏或竖屏</p> </li> \n </ul> \n <h3 id=\"使用媒体查询\"><a href=\"#使用媒体查询\" class=\"headerlink\" title=\"使用媒体查询\"></a>使用媒体查询</h3>\n <p>语法：<code>@media 媒体类型 and (媒体特性) {你的样式}</code></p> \n <h4 id=\"最大宽度\"><a href=\"#最大宽度\" class=\"headerlink\" title=\"最大宽度\"></a>最大宽度</h4>\n <p><code>max-width</code> 是媒体特性中最常用的一个特性，其意思是指媒体类型小于或等于指定的宽度时，样式生效。如：</p> \n <pre><code>@media screen and (max-width:480px) {\n .ads {\n   display:none;\n  }\n}\n</code></pre>\n <p>上面表示的是：当屏幕小于或等于 480px 时，页面中包含类样式 <code>.ads</code> 的元素都将被隐藏。</p> \n <h4 id=\"最小宽度\"><a href=\"#最小宽度\" class=\"headerlink\" title=\"最小宽度\"></a>最小宽度</h4>\n <p><code>min-width</code> 与 <code>max-width</code> 相反，指的是媒体类型大于或等于指定宽度时，样式生效。</p> \n <pre><code>@media screen and (min-width: 900px) {\n    .wrapper {width: 980px;}\n}\n</code></pre>\n <p>上面表示的是：当屏幕大于或等于 900px 时，页面中包含类样式 <code>.wrapper</code> 元素的宽度为 980px。</p> \n <h4 id=\"多个媒体特性的使用\"><a href=\"#多个媒体特性的使用\" class=\"headerlink\" title=\"多个媒体特性的使用\"></a>多个媒体特性的使用</h4>\n <p>媒体查询可以使用关键词 <code>and</code> 将多个媒体特性结合在一起。也就是说，一个媒体查询中可以包含 0 到多个表达式，表达式又可以包含 0 到多个关键字，以及一种媒体类型。</p> \n <p>当屏幕在 600px~900px 之间时，<code>body</code> 的背景色渲染为 <code>#F5F5F5</code> ，如下所示：</p> \n <pre><code>@media screen and (min-width:600px) and (max-width:900px) {\n  body {background-color:#F5F5F5;}\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(329,3,'Bootstrap 表格',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 提供了一个清晰的创建表格的布局。下表列出了 Bootstrap 支持的一些表格元素：</p> \n <table> \n  <thead> \n   <tr> \n    <th>标签</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>&lt;table&gt;</code></td> \n    <td>为表格添加基础样式</td> \n   </tr> \n   <tr> \n    <td><code>&lt;thead&gt;</code></td> \n    <td>表格标题行的容器元素（<code>&lt;tr&gt;</code>），用来标识表格列</td> \n   </tr> \n   <tr> \n    <td><code>&lt;tbody&gt;</code></td> \n    <td>表格主体中的表格行的容器元素（<code>&lt;tr&gt;</code>）</td> \n   </tr> \n   <tr> \n    <td><code>&lt;tr&gt;</code></td> \n    <td>一组出现在单行上的表格单元格的容器元素（<code>&lt;td&gt;</code> 或 <code>&lt;th&gt;</code>）</td> \n   </tr> \n   <tr> \n    <td><code>&lt;td&gt;</code></td> \n    <td>默认的表格单元格</td> \n   </tr> \n   <tr> \n    <td><code>&lt;th&gt;</code></td> \n    <td>特殊的表格单元格，用来标识列或行（取决于范围和位置）。必须在 <code>&lt;thead&gt;</code> 内使用</td> \n   </tr> \n   <tr> \n    <td><code>&lt;caption&gt;</code></td> \n    <td>关于表格存储内容的描述或总结</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"表格类\"><a href=\"#表格类\" class=\"headerlink\" title=\"表格类\"></a>表格类</h4>\n <p>下表样式可用于表格中：</p> \n <table> \n  <thead> \n   <tr> \n    <th>类</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>.table</code></td> \n    <td>为任意 <code>&lt;table&gt;</code> 添加基本样式 (只有横向分隔线)</td> \n   </tr> \n   <tr> \n    <td><code>.table-striped</code></td> \n    <td>在 <code>&lt;tbody&gt;</code> 内添加斑马线形式的条纹 ( IE8 不支持)</td> \n   </tr> \n   <tr> \n    <td><code>.table-bordered</code></td> \n    <td>为所有表格的单元格添加边框</td> \n   </tr> \n   <tr> \n    <td><code>.table-hover</code></td> \n    <td>在 <code>&lt;tbody&gt;</code> 内的任一行启用鼠标悬停状态</td> \n   </tr> \n   <tr> \n    <td><code>.table-condensed</code></td> \n    <td>让表格更加紧凑</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"lt-tr-gt-lt-th-gt-和-lt-td-gt-类\"><a href=\"#lt-tr-gt-lt-th-gt-和-lt-td-gt-类\" class=\"headerlink\" title=\"<tr>, <th> 和 <td> 类\"></a><code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code> 和 <code>&lt;td&gt;</code> 类</h4>\n <p>下表的类可用于表格的行或者单元格：</p> \n <table> \n  <thead> \n   <tr> \n    <th>类</th> \n    <th>描述</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td><code>.active</code></td> \n    <td>将悬停的颜色应用在行或者单元格上</td> \n   </tr> \n   <tr> \n    <td><code>.success</code></td> \n    <td>表示成功的操作</td> \n   </tr> \n   <tr> \n    <td><code>.info</code></td> \n    <td>表示信息变化的操作</td> \n   </tr> \n   <tr> \n    <td><code>.warning</code></td> \n    <td>表示一个警告的操作</td> \n   </tr> \n   <tr> \n    <td><code>.danger</code></td> \n    <td>表示一个危险的操作</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"基本的表格\"><a href=\"#基本的表格\" class=\"headerlink\" title=\"基本的表格\"></a>基本的表格</h4>\n <p>如果您想要一个只带有内边距（padding）和水平分割的基本表，请添加 class <code>.table</code>，如下面实例所示：</p> \n <pre><code>&lt;table class=\"table\"&gt;\n  &lt;caption&gt;基本的表格布局&lt;/caption&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;名称&lt;/th&gt;\n      &lt;th&gt;城市&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Tanmay&lt;/td&gt;\n      &lt;td&gt;Bangalore&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Sachin&lt;/td&gt;\n      &lt;td&gt;Mumbai&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:07','2018-12-20 22:06:07'),
(330,3,'Spring 整合 Web',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"容器初始化\"><a href=\"#容器初始化\" class=\"headerlink\" title=\"容器初始化\"></a>容器初始化</h3>\n <p>启动容器时需要自动装载 <code>ApplicationContext</code>，Spring 提供的 <code>ContextLoaderListener</code> 就是为了自动装配 <code>ApplicationContext</code> 的配置信息</p> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>需要在 <code>pom.xml</code> 增加 <code>org.springframework:spring-web</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n    &lt;version&gt;3.1.0&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h4>\n <p><code>web.xml</code> 配置如下</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n         version=\"3.1\"&gt;\n\n    &lt;context-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath:spring-context*.xml&lt;/param-value&gt;\n    &lt;/context-param&gt;\n    &lt;listener&gt;\n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\n    &lt;/listener&gt;\n&lt;/web-app&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(331,3,'浏览器端存储技术简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3>\n <p>Cookie 是指存储在用户本地终端上的数据，同时它是与具体的 Web 页面或者站点相关的。Cookie 数据会自动在 Web 浏览器和 Web 服务器之间传输，也就是说 HTTP 请求发送时，会把保存在该请求域名下的所有 Cookie 值发送给 Web 服务器，因此服务器端脚本是可以读、写存储在客户端的 Cookie 的操作。</p> \n <h3 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h3>\n <p>在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，解决了 Cookie 存储空间不足的问题(Cookie 中每条 Cookie 的存储空间为 4k)，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同。</p> \n <h3 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h3>\n <p>SessionStorage 与 LocalStorage 的唯一一点区别就是 LocalStorage 属于永久性存储，而 SessionStorage 属于当会话结束的时候，SessionStorage 中的键值对就会被清空。</p> \n <h3 id=\"UserData、GlobalStorage、Google-Gear\"><a href=\"#UserData、GlobalStorage、Google-Gear\" class=\"headerlink\" title=\"UserData、GlobalStorage、Google Gear\"></a>UserData、GlobalStorage、Google Gear</h3>\n <p>这三种的使用都有一定的局限性，例如 </p> \n <ul> \n  <li><p>userData 是 IE 浏览器专属，它的容量可以达到 640K，这种方案可靠，不需要安装额外插件，只不过它仅在IE下有效</p> </li> \n  <li><p>globalStorage 适用于 Firefox 2+ 的浏览器，类似于 IE 的 userData</p> </li> \n  <li><p>google gear 是谷歌开发出的一种本地存储技术，需要安装 Gear 组件</p> </li> \n </ul> \n <h3 id=\"Flash-ShareObject（Flash-Cookie）\"><a href=\"#Flash-ShareObject（Flash-Cookie）\" class=\"headerlink\" title=\"Flash ShareObject（Flash Cookie）\"></a>Flash ShareObject（Flash Cookie）</h3>\n <p>这种方式能能解决上面提到的 Cookie 存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个 Flash，当浏览器没有安装 Flash 控件时就不能用了。所幸的是，没有安装 Flash 的用户极少。</p> \n <h3 id=\"附：CookieUtils\"><a href=\"#附：CookieUtils\" class=\"headerlink\" title=\"附：CookieUtils\"></a>附：CookieUtils</h3>\n <pre><code>package com.funtl.leeshop.commons.utils;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\n\n/**\n * Cookie 工具类\n * &lt;p&gt;Title: CookieUtils&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2017/12/10 22:00\n */\npublic final class CookieUtils {\n\n    /**\n     * 得到Cookie的值, 不编码\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName) {\n        return getCookieValue(request, cookieName, false);\n    }\n\n    /**\n     * 得到Cookie的值,\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {\n        Cookie[] cookieList = request.getCookies();\n        if (cookieList == null || cookieName == null) {\n            return null;\n        }\n        String retValue = null;\n        try {\n            for (int i = 0; i &lt; cookieList.length; i++) {\n                if (cookieList[i].getName().equals(cookieName)) {\n                    if (isDecoder) {\n                        retValue = URLDecoder.decode(cookieList[i].getValue(), \"UTF-8\");\n                    } else {\n                        retValue = cookieList[i].getValue();\n                    }\n                    break;\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return retValue;\n    }\n\n    /**\n     * 得到Cookie的值,\n     *\n     * @param request\n     * @param cookieName\n     * @return\n     */\n    public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) {\n        Cookie[] cookieList = request.getCookies();\n        if (cookieList == null || cookieName == null) {\n            return null;\n        }\n        String retValue = null;\n        try {\n            for (int i = 0; i &lt; cookieList.length; i++) {\n                if (cookieList[i].getName().equals(cookieName)) {\n                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);\n                    break;\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return retValue;\n    }\n\n    /**\n     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue) {\n        setCookie(request, response, cookieName, cookieValue, -1);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效,但不编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage) {\n        setCookie(request, response, cookieName, cookieValue, cookieMaxage, false);\n    }\n\n    /**\n     * 设置Cookie的值 不设置生效时间,但编码\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, boolean isEncode) {\n        setCookie(request, response, cookieName, cookieValue, -1, isEncode);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效, 编码参数\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage, boolean isEncode) {\n        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);\n    }\n\n    /**\n     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)\n     */\n    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,\n                                 String cookieValue, int cookieMaxage, String encodeString) {\n        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);\n    }\n\n    /**\n     * 删除Cookie带cookie域名\n     */\n    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response,\n                                    String cookieName) {\n        doSetCookie(request, response, cookieName, \"\", -1, false);\n    }\n\n    /**\n     * 设置Cookie的值，并使其在指定时间内生效\n     *\n     * @param cookieMaxage cookie生效的最大秒数\n     */\n    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,\n                                          String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {\n        try {\n            if (cookieValue == null) {\n                cookieValue = \"\";\n            } else if (isEncode) {\n                cookieValue = URLEncoder.encode(cookieValue, \"utf-8\");\n            }\n            Cookie cookie = new Cookie(cookieName, cookieValue);\n            if (cookieMaxage &gt; 0)\n                cookie.setMaxAge(cookieMaxage);\n            if (null != request) {// 设置域名的cookie\n                String domainName = getDomainName(request);\n//                System.out.println(domainName);\n                if (!\"localhost\".equals(domainName)) {\n                    cookie.setDomain(domainName);\n                }\n            }\n            cookie.setPath(\"/\");\n            response.addCookie(cookie);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 设置Cookie的值，并使其在指定时间内生效\n     *\n     * @param cookieMaxage cookie生效的最大秒数\n     */\n    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,\n                                          String cookieName, String cookieValue, int cookieMaxage, String encodeString) {\n        try {\n            if (cookieValue == null) {\n                cookieValue = \"\";\n            } else {\n                cookieValue = URLEncoder.encode(cookieValue, encodeString);\n            }\n            Cookie cookie = new Cookie(cookieName, cookieValue);\n            if (cookieMaxage &gt; 0)\n                cookie.setMaxAge(cookieMaxage);\n            if (null != request) {// 设置域名的cookie\n                String domainName = getDomainName(request);\n//                System.out.println(domainName);\n                if (!\"localhost\".equals(domainName)) {\n                    cookie.setDomain(domainName);\n                }\n            }\n            cookie.setPath(\"/\");\n            response.addCookie(cookie);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 得到cookie的域名\n     */\n    private static final String getDomainName(HttpServletRequest request) {\n        String domainName = null;\n\n        String serverName = request.getRequestURL().toString();\n        if (serverName == null || serverName.equals(\"\")) {\n            domainName = \"\";\n        } else {\n            serverName = serverName.toLowerCase();\n            serverName = serverName.substring(7);\n            final int end = serverName.indexOf(\"/\");\n            serverName = serverName.substring(0, end);\n            final String[] domains = serverName.split(\"\\\\.\");\n            int len = domains.length;\n            if (len &gt; 3) {\n                // www.xxx.com.cn\n                domainName = \".\" + domains[len - 3] + \".\" + domains[len - 2] + \".\" + domains[len - 1];\n            } else if (len &lt;= 3 &amp;&amp; len &gt; 1) {\n                // xxx.com or xxx.cn\n                domainName = \".\" + domains[len - 2] + \".\" + domains[len - 1];\n            } else {\n                domainName = serverName;\n            }\n        }\n\n        if (domainName != null &amp;&amp; domainName.indexOf(\":\") &gt; 0) {\n            String[] ary = domainName.split(\"\\\\:\");\n            domainName = ary[0];\n        }\n        return domainName;\n    }\n\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(332,3,'Bootstrap 网格系统',1,'www.funtl.com/assets/Lusifer1528226157.png',1,'<div class=\"col-sm-12\"> \n <p>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。</p> \n <h3 id=\"什么是网格（Grid）？\"><a href=\"#什么是网格（Grid）？\" class=\"headerlink\" title=\"什么是网格（Grid）？\"></a>什么是网格（Grid）？</h3>\n <blockquote> \n  <p>在平面设计中，网格是一种由一系列用于组织内容的相交的直线（垂直的、水平的）组成的结构（通常是二维的）。它广泛应用于打印设计中的设计布局和内容结构。在网页设计中，它是一种用于快速创建一致的布局和有效地使用 HTML 和 CSS 的方法。</p> \n </blockquote> \n <p>简单地说，网页设计中的网格用于组织内容，让网站易于浏览，并降低用户端的负载。</p> \n <h3 id=\"什么是-Bootstrap-网格系统（Grid-System）？\"><a href=\"#什么是-Bootstrap-网格系统（Grid-System）？\" class=\"headerlink\" title=\"什么是 Bootstrap 网格系统（Grid System）？\"></a>什么是 Bootstrap 网格系统（Grid System）？</h3>\n <p>Bootstrap 官方文档中有关网格系统的描述：</p> \n <blockquote> \n  <p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。</p> \n </blockquote> \n <p>让我们来理解一下上面的语句。Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p> \n <h4 id=\"移动设备优先策略\"><a href=\"#移动设备优先策略\" class=\"headerlink\" title=\"移动设备优先策略\"></a>移动设备优先策略</h4>\n <ul> \n  <li><p>内容</p> \n   <ul> \n    <li><p>决定什么是最重要的</p> </li> \n    <li><p>布局</p> </li> \n   </ul> </li> \n  <li><p>优先设计更小的宽度</p> \n   <ul> \n    <li><p>基础的 CSS 是移动设备优先，<strong>媒体查询</strong> 是针对于平板电脑、台式电脑</p> </li> \n    <li><p>渐进增强</p> </li> \n   </ul> </li> \n  <li><p>随着屏幕大小的增加而添加元素</p> </li> \n </ul> \n <p>响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多 12 列。</p> \n <p><img src=\"/assets/Lusifer1528226157.png\" alt=\"\"></p> \n <h3 id=\"Bootstrap-网格系统（Grid-System）的工作原理\"><a href=\"#Bootstrap-网格系统（Grid-System）的工作原理\" class=\"headerlink\" title=\"Bootstrap 网格系统（Grid System）的工作原理\"></a>Bootstrap 网格系统（Grid System）的工作原理</h3>\n <p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p> \n <ul> \n  <li><p>行必须放置在 <code>.container</code> class 内，以便获得适当的对齐（alignment）和内边距（padding）</p> </li> \n  <li><p>使用行来创建列的水平组</p> </li> \n  <li><p>内容应该放置在列内，且唯有列可以是行的直接子元素</p> </li> \n  <li><p>预定义的网格类，比如 <code>.row</code> 和 <code>.col-xs-4</code>，可用于快速创建网格布局。LESS 混合类可用于更多语义布局</p> </li> \n  <li><p>列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 <code>.rows</code> 上的外边距（margin）取负，表示第一列和最后一列的行偏移</p> </li> \n  <li><p>网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 <code>.col-xs-4</code></p> </li> \n </ul> \n <h3 id=\"网格选项\"><a href=\"#网格选项\" class=\"headerlink\" title=\"网格选项\"></a>网格选项</h3>\n <p>下表总结了 Bootstrap 网格系统如何跨多个设备工作：</p> \n <table> \n  <thead> \n   <tr> \n    <th>说明</th> \n    <th>超小设备手机（&lt; 768px）</th> \n    <th>小型设备平板电脑（≥ 768px）</th> \n    <th>中型设备台式电脑（≥ 992px）</th> \n    <th>大型设备台式电脑（≥ 1200px）</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>网格行为</td> \n    <td>一直是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n    <td>以折叠开始，断点以上是水平的</td> \n   </tr> \n   <tr> \n    <td>最大容器宽度</td> \n    <td>None (auto)</td> \n    <td>750px</td> \n    <td>970px</td> \n    <td>1170px</td> \n   </tr> \n   <tr> \n    <td>Class 前缀</td> \n    <td><code>.col-xs-</code></td> \n    <td><code>.col-sm-</code></td> \n    <td><code>.col-md-</code></td> \n    <td><code>.col-lg-</code></td> \n   </tr> \n   <tr> \n    <td>列数量和</td> \n    <td>12</td> \n    <td>12</td> \n    <td>12</td> \n    <td>12</td> \n   </tr> \n   <tr> \n    <td>最大列宽</td> \n    <td>Auto</td> \n    <td>60px</td> \n    <td>78px</td> \n    <td>95px</td> \n   </tr> \n   <tr> \n    <td>间隙宽度</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n    <td>30px（一个列的每边分别 15px）</td> \n   </tr> \n   <tr> \n    <td>可嵌套</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n   <tr> \n    <td>偏移量</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n   <tr> \n    <td>列排序</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n    <td>Yes</td> \n   </tr> \n  </tbody> \n </table> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(333,3,'Bootstrap 字体图标',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"什么是字体图标\"><a href=\"#什么是字体图标\" class=\"headerlink\" title=\"什么是字体图标\"></a>什么是字体图标</h3>\n <p>所谓字体图标，就是使用字体（Font）格式的字形做成了图标。</p> \n <h3 id=\"Bootstrap-自带的字体图标\"><a href=\"#Bootstrap-自带的字体图标\" class=\"headerlink\" title=\"Bootstrap 自带的字体图标\"></a>Bootstrap 自带的字体图标</h3>\n <p>Bootstrap 捆绑了 200 多种字体格式的字形，在 fonts 文件夹内可以找到字体图标，它包含了下列这些文件：</p> \n <ul> \n  <li><p>glyphicons-halflings-regular.eot</p> </li> \n  <li><p>glyphicons-halflings-regular.svg</p> </li> \n  <li><p>glyphicons-halflings-regular.ttf</p> </li> \n  <li><p>glyphicons-halflings-regular.woff</p> </li> \n </ul> \n <p>相关的 CSS 规则写在 dist 文件夹内的 css 文件夹内的 <code>bootstrap.css</code> 和 <code>bootstrap-min.css</code> 文件上。</p> \n <h3 id=\"使用字体图标\"><a href=\"#使用字体图标\" class=\"headerlink\" title=\"使用字体图标\"></a>使用字体图标</h3>\n <p>如需使用图标，只需要简单地使用下面的代码即可：</p> \n <pre><code>&lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt;\n</code></pre>\n <h3 id=\"其它字体图标库\"><a href=\"#其它字体图标库\" class=\"headerlink\" title=\"其它字体图标库\"></a>其它字体图标库</h3>\n <ul> \n  <li><p>FontAwesome：<a href=\"http://fontawesome.dashgame.com/\" target=\"_blank\" rel=\"noopener\">http://fontawesome.dashgame.com/</a></p> </li> \n  <li><p>LineAwesome：<a href=\"https://icons8.com/line-awesome\" target=\"_blank\" rel=\"noopener\">https://icons8.com/line-awesome</a></p> </li> \n  <li><p>SocialIcons：<a href=\"http://www.socicon.com/chart.php\" target=\"_blank\" rel=\"noopener\">http://www.socicon.com/chart.php</a></p> </li> \n  <li><p><strong>阿里巴巴矢量图标库</strong>：<a href=\"http://www.iconfont.cn/\" target=\"_blank\" rel=\"noopener\">http://www.iconfont.cn/</a></p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(334,3,'Spring MVC 简介',1,'www.funtl.com/assets/20151003165041682.jpg',1,'<div class=\"col-sm-12\"> \n <p>Spring MVC 也叫 Spring Web MVC ，属于展示层框架。SpringMVC 是 Spring 框架的一部分。</p> \n <p>Spring Web MVC 框架提供了 MVC (模型 - 视图 - 控制器) 架构和用于开发灵活和松散耦合的 Web 应用程序的组件。 MVC 模式导致应用程序的不同方面(输入逻辑，业务逻辑和 UI 逻辑)分离，同时提供这些元素之间的松散耦合。</p> \n <ul> \n  <li><p>模型 (Model)：封装了应用程序数据，通常它们将由 POJO 类组成。</p> </li> \n  <li><p>视图 (View)：负责渲染模型数据，一般来说它生成客户端浏览器可以解释 HTML 输出。</p> </li> \n  <li><p>控制器 (Controller)：负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</p> </li> \n </ul> \n <h4 id=\"DispatcherServlet-组件类\"><a href=\"#DispatcherServlet-组件类\" class=\"headerlink\" title=\"DispatcherServlet 组件类\"></a>DispatcherServlet 组件类</h4>\n <p>Spring Web MVC 框架是围绕 DispatcherServlet 设计的，它处理所有的 HTTP 请求和响应。 Spring Web MVC DispatcherServlet 的请求处理工作流如下图所示：</p> \n <p><img src=\"/assets/20151003165041682.jpg\" alt=\"\"></p> \n <p>以下是对应于到 DispatcherServlet 的传入 HTTP 请求的事件顺序：</p> \n <ul> \n  <li><p>在接收到 HTTP 请求后，DispatcherServlet 会查询 HandlerMapping 以调用相应的 Controller。</p> </li> \n  <li><p>Controller 接受请求并根据使用的 GET 或 POST 方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给 DispatcherServlet。</p> </li> \n  <li><p>DispatcherServlet 将从 ViewResolver 获取请求的定义视图。</p> </li> \n  <li><p>当视图完成，DispatcherServlet 将模型数据传递到最终的视图，并在浏览器上呈现。</p> </li> \n </ul> \n <p>所有上述组件，即: HandlerMapping，Controller 和 ViewResolver 是 WebApplicationContext 的一部分，它是普通 ApplicationContext 的扩展，带有 Web 应用程序所需的一些额外功能。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(335,3,'第一个 Maven 应用程序',1,'www.funtl.com/assets/Lusifer1528025821.png',1,'<div class=\"col-sm-12\"> \n <p>下面我们来学习如何使用 Maven 创建一个 Java Web 应用程序</p> \n <h4 id=\"创建-Maven-项目\"><a href=\"#创建-Maven-项目\" class=\"headerlink\" title=\"创建 Maven 项目\"></a>创建 Maven 项目</h4>\n <p>选择 <code>File</code> -&gt; <code>New</code> -&gt; <code>Project...</code></p> \n <p><img src=\"/assets/Lusifer1528025821.png\" alt=\"\"></p> \n <p>选择 <code>Maven</code> 项目</p> \n <p><img src=\"/assets/Lusifer1528025904.png\" alt=\"\"></p> \n <p>填写项目信息</p> \n <p><img src=\"/assets/Lusifer1528025957.png\" alt=\"\"></p> \n <p>选择工作空间</p> \n <p><img src=\"/assets/Lusifer1528026009.png\" alt=\"\"></p> \n <h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4>\n <p>Java Web 的 Maven 基本结构如下：</p> \n <pre><code>├─src\n│  ├─main\n│  │  ├─java\n│  │  ├─resources\n│  │  └─webapp\n│  │      └─WEB-INF\n│  └─test\n│      └─java\n</code></pre>\n <p>结构说明：</p> \n <ul> \n  <li><code>src</code>：源码目录\n   <ul> \n    <li><code>src/main/java</code>：Java 源码目录</li> \n    <li><code>src/main/resources</code>：资源文件目录</li> \n    <li><code>src/main/webapp</code>：Web 相关目录</li> \n    <li><code>src/test</code>：单元测试</li> \n   </ul> </li> \n </ul> \n <h4 id=\"IDEA-Maven-项目管理\"><a href=\"#IDEA-Maven-项目管理\" class=\"headerlink\" title=\"IDEA Maven 项目管理\"></a>IDEA Maven 项目管理</h4>\n <p>在 IDEA 界面的右侧 <code>Maven Projects</code> 选项，可以管理 Maven 项目的整个生命周期、插件、依赖等</p> \n <p><img src=\"/assets/Lusifer1528027638.png\" alt=\"\"></p> \n <h3 id=\"完善-Java-Web-程序\"><a href=\"#完善-Java-Web-程序\" class=\"headerlink\" title=\"完善 Java Web 程序\"></a>完善 Java Web 程序</h3>\n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>修改 <code>pom.xml</code> 配置，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;hello-maven&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n            &lt;version&gt;4.0.1&lt;/version&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;1.7.25&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n <p>配置说明：</p> \n <ul> \n  <li><code>packaging</code>：打包方式，这里是 <code>war</code> 包，表示为 Java Web 应用程序</li> \n  <li><code>dependencies</code>：项目依赖配置，整个项目生命周期中所需的依赖都在这里配置</li> \n </ul> \n <h4 id=\"创建测试用-Servlet\"><a href=\"#创建测试用-Servlet\" class=\"headerlink\" title=\"创建测试用 Servlet\"></a>创建测试用 Servlet</h4>\n <p>创建一个 <code>Servlet</code> 用于测试请求</p> \n <pre><code>package com.funtl.hello.maven.servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class HelloServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        req.getRequestDispatcher(\"/index.jsp\").forward(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n</code></pre>\n <h4 id=\"创建测试用-JSP\"><a href=\"#创建测试用-JSP\" class=\"headerlink\" title=\"创建测试用 JSP\"></a>创建测试用 JSP</h4>\n <p>创建一个 <code>JSP</code> 页面，用于测试请求</p> \n <pre><code>&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    Hello Maven\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n <h4 id=\"创建-Log4J-的配置文件\"><a href=\"#创建-Log4J-的配置文件\" class=\"headerlink\" title=\"创建 Log4J 的配置文件\"></a>创建 Log4J 的配置文件</h4>\n <p>在 <code>src/main/resources</code> 目录下创建 <code>log4j.properties</code> 配置文件，内容如下：</p> \n <pre><code>log4j.rootLogger=INFO, console, file\n\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n\n\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.File=logs/log.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A3.MaxFileSize=1024KB\nlog4j.appender.A3.MaxBackupIndex=10\nlog4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre>\n <h4 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h4>\n <p><code>web.xml</code> 配置文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\"&gt;\n\n    &lt;servlet&gt;\n        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n        &lt;servlet-class&gt;com.funtl.hello.maven.servlet.HelloServlet&lt;/servlet-class&gt;\n    &lt;/servlet&gt;\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/servlet/hello&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;\n</code></pre>\n <h4 id=\"测试运行\"><a href=\"#测试运行\" class=\"headerlink\" title=\"测试运行\"></a>测试运行</h4>\n <p>按照之前章节 <code>第一个 IDEA 应用程序</code> 配置完 <code>Tomcat</code> 后直接运行，打开浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 显示如下：</p> \n <pre><code>Hello Maven\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:08','2018-12-20 22:06:08'),
(336,3,'MyBatis 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>MyBatis 是一个优秀的基于 Java 的持久层框架，它内部封装了 JDBC，使开发者只需关注 SQL 语句本身，而不用再花费精力去处理诸如注册驱动、创建 Connection、配置 Statement 等繁杂过程。</p> \n <p>Mybatis 通过 xml 或注解的方式将要执行的各种 Statement（Statement、PreparedStatement 等）配置起来，并通过 Java 对象和 Statement 中 SQL 的动态参数进行映射生成最终执行的 SQL 语句，最后由 MyBatis 框架执行 SQL 并将结果映射成 Java 对象并返回。</p> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018061304510001.png\">\n  <br>\n </div> \n <h3 id=\"MyBatis-与-Hibernate\"><a href=\"#MyBatis-与-Hibernate\" class=\"headerlink\" title=\"MyBatis 与 Hibernate\"></a>MyBatis 与 Hibernate</h3>\n <p>Hibernate 框架是提供了全面的数据库封装机制的 <strong>“全自动”</strong> ORM，即实现了 POJO 和数据库表之间的映射，以及 SQL 的自动生成和执行。</p> \n <p>相对于此，MyBatis 只能算作是 <strong>“半自动”</strong> ORM。其着力点，是在 POJO 类与 SQL 语句之间的映射关系。也就是说，MyBatis 并不会为程序员自动生成 SQL 语句。具体的 SQL 需要程序员自己编写，然后通过 SQL 语句映射文件，将 SQL 所需的参数，以及返回的结果字段映射到指定 POJO。因此，MyBatis 成为了“全自动”ORM 的一种有益补充。</p> \n <h3 id=\"MyBatis-的特点\"><a href=\"#MyBatis-的特点\" class=\"headerlink\" title=\"MyBatis 的特点\"></a>MyBatis 的特点</h3>\n <ul> \n  <li><p>在 XML 文件中配置 SQL 语句，实现了 SQL 语句与代码的分离，给程序的维护带来了很大便利。</p> </li> \n  <li><p>因为需要程序员自己去编写 SQL 语句，程序员可以结合数据库自身的特点灵活控制 SQL 语句，因此能够实现比 Hibernate 等全自动 ORM 框架更高的查询效率，能够完成复杂查询。</p> </li> \n  <li><p>简单，易于学习，易于使用，上手快。</p> </li> \n </ul> \n <div style=\"text-align:center\">\n  <br> \n  <img src=\"/assets/Lusifer2018061304510002.png\">\n  <br>\n </div> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(337,3,'第一个 Controller 控制器',1,NULL,1,'<div class=\"col-sm-12\"> \n <pre><code>package com.funtl.my.shop.web.controller;\n\nimport com.funtl.my.shop.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\n\n@Controller\npublic class LoginController {\n\n    @Autowired\n    private UserService userService;\n\n    @RequestMapping(value = {\"\", \"login\"}, method = RequestMethod.GET)\n    public String login() {\n        return \"login\";\n    }\n\n    @RequestMapping(value = \"login\", method = RequestMethod.POST)\n    public String login(@RequestParam(required = true) String email, @RequestParam(required = true) String password) {\n        return \"redirect:/main\";\n    }\n}\n</code></pre>\n <h4 id=\"注解说明\"><a href=\"#注解说明\" class=\"headerlink\" title=\"注解说明\"></a>注解说明</h4>\n <h5 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"@Controller\"></a>@Controller</h5>\n <p>在 Spring MVC 中，控制器 Controller 负责处理由 <code>DispatcherServlet</code> 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model ，然后再把该 Model 返回给对应的 View 进行展示。在 Spring MVC 中提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用 <code>@Controller</code> 标记一个类是 Controller ，然后使用 <code>@RequestMapping</code> 和 <code>@RequestParam</code> 等一些注解用以定义 URL 请求和 Controller 方法之间的映射，这样的 Controller 就能被外界访问到。此外 Controller 不会直接依赖于 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 等 <code>HttpServlet</code> 对象，它们可以通过 Controller 的方法参数灵活的获取到。</p> \n <p><code>@Controller</code> 用于标记在一个类上，使用它标记的类就是一个 Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了 <code>@RequestMapping</code> 注解。<code>@Controller</code> 只是定义了一个控制器类，而使用 <code>@RequestMapping</code> 注解的方法才是真正处理请求的处理器。</p> \n <h5 id=\"RequestMapping\"><a href=\"#RequestMapping\" class=\"headerlink\" title=\"@RequestMapping\"></a>@RequestMapping</h5>\n <p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。<strong>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径</strong>。</p> \n <p>RequestMapping 注解有六个属性：</p> \n <ul> \n  <li><p>value， method</p> \n   <ul> \n    <li>value：指定请求的实际地址，指定的地址可以是 URI Template 模式</li> \n    <li>method：指定请求的method类型， GET、POST、PUT、DELETE 等</li> \n   </ul> </li> \n  <li><p>consumes，produces</p> \n   <ul> \n    <li>consumes：指定处理请求的提交内容类型（Content-Type），例如 application/json, text/html</li> \n    <li>produces: 指定返回的内容类型，仅当 request 请求头中的(Accept)类型中包含该指定类型才返回</li> \n   </ul> </li> \n  <li><p>params，headers</p> \n   <ul> \n    <li>params：指定 request 中必须包含某些参数值是，才让该方法处理</li> \n    <li>headers：指定 request 中必须包含某些指定的 header 值，才能让该方法处理请求</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(338,3,'Maven 模块化开发',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>在多人协同开发时，特别是规模较大的项目，为了方便日后的代码维护和管理，我们会将每个开发人员的工作细分到具体的功能和模块上。随着项目的不断扩大，模块也会越来越多，后续会更加难以维护和扩展，为了应对这种情况后期我们还会采用微服务架构的方式进行开发。</p> \n <p>以当前教程为例，我们可以将模块划分为如下形式：</p> \n <ul> \n  <li><p>统一的依赖管理（dependencies）</p> </li> \n  <li><p>通用的工具类（commons）</p> </li> \n  <li><p>领域模型（domain）</p> </li> \n  <li><p>管理后台（admin）</p> </li> \n  <li><p>商城前端（ui）</p> </li> \n  <li><p>接口模块（api）</p> </li> \n </ul> \n <p>整个模块化开发过程主要是在开发思想上稍作了一些转变，只需要按照下面的流程操作即可。</p> \n <h4 id=\"创建根项目（工程）\"><a href=\"#创建根项目（工程）\" class=\"headerlink\" title=\"创建根项目（工程）\"></a>创建根项目（工程）</h4>\n <p>创建一个名为 <code>my-shop</code> 的工程，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;modules&gt;\n\n    &lt;/modules&gt;\n&lt;/project&gt;\n</code></pre>\n <p>该项目称之为 Root 项目，主要作用是管理整个工程的全部模块，当有新模块加入时需要在 <code>modules</code> 元素下配置对应的模块目录</p> \n <h4 id=\"创建统一的依赖管理\"><a href=\"#创建统一的依赖管理\" class=\"headerlink\" title=\"创建统一的依赖管理\"></a>创建统一的依赖管理</h4>\n <p>创建一个名为 <code>my-shop-dependencies</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-dependencies&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;!-- 环境配置 --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n\n        &lt;!-- 统一的依赖管理 --&gt;\n        &lt;commons-lang3.version&gt;3.5&lt;/commons-lang3.version&gt;\n        &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;\n        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n        &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;\n        &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt;\n        &lt;spring.version&gt;4.3.17.RELEASE&lt;/spring.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;!-- Spring Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n                &lt;version&gt;${spring.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n                &lt;version&gt;${spring.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Spring End --&gt;\n\n            &lt;!-- Servlet Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n                &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n                &lt;version&gt;${servlet-api.version}&lt;/version&gt;\n                &lt;scope&gt;provided&lt;/scope&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n                &lt;artifactId&gt;jstl&lt;/artifactId&gt;\n                &lt;version&gt;${jstl.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Servlet End --&gt;\n\n            &lt;!-- Log Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;\n                &lt;version&gt;${slf4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;log4j&lt;/groupId&gt;\n                &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n                &lt;version&gt;${log4j.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Log End --&gt;\n\n            &lt;!-- Commons Begin --&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n                &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n                &lt;version&gt;${commons-lang3.version}&lt;/version&gt;\n            &lt;/dependency&gt;\n            &lt;!-- Commons End --&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;!-- Compiler 插件, 设定 JDK 版本 --&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n                &lt;version&gt;3.7.0&lt;/version&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;${java.version}&lt;/source&gt;\n                    &lt;target&gt;${java.version}&lt;/target&gt;\n                    &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;\n                    &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n\n        &lt;!-- 资源文件配置 --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/java&lt;/directory&gt;\n                &lt;excludes&gt;\n                    &lt;exclude&gt;**/*.java&lt;/exclude&gt;\n                &lt;/excludes&gt;\n            &lt;/resource&gt;\n            &lt;resource&gt;\n                &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/build&gt;\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-dependencies&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建通用的工具类\"><a href=\"#创建通用的工具类\" class=\"headerlink\" title=\"创建通用的工具类\"></a>创建通用的工具类</h4>\n <p>创建一个名为 <code>my-shop-commons</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-commons&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-commons&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建领域模型\"><a href=\"#创建领域模型\" class=\"headerlink\" title=\"创建领域模型\"></a>创建领域模型</h4>\n <p>创建一个名为 <code>my-shop-domain</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-domain&lt;/artifactId&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-domain&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-domain&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建管理后台\"><a href=\"#创建管理后台\" class=\"headerlink\" title=\"创建管理后台\"></a>创建管理后台</h4>\n <p>创建一个名为 <code>my-shop-web-admin</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-admin&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-admin&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-domain&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-admin&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建商城前端\"><a href=\"#创建商城前端\" class=\"headerlink\" title=\"创建商城前端\"></a>创建商城前端</h4>\n <p>创建一个名为 <code>my-shop-web-ui</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-ui&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-ui&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-ui&lt;/module&gt;</code> 配置</p> \n <h4 id=\"创建接口模块\"><a href=\"#创建接口模块\" class=\"headerlink\" title=\"创建接口模块\"></a>创建接口模块</h4>\n <p>创建一个名为 <code>my-shop-web-api</code> 的项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n        &lt;artifactId&gt;my-shop-dependencies&lt;/artifactId&gt;\n        &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n        &lt;relativePath&gt;../my-shop-dependencies/pom.xml&lt;/relativePath&gt;\n    &lt;/parent&gt;\n\n    &lt;artifactId&gt;my-shop-web-api&lt;/artifactId&gt;\n    &lt;packaging&gt;war&lt;/packaging&gt;\n\n    &lt;name&gt;my-shop-web-api&lt;/name&gt;\n    &lt;description&gt;&lt;/description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n            &lt;artifactId&gt;my-shop-commons&lt;/artifactId&gt;\n            &lt;version&gt;${project.parent.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n <p>PS：别忘记在 <code>my-shop</code> 工程的 <code>pom.xml</code> 中增加 <code>&lt;module&gt;my-shop-web-api&lt;/module&gt;</code> 配置</p> \n <h4 id=\"清理、编译、打包\"><a href=\"#清理、编译、打包\" class=\"headerlink\" title=\"清理、编译、打包\"></a>清理、编译、打包</h4>\n <p>至此一个完整的模块化工程创建完毕，此时的 Root 工程 <code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.funtl&lt;/groupId&gt;\n    &lt;artifactId&gt;my-shop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;pom&lt;/packaging&gt;\n\n    &lt;modules&gt;\n        &lt;module&gt;my-shop-dependencies&lt;/module&gt;\n        &lt;module&gt;my-shop-commons&lt;/module&gt;\n        &lt;module&gt;my-shop-domain&lt;/module&gt;\n        &lt;module&gt;my-shop-web-admin&lt;/module&gt;\n        &lt;module&gt;my-shop-web-ui&lt;/module&gt;\n        &lt;module&gt;my-shop-web-api&lt;/module&gt;\n    &lt;/modules&gt;\n&lt;/project&gt;\n</code></pre>\n <p>我们可以在 Root 工程中使用 Maven 提供的 <code>mvn clean</code> 命令测试一下效果，控制台输出如下：</p> \n <pre><code>[INFO] Scanning for projects...\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] my-shop\n[INFO] my-shop-dependencies\n[INFO] my-shop-commons\n[INFO] my-shop-domain\n[INFO] my-shop-web-admin\n[INFO] my-shop-web-ui\n[INFO] my-shop-web-api\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-dependencies 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-dependencies ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-commons 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-commons ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-commons\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-domain 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-domain ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-domain\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-admin 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-admin ---\n[INFO] Deleting D:\\Workspace\\my-shop\\my-shop-web-admin\\target\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-ui 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-ui ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building my-shop-web-api 1.0.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ my-shop-web-api ---\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] my-shop ............................................ SUCCESS [  0.158 s]\n[INFO] my-shop-dependencies ............................... SUCCESS [  0.004 s]\n[INFO] my-shop-commons .................................... SUCCESS [  0.020 s]\n[INFO] my-shop-domain ..................................... SUCCESS [  0.016 s]\n[INFO] my-shop-web-admin .................................. SUCCESS [  0.033 s]\n[INFO] my-shop-web-ui ..................................... SUCCESS [  0.012 s]\n[INFO] my-shop-web-api .................................... SUCCESS [  0.008 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 0.400 s\n[INFO] Finished at: 2018-06-12T07:47:58+08:00\n[INFO] Final Memory: 8M/241M\n[INFO] ------------------------------------------------------------------------\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(339,3,'Spring 整合 MyBatis',1,NULL,1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>在 <code>pom.xml</code> 文件中增加 MyBatis 相关依赖：</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n    &lt;version&gt;3.2.8&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n    &lt;version&gt;1.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <p>主要增加了 3 个依赖，分别为 <code>org.mybatis:mybatis</code>、<code>org.mybatis:mybatis-spring</code>、<code>org.springframework:spring-jdbc</code></p> \n <h4 id=\"创建-MyBatis-配置文件\"><a href=\"#创建-MyBatis-配置文件\" class=\"headerlink\" title=\"创建 MyBatis 配置文件\"></a>创建 MyBatis 配置文件</h4>\n <p>创建一个名为 <code>mybatis-config.xml</code> 的配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;\n</code></pre>\n <h4 id=\"Spring-集成-MyBatis\"><a href=\"#Spring-集成-MyBatis\" class=\"headerlink\" title=\"Spring 集成 MyBatis\"></a>Spring 集成 MyBatis</h4>\n <p>创建一个名为 <code>spring-context-mybatis.xml</code> 的 Spring 配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 \',\' 号分割 --&gt;\n        &lt;property name=\"typeAliasesPackage\" value=\"com.funtl.my.shop.domain\"/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=\"mapperLocations\" value=\"classpath:/mapper/**/*.xml\"/&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;property name=\"basePackage\" value=\"com.funtl.my.shop.web.admin.dao\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(340,3,'Druid 简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>Druid 是阿里巴巴开源平台上的一个项目，整个项目由数据库连接池、插件框架和 SQL 解析器组成。该项目主要是为了扩展 JDBC 的一些限制，可以让程序员实现一些特殊的需求，比如向密钥服务请求凭证、统计 SQL 信息、SQL 性能收集、SQL 注入检查、SQL 翻译等，程序员可以通过定制来实现自己需要的功能。</p> \n <h3 id=\"各种连接池性能对比测试\"><a href=\"#各种连接池性能对比测试\" class=\"headerlink\" title=\"各种连接池性能对比测试\"></a>各种连接池性能对比测试</h3>\n <p>测试执行申请归还连接 1,000,000（一百万）次总耗时性能对比。</p> \n <h4 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h4>\n <table> \n  <thead> \n   <tr> \n    <th>环境</th> \n    <th>版本</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>OS</td> \n    <td>OS X 10.8.2</td> \n   </tr> \n   <tr> \n    <td>CPU</td> \n    <td>Intel i7 2GHz 4 Core</td> \n   </tr> \n   <tr> \n    <td>JVM</td> \n    <td>Java Version 1.7.0_05</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"基准测试结果\"><a href=\"#基准测试结果\" class=\"headerlink\" title=\"基准测试结果\"></a>基准测试结果</h4>\n <table> \n  <thead> \n   <tr> \n    <th>Jdbc Connection Pool</th> \n    <th>1 thread</th> \n    <th>2 threads</th> \n    <th>5 threads</th> \n    <th>10 threads</th> \n    <th>20 threads</th> \n    <th>50 threads</th> \n   </tr> \n  </thead> \n  <tbody> \n   <tr> \n    <td>Druid</td> \n    <td>898</td> \n    <td>1,191</td> \n    <td>1,324</td> \n    <td>1,362</td> \n    <td>1,325</td> \n    <td>1,459</td> \n   </tr> \n   <tr> \n    <td>tomcat-jdbc</td> \n    <td>1,269</td> \n    <td>1,378</td> \n    <td>2,029</td> \n    <td>2,103</td> \n    <td>1,879</td> \n    <td>2,025</td> \n   </tr> \n   <tr> \n    <td>DBCP</td> \n    <td>2,324</td> \n    <td>5,055</td> \n    <td>5,446</td> \n    <td>5,471</td> \n    <td>5,524</td> \n    <td>5,415</td> \n   </tr> \n   <tr> \n    <td>BoneCP</td> \n    <td>3,738</td> \n    <td>3,150</td> \n    <td>3,194</td> \n    <td>5,681</td> \n    <td>11,018</td> \n    <td>23,125</td> \n   </tr> \n   <tr> \n    <td>jboss-datasource</td> \n    <td>4,377</td> \n    <td>2,988</td> \n    <td>3,680</td> \n    <td>3,980</td> \n    <td>32,708</td> \n    <td>37,742</td> \n   </tr> \n   <tr> \n    <td>C3P0</td> \n    <td>10,841</td> \n    <td>13,637</td> \n    <td>10,682</td> \n    <td>11,055</td> \n    <td>14,497</td> \n    <td>20,351</td> \n   </tr> \n   <tr> \n    <td>Proxool</td> \n    <td>16,337</td> \n    <td>16,187</td> \n    <td>18,310(Exception)</td> \n    <td>25,945</td> \n    <td>33,706(Exception)</td> \n    <td>39,501 (Exception)</td> \n   </tr> \n  </tbody> \n </table> \n <h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4>\n <ul> \n  <li><p>Druid 是性能最好的数据库连接池，tomcat-jdbc 和 druid 性能接近。</p> </li> \n  <li><p>proxool 在激烈并发时会抛异常，完全不靠谱。</p> </li> \n  <li><p>c3p0 和 proxool 都相当慢，慢到影响 sql 执行效率的地步。</p> </li> \n  <li><p>bonecp 性能并不优越，采用 LinkedTransferQueue 并没有能够获得性能提升。</p> </li> \n  <li><p>除了 bonecp，其他的在 JDK 7 上跑得比 JDK 6 上快</p> </li> \n  <li><p>jboss-datasource 虽然稳定，但是性能很糟糕</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(341,3,'MyBatis 单表 CRUD 操作',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>本章主要内容是带领大家学习 MyBatis 的单表 CRUD 的相关操作方法</p> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(342,3,'Spring 整合 Druid',1,'www.funtl.com/assets/Lusifer1528842755.png',1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>在 <code>pom.xml</code> 文件中新增 <code>com.alibaba:druid</code> 和 <code>mysql:mysql-connector-java</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid&lt;/artifactId&gt;\n    &lt;version&gt;1.1.6&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n    &lt;version&gt;5.1.46&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"配置数据库连接\"><a href=\"#配置数据库连接\" class=\"headerlink\" title=\"配置数据库连接\"></a>配置数据库连接</h4>\n <p>配置数据库连接 <code>jdbc.properties</code> ，配置代码如下：</p> \n <pre><code># JDBC\n# MySQL 8.x: com.mysql.cj.jdbc.Driver\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.connectionURL=jdbc:mysql://192.168.75.134:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\njdbc.username=root\njdbc.password=123456\n\n# JDBC Pool\njdbc.pool.init=1\njdbc.pool.minIdle=3\njdbc.pool.maxActive=20\n\n# JDBC Test\njdbc.testSql=SELECT \'x\' FROM DUAL\n</code></pre>\n <h4 id=\"Spring-集成-Druid\"><a href=\"#Spring-集成-Druid\" class=\"headerlink\" title=\"Spring 集成 Druid\"></a>Spring 集成 Druid</h4>\n <p>创建一个名为 <code>spring-context-druid.xml</code> 的 Spring 配置文件，内容如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;\n        &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;\n        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClass}\"/&gt;\n\n        &lt;!-- 基本属性 url、user、password --&gt;\n        &lt;property name=\"url\" value=\"${jdbc.connectionURL}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n\n        &lt;!-- 配置初始化大小、最小、最大 --&gt;\n        &lt;property name=\"initialSize\" value=\"${jdbc.pool.init}\"/&gt;\n        &lt;property name=\"minIdle\" value=\"${jdbc.pool.minIdle}\"/&gt;\n        &lt;property name=\"maxActive\" value=\"${jdbc.pool.maxActive}\"/&gt;\n\n        &lt;!-- 配置获取连接等待超时的时间 --&gt;\n        &lt;property name=\"maxWait\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;\n        &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;\n        &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt;\n\n        &lt;property name=\"validationQuery\" value=\"${jdbc.testSql}\"/&gt;\n        &lt;property name=\"testWhileIdle\" value=\"true\"/&gt;\n        &lt;property name=\"testOnBorrow\" value=\"false\"/&gt;\n        &lt;property name=\"testOnReturn\" value=\"false\"/&gt;\n\n        &lt;!-- 配置监控统计拦截的filters --&gt;\n        &lt;property name=\"filters\" value=\"stat\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h4 id=\"配置-Druid-监控中心\"><a href=\"#配置-Druid-监控中心\" class=\"headerlink\" title=\"配置 Druid 监控中心\"></a>配置 Druid 监控中心</h4>\n <p>Druid 提供了大量的监控数据，只需要在 <code>web.xml</code> 中配置一个 Servlet 就可以方便的查看这些信息。</p> \n <p>修改 <code>web.xml</code> 配置文件，增加 Druid 提供的 Servlet</p> \n <pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n <p>打开浏览器，输入：<a href=\"http://localhost:8080/druid/index.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/druid/index.html</a> 浏览器显示效果如下：</p> \n <p><img src=\"/assets/Lusifer1528842755.png\" alt=\"\"></p> \n</div>',NULL,NULL,'2018-12-20 22:06:09','2018-12-20 22:06:09'),
(343,3,'第一个 MyBatis 对象关系映射',1,NULL,1,'<div class=\"col-sm-12\"> \n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p>编写完相关代码后，我们可以使用单元测试查看 MyBatis 的执行效果，需要增加单元测试相关依赖，配置如下：</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;/groupId&gt;\n    &lt;artifactId&gt;junit&lt;/artifactId&gt;\n    &lt;version&gt;4.12&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h4 id=\"导入-SQL\"><a href=\"#导入-SQL\" class=\"headerlink\" title=\"导入 SQL\"></a>导入 SQL</h4>\n <p>群共享中已经为大家准备好了练习用的 SQL，位置： <code>Java 微服务架构相关环境资料-SQL/myshop.zip</code>，有需要的同学可以加群获取</p> \n <h4 id=\"定义实体类\"><a href=\"#定义实体类\" class=\"headerlink\" title=\"定义实体类\"></a>定义实体类</h4>\n <p>以 <code>tb_user</code> 表为例，实体类代码如下：</p> \n <pre><code>package com.funtl.my.shop.domain;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\npublic class TbUser implements Serializable {\n    private Long id;\n    private String username;\n    private String password;\n    private String phone;\n    private String email;\n    private Date created;\n    private Date update;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public void setEmail(String email) {\n        this.email = email;\n    }\n\n    public Date getCreated() {\n        return created;\n    }\n\n    public void setCreated(Date created) {\n        this.created = created;\n    }\n\n    public Date getUpdate() {\n        return update;\n    }\n\n    public void setUpdate(Date update) {\n        this.update = update;\n    }\n}\n</code></pre>\n <h4 id=\"定义数据访问接口\"><a href=\"#定义数据访问接口\" class=\"headerlink\" title=\"定义数据访问接口\"></a>定义数据访问接口</h4>\n <p>注意：Spring 集成 MyBatis 后，不需要手动实现 DAO 层的接口，所有的 SQL 执行语句都写在对应的关系映射配置文件中。</p> \n <pre><code>package com.funtl.my.shop.web.admin.dao;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.List;\n\n@Repository\npublic interface TbUserDao {\n\n    /**\n     * 查询全部用户信息\n     * @return\n     */\n    public List&lt;TbUser&gt; selectAll();\n}\n</code></pre>\n <h4 id=\"定义业务逻辑接口\"><a href=\"#定义业务逻辑接口\" class=\"headerlink\" title=\"定义业务逻辑接口\"></a>定义业务逻辑接口</h4>\n <pre><code>package com.funtl.my.shop.web.admin.service;\n\nimport com.funtl.my.shop.domain.TbUser;\n\nimport java.util.List;\n\npublic interface TbUserService {\n\n    /**\n     * 查询全部用户信息\n     * @return\n     */\n    public List&lt;TbUser&gt; selectAll();\n}\n</code></pre>\n <h4 id=\"实现业务逻辑接口\"><a href=\"#实现业务逻辑接口\" class=\"headerlink\" title=\"实现业务逻辑接口\"></a>实现业务逻辑接口</h4>\n <pre><code>package com.funtl.my.shop.web.admin.service.impl;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.dao.TbUserDao;\nimport com.funtl.my.shop.web.admin.service.TbUserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n@Service\npublic class TbUserServiceImpl implements TbUserService {\n\n    @Autowired\n    private TbUserDao tbUserDao;\n\n    @Override\n    public List&lt;TbUser&gt; selectAll() {\n        return tbUserDao.selectAll();\n    }\n}\n</code></pre>\n <h4 id=\"定义映射文件\"><a href=\"#定义映射文件\" class=\"headerlink\" title=\"定义映射文件\"></a>定义映射文件</h4>\n <p>映射文件，简称为 Mapper，主要完成 DAO 层中 SQL 语句的映射。映射文件名随意，一般放在 <code>src/resources/mapper</code> 文件夹中。这里映射文件名称定为 <code>TbUserMapper.xml</code>。</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.funtl.my.shop.web.admin.dao.TbUserDao\"&gt;\n    &lt;select id=\"selectAll\" resultType=\"TbUser\"&gt;\n        SELECT\n          a.id,\n          a.username,\n          a.password,\n          a.phone,\n          a.email,\n          a.created,\n          a.updated\n        FROM\n          tb_user AS a\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h4 id=\"创建单元测试\"><a href=\"#创建单元测试\" class=\"headerlink\" title=\"创建单元测试\"></a>创建单元测试</h4>\n <p>所有工作准备就绪，我们就可以测试 MyBatis 是否能够正常执行了。创建一个单元测试类，代码如下：</p> \n <pre><code>package com.funtl.my.shop.web.admin.service.test;\n\nimport com.funtl.my.shop.domain.TbUser;\nimport com.funtl.my.shop.web.admin.dao.TbUserDao;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.util.List;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:spring-context.xml\", \"classpath:spring-context-druid.xml\", \"classpath:spring-context-mybatis.xml\"})\npublic class TbUserServiceTest {\n\n    @Autowired\n    private TbUserDao tbUserDao;\n\n    @Test\n    public void testSelectAll() {\n        List&lt;TbUser&gt; tbUsers = tbUserDao.selectAll();\n        for (TbUser tbUser : tbUsers) {\n            System.out.println(tbUser.getUsername());\n        }\n    }\n}\n</code></pre>\n <p>成功执行测试后，控制台输出如下：</p> \n <pre><code>2018-06-13 08:00:40,069 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Loaded default TestExecutionListener class names from location [META-INF/spring.factories]: [org.springframework.test.context.web.ServletTestExecutionListener, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener, org.springframework.test.context.support.DependencyInjectionTestExecutionListener, org.springframework.test.context.support.DirtiesContextTestExecutionListener, org.springframework.test.context.transaction.TransactionalTestExecutionListener, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener]\n2018-06-13 08:00:40,106 INFO [org.springframework.test.context.support.DefaultTestContextBootstrapper] - Using TestExecutionListeners: [org.springframework.test.context.web.ServletTestExecutionListener@4b9e13df, org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener@2b98378d, org.springframework.test.context.support.DependencyInjectionTestExecutionListener@475530b9, org.springframework.test.context.support.DirtiesContextTestExecutionListener@1d057a39, org.springframework.test.context.transaction.TransactionalTestExecutionListener@26be92ad, org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener@4c70fda8]2018-06-13 08:00:40,213 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context.xml]\n2018-06-13 08:00:40,513 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-druid.xml]\n2018-06-13 08:00:40,565 INFO [org.springframework.beans.factory.xml.XmlBeanDefinitionReader] - Loading XML bean definitions from class path resource [spring-context-mybatis.xml]\n2018-06-13 08:00:40,586 INFO [org.springframework.context.support.GenericApplicationContext] - Refreshing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy\n2018-06-13 08:00:41,650 INFO [com.alibaba.druid.pool.DruidDataSource] - {dataSource-1} inited\nzhangsan\nzhangsan1\nzhangsan2\nzhangsan3\nzhangsan5\nlisi\nlisi1\njd_gogogo\ntidy\ntidy1\nniuniu\nniuniu2\nniuniu3\nniuniu4\ntest01\ntest02\n2018-06-13 08:00:42,143 INFO [org.springframework.context.support.GenericApplicationContext] - Closing org.springframework.context.support.GenericApplicationContext@55d56113: startup date [Wed Jun 13 08:00:40 CST 2018]; root of context hierarchy\n2018-06-13 08:00:42,149 INFO [com.alibaba.druid.pool.DruidDataSource] - {dataSource-1} closed\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(344,3,'Spring MVC 拦截器的使用',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"拦截器简介\"><a href=\"#拦截器简介\" class=\"headerlink\" title=\"拦截器简介\"></a>拦截器简介</h3>\n <p>Spring Web MVC 的处理器拦截器，类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。</p> \n <h3 id=\"常见应用场景\"><a href=\"#常见应用场景\" class=\"headerlink\" title=\"常见应用场景\"></a>常见应用场景</h3>\n <ul> \n  <li><p>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算 PV（Page View）等</p> </li> \n  <li><p>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</p> </li> \n  <li><p>性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</p> </li> \n  <li><p>通用行为：读取 Cookie 得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取 Locale、Theme 信息等，只要是多个处理器都需要的即可使用拦截器实现</p> </li> \n </ul> \n <h3 id=\"第一个-Spring-MVC-拦截器\"><a href=\"#第一个-Spring-MVC-拦截器\" class=\"headerlink\" title=\"第一个 Spring MVC 拦截器\"></a>第一个 Spring MVC 拦截器</h3>\n <p>Spring MVC 拦截器需要实现 <code>HandlerInterceptor</code> 接口，该接口定义了 3 个方法，分别为 <code>preHandle()</code>、<code>postHandle()</code> 和 <code>afterCompletion()</code>，咱们就是通过重写这 3 个方法来对用户的请求进行拦截处理的。</p> \n <ul> \n  <li><p><code>preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)</code>：该方法在请求处理之前进行调用。Spring MVC 中的 Interceptor 是链式调用的，在一个应用中或者说是在一个请求中可以同时存在多个 Interceptor 。每个 Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是 Interceptor 中的 <code>preHandle</code> 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求做一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值 Boolean 类型的，当它返回为 <code>false</code> 时，表示请求结束，后续的 Interceptor 和 Controller 都不会再执行；当返回值为 <code>true</code> 时，就会继续调用下一个 Interceptor 的 <code>preHandle</code> 方法，如果已经是最后一个 Interceptor 的时候，就会是调用当前请求的 Controller 中的方法。</p> </li> \n  <li><p><code>postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)</code>：通过 <code>preHandle</code> 方法的解释咱们知道这个方法包括后面要说到的 <code>afterCompletion</code> 方法都只能在当前所属的 Interceptor 的 <code>preHandle</code> 方法的返回值为 <code>true</code> 的时候，才能被调用。<code>postHandle</code> 方法在当前请求进行处理之后，也就是在 Controller 中的方法调用之后执行，但是它会在 <code>DispatcherServlet</code> 进行视图返回渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 <code>ModelAndView</code> 对象进行操作。<code>postHandle</code> 方法被调用的方向跟 <code>preHandle</code> 是相反的，也就是说，先声明的 Interceptor 的 <code>postHandle</code> 方法反而会后执行。</p> </li> \n  <li><p><code>afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)</code>：也是需要当前对应的 Interceptor 的 <code>preHandle</code> 方法的返回值为 <code>true</code> 时才会执行。因此，该方法将在整个请求结束之后，也就是在 <code>DispatcherServlet</code> 渲染了对应的视图之后执行，这个方法的主要作用是用于进行资源清理的工作。</p> </li> \n </ul> \n <h4 id=\"创建登录拦截器\"><a href=\"#创建登录拦截器\" class=\"headerlink\" title=\"创建登录拦截器\"></a>创建登录拦截器</h4>\n <p>我们知道对系统的相关操作是需要登录后才可以使用的，当未登录时是无法直接访问需要登录权限的操作的，为了做到这个效果，我们使用登录拦截器来判断用户是否登录，如果用户已登录则放行让用户继续操作，否则就将其跳转到登录页。</p> \n <p>定义一个名为 <code>LoginInterceptor</code> 的拦截器，代码如下：</p> \n <pre><code>package com.funtl.my.shop.web.interceptor;\n\nimport com.funtl.my.shop.entity.User;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * 登录拦截器\n * &lt;p&gt;Title: LoginInterceptor&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/12 5:44\n */\npublic class LoginInterceptor implements HandlerInterceptor {\n    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n        User user = (User) httpServletRequest.getSession().getAttribute(\"user\");\n\n        // 判断用户是否登录\n        if (user == null) {\n            // 用户未登录，重定向到登录页\n            httpServletResponse.sendRedirect(\"/login\");\n            return false;\n        }\n\n        // 放行\n        return true;\n    }\n\n    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n        // 如果请求来自登录页\n        if (modelAndView.getViewName().endsWith(\"login\")) {\n            // 则直接重定向到首页不再显示登录页\n            httpServletResponse.sendRedirect(\"/main\");\n        }\n    }\n\n    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n    }\n}\n</code></pre>\n <h4 id=\"在-spring-mvc-xml-中配置拦截器\"><a href=\"#在-spring-mvc-xml-中配置拦截器\" class=\"headerlink\" title=\"在 spring-mvc.xml 中配置拦截器\"></a>在 <code>spring-mvc.xml</code> 中配置拦截器</h4>\n <p>拦截器定义后还需要在 <code>spring-mvc.xml</code> 中配置拦截器，代码如下：</p> \n <pre><code>&lt;!-- 拦截器配置，拦截顺序：先执行后定义的，排在第一位的最后执行。--&gt;\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path=\"/**\"/&gt;\n        &lt;mvc:exclude-mapping path=\"/static/**\"/&gt;\n        &lt;mvc:exclude-mapping path=\"/login\"/&gt;\n        &lt;bean class=\"com.funtl.my.shop.web.interceptor.LoginInterceptor\"/&gt;\n    &lt;/mvc:interceptor&gt;\n&lt;/mvc:interceptors&gt;\n</code></pre>\n <p>相关配置说明：</p> \n <ul> \n  <li><code>mvc:interceptor</code>：定义一个拦截器\n   <ul> \n    <li><code>mvc:mapping</code>：映射路径，需要拦截的请求路径</li> \n    <li><code>mvc:exclude-mapping</code>：需要排除的请求路径，比如登录页本身是不需要拦截的，这里还包括了静态资源路径也是不需要拦截的</li> \n    <li><code>bean class</code>：配置指定的拦截器对象</li> \n   </ul> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(345,3,'Spring 整合 Spring MVC',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h3>\n <p>在 <code>pom.xml</code> 配置文件中增加 <code>org.springframework:spring-webmvc</code> 依赖</p> \n <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n    &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n <h3 id=\"配置-web-xml\"><a href=\"#配置-web-xml\" class=\"headerlink\" title=\"配置 web.xml\"></a>配置 <code>web.xml</code></h3>\n <h4 id=\"CharacterEncodingFilter\"><a href=\"#CharacterEncodingFilter\" class=\"headerlink\" title=\"CharacterEncodingFilter\"></a>CharacterEncodingFilter</h4>\n <p>配置字符集过滤器，用于解决中文编码问题</p> \n <pre><code>&lt;filter&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;encoding&lt;/param-name&gt;\n        &lt;param-value&gt;UTF-8&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;\n        &lt;param-value&gt;true&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n</code></pre>\n <h4 id=\"DispatcherServlet\"><a href=\"#DispatcherServlet\" class=\"headerlink\" title=\"DispatcherServlet\"></a>DispatcherServlet</h4>\n <p>配置 Spring 的 Servlet 分发器处理所有 HTTP 的请求和响应</p> \n <pre><code>&lt;servlet&gt;\n    &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n        &lt;param-value&gt;classpath*:/spring-mvc*.xml&lt;/param-value&gt;\n    &lt;/init-param&gt;\n    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;\n&lt;/servlet&gt;\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n</code></pre>\n <h3 id=\"配置-Spring-MVC\"><a href=\"#配置-Spring-MVC\" class=\"headerlink\" title=\"配置 Spring MVC\"></a>配置 Spring MVC</h3>\n <p>创建一个名为 <code>spring-mvc.xml</code> 文件来配置 MVC</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;\n\n    &lt;description&gt;Spring MVC Configuration&lt;/description&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:myshop.properties\"/&gt;\n\n    &lt;!-- 使用 Annotation 自动注册 Bean,只扫描 @Controller --&gt;\n    &lt;context:component-scan base-package=\"com.lusifer.myshop\" use-default-filters=\"false\"&gt;\n        &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n    &lt;/context:component-scan&gt;\n\n    &lt;!-- 默认的注解映射的支持 --&gt;\n    &lt;mvc:annotation-driven /&gt;\n\n    &lt;!-- 定义视图文件解析 --&gt;\n    &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt;\n        &lt;property name=\"prefix\" value=\"${web.view.prefix}\"/&gt;\n        &lt;property name=\"suffix\" value=\"${web.view.suffix}\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 静态资源映射 --&gt;\n    &lt;mvc:resources mapping=\"/static/**\" location=\"/static/\" cache-period=\"31536000\"/&gt;\n&lt;/beans&gt;\n</code></pre>\n <p>相关配置说明：</p> \n <ul> \n  <li><p><code>context:property-placeholder</code>：动态加载属性配置文件以变量的方式引用需要的值</p> </li> \n  <li><p><code>context:component-scan</code>：当前配置文件为 MVC 相关，故只需要扫描包含 <code>@Controller</code> 的注解即可，由于 <code>spring-context.xml</code> 配置文件中也配置了包扫描，所以还需要排除 <code>@Controller</code> 的注解扫描。</p> </li> \n  <li><p><code>InternalResourceViewResolver</code>：视图文件解析器的一种，用于配置视图资源的路径和需要解释的视图资源文件类型，这里有两个需要配置的属性 <code>prefix</code>（前缀）以及 <code>suffix</code>（后缀）。</p> \n   <ul> \n    <li><code>prefix</code>：配置视图资源路径，如：<code>/WEB-INF/views/</code></li> \n    <li><code>suffix</code>：配置视图资源类型，如：<code>.jsp</code></li> \n   </ul> </li> \n  <li><p><code>mvc:resources</code>：静态资源映射，主要用于配置静态资源文件存放路径，如：JS、CSS、Image 等</p> </li> \n </ul> \n <h4 id=\"系统相关配置\"><a href=\"#系统相关配置\" class=\"headerlink\" title=\"系统相关配置\"></a>系统相关配置</h4>\n <p>在 <code>spring-mvc.xnl</code> 中，我们配置了 <code>&lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:myshop.properties\"/&gt;</code> 用于动态加载属性配置文件，实际开发中我们会将系统所需的一些配置信息封装到 <code>.properties</code> 配置文件中便于统一的管理。</p> \n <p>创建一个名为 <code>myshop.properties</code> 的配置文件，内容如下：</p> \n <pre><code>#============================#\n#==== Framework settings ====#\n#============================#\n\n# \\u89c6\\u56fe\\u6587\\u4ef6\\u5b58\\u653e\\u8def\\u5f84\nweb.view.prefix=/WEB-INF/views/\nweb.view.suffix=.jsp\n</code></pre>\n <h4 id=\"去掉-Spring-配置的重复扫描\"><a href=\"#去掉-Spring-配置的重复扫描\" class=\"headerlink\" title=\"去掉 Spring 配置的重复扫描\"></a>去掉 Spring 配置的重复扫描</h4>\n <p>由于 <code>spring-mvc.xml</code> 中已经配置了 <code>@Controller</code> 注解的扫描而 <code>spring-context.xml</code> 中配置的是扫描全部注解，故在这里需要将 <code>@Controller</code> 注解的扫描配置排除。</p> \n <p>修改 <code>spring-context.xml</code> 配置：</p> \n <pre><code>&lt;!-- 使用 Annotation 自动注册 Bean，在主容器中不扫描 @Controller 注解，在 SpringMVC 中只扫描 @Controller 注解。--&gt;\n&lt;context:component-scan base-package=\"com.funtl.my.shop\"&gt;\n    &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n&lt;/context:component-scan&gt;\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(346,3,'使用 Apache HttpClient 解决通信问题',1,'www.funtl.com/assets/Lusifer201807030001.png',1,'<div class=\"col-sm-12\"> \n <h3 id=\"简易架构图\"><a href=\"#简易架构图\" class=\"headerlink\" title=\"简易架构图\"></a>简易架构图</h3>\n <p><img src=\"/assets/Lusifer201807030001.png\" alt=\"\"></p> \n <h3 id=\"Apache-HttpClient-简介\"><a href=\"#Apache-HttpClient-简介\" class=\"headerlink\" title=\"Apache HttpClient 简介\"></a>Apache HttpClient 简介</h3>\n <blockquote> \n  <p>HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。HttpClient 已经应用在很多的项目中，比如 Apache Jakarta 上很著名的另外两个开源项目 Cactus 和 <strong>HTMLUnit</strong> 都使用了 HttpClient。</p> \n </blockquote> \n <p>HttpClient 相比传统 JDK 自带的 <code>URLConnection</code>，增加了易用性和灵活性，它不仅是客户端发送 HTTP 请求变得容易，而且也方便了开发人员测试接口（基于 HTTP 协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握 HttpClient 是很重要的必修内容，掌握 HttpClient 后，相信对于 HTTP 协议的了解会更加深入。</p> \n <h3 id=\"Apache-HttpClient-特性\"><a href=\"#Apache-HttpClient-特性\" class=\"headerlink\" title=\"Apache HttpClient 特性\"></a>Apache HttpClient 特性</h3>\n <ul> \n  <li><p>基于标准、纯净的 Java 语言。实现了 HTTP 1.0 和 HTTP 1.1</p> </li> \n  <li><p>以可扩展的面向对象的结构实现了 HTTP 全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</p> </li> \n  <li><p>支持 HTTPS 协议。</p> </li> \n  <li><p>通过 HTTP 代理建立透明的连接。</p> </li> \n  <li><p>利用 CONNECT 方法通过 HTTP 代理建立隧道的 HTTPS 连接。</p> </li> \n  <li><p>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos 认证方案。</p> </li> \n  <li><p>插件式的自定义认证方案。</p> </li> \n  <li><p>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</p> </li> \n  <li><p>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</p> </li> \n  <li><p>自动处理 Set-Cookie 中的 Cookie。</p> </li> \n  <li><p>插件式的自定义 Cookie 策略。</p> </li> \n  <li><p>Request 的输出流可以避免流中内容直接缓冲到 Socket 服务器。</p> </li> \n  <li><p>Response 的输入流可以有效的从 Socket 服务器直接读取相应内容。</p> </li> \n  <li><p>在 HTTP 1.0 和 HTTP 1.1 中利用 KeepAlive 保持持久连接。</p> </li> \n  <li><p>直接获取服务器发送的 response code 和 headers。</p> </li> \n  <li><p>设置连接超时的能力。</p> </li> \n  <li><p>实验性的支持 HTTP 1.1 response caching。</p> </li> \n  <li><p>源代码基于 Apache License 可免费获取。</p> </li> \n </ul> \n <h3 id=\"Apache-HttpClient-使用流程\"><a href=\"#Apache-HttpClient-使用流程\" class=\"headerlink\" title=\"Apache HttpClient 使用流程\"></a>Apache HttpClient 使用流程</h3>\n <p>使用 HttpClient 发送请求、接收响应很简单，一般需要如下几步即可。</p> \n <ul> \n  <li><p>创建 <code>HttpClient</code> 对象。</p> </li> \n  <li><p>创建请求方法的实例，并指定请求 URL。如果需要发送 GET 请求，创建 <code>HttpGet</code> 对象；如果需要发送 POST 请求，创建 <code>HttpPost</code> 对象。</p> </li> \n  <li><p>如果需要发送请求参数，可调用 <code>HttpGet</code>、<code>HttpPost</code> 共同的 <code>setParams(HttpParams params)</code> 方法来添加请求参数；对于 <code>HttpPost</code> 对象而言，也可调用 <code>setEntity(HttpEntity entity)</code> 方法来设置请求参数。</p> </li> \n  <li><p>调用 <code>HttpClient</code> 对象的 <code>execute(HttpUriRequest request)</code> 发送请求，该方法返回一个 <code>HttpResponse</code>。</p> </li> \n  <li><p>调用 <code>HttpResponse</code> 的 <code>getAllHeaders()</code>、<code>getHeaders(String name)</code> 等方法可获取服务器的响应头；调用 <code>HttpResponse</code> 的 <code>getEntity()</code> 方法可获取 <code>HttpEntity</code> 对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。</p> </li> \n  <li><p>释放连接。无论执行方法是否成功，都必须释放连接</p> </li> \n </ul> \n <h3 id=\"Apache-HttpClient-使用实例\"><a href=\"#Apache-HttpClient-使用实例\" class=\"headerlink\" title=\"Apache HttpClient 使用实例\"></a>Apache HttpClient 使用实例</h3>\n <h4 id=\"POM\"><a href=\"#POM\" class=\"headerlink\" title=\"POM\"></a>POM</h4>\n <p><code>pom.xml</code> 配置如下：</p> \n <pre><code>&lt;!-- Apache Http Begin --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;fluent-hc&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpmime&lt;/artifactId&gt;\n    &lt;version&gt;4.5.5&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- Apache Http End --&gt;\n</code></pre>\n <p>主要增加了 <code>org.apache.httpcomponents:httpclient</code>、<code>org.apache.httpcomponents:fluent-hc</code>、<code>org.apache.httpcomponents:httpmime</code> 三个依赖</p> \n <h4 id=\"创建-HttpGet-请求\"><a href=\"#创建-HttpGet-请求\" class=\"headerlink\" title=\"创建 HttpGet 请求\"></a>创建 HttpGet 请求</h4>\n <p>案例代码如下：</p> \n <pre><code>package com.funtl.hello.httpclient;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        get();\n    }\n\n    private static void get() {\n        // 创建 HttpClient 客户端\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n\n        // 创建 HttpGet 请求\n        HttpGet httpGet = new HttpGet(\"http://localhost:8080/content/page?draw=1&amp;start=0&amp;length=10\");\n        // 设置长连接\n        httpGet.setHeader(\"Connection\", \"keep-alive\");\n        // 设置代理（模拟浏览器版本）\n        httpGet.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n        // 设置 Cookie\n        httpGet.setHeader(\"Cookie\", \"UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4\");\n\n        CloseableHttpResponse httpResponse = null;\n        try {\n            // 请求并获得响应结果\n            httpResponse = httpClient.execute(httpGet);\n            HttpEntity httpEntity = httpResponse.getEntity();\n            // 输出请求结果\n            System.out.println(EntityUtils.toString(httpEntity));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 无论如何必须关闭连接\n        finally {\n            if (httpResponse != null) {\n                try {\n                    httpResponse.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (httpClient != null) {\n                try {\n                    httpClient.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n</code></pre>\n <p>控制台输出结果：</p> \n <pre><code>{\"draw\":1,\"recordsTotal\":1,\"recordsFiltered\":1,\"data\":[{\"id\":33,\"created\":1530542074000,\"updated\":1530542074000,\"title\":\"ad1\",\"subTitle\":\"ad1\",\"titleDesc\":\"ad1\",\"url\":\"https://sale.jd.com/act/XkCzhoisOMSW.html\",\"pic\":\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\",\"pic2\":\"\",\"content\":\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\",\"tbContentCategory\":{\"id\":89,\"created\":null,\"updated\":null,\"parent\":null,\"isParent\":null,\"name\":\"幻灯片\",\"status\":null,\"sortOrder\":null}}],\"error\":null}\n</code></pre>\n <h4 id=\"创建-HttpPost-请求\"><a href=\"#创建-HttpPost-请求\" class=\"headerlink\" title=\"创建 HttpPost 请求\"></a>创建 HttpPost 请求</h4>\n <p>案例代码如下：</p> \n <pre><code>package com.funtl.hello.httpclient;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        post();\n    }\n\n    private static void post() {\n        // 创建 HttpClient 客户端\n        CloseableHttpClient httpClient = HttpClients.createDefault();\n\n        // 创建 HttpPost 请求\n        HttpPost httpPost = new HttpPost(\"http://localhost:8080/content/page\");\n        // 设置长连接\n        httpPost.setHeader(\"Connection\", \"keep-alive\");\n        // 设置代理（模拟浏览器版本）\n        httpPost.setHeader(\"User-Agent\", \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\");\n        // 设置 Cookie\n        httpPost.setHeader(\"Cookie\", \"UM_distinctid=16442706a09352-0376059833914f-3c604504-1fa400-16442706a0b345; CNZZDATA1262458286=1603637673-1530123020-%7C1530123020; JSESSIONID=805587506F1594AE02DC45845A7216A4\");\n\n        // 创建 HttpPost 参数\n        List&lt;BasicNameValuePair&gt; params = new ArrayList&lt;BasicNameValuePair&gt;();\n        params.add(new BasicNameValuePair(\"draw\", \"1\"));\n        params.add(new BasicNameValuePair(\"start\", \"0\"));\n        params.add(new BasicNameValuePair(\"length\", \"10\"));\n\n        CloseableHttpResponse httpResponse = null;\n        try {\n            // 设置 HttpPost 参数\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            httpResponse = httpClient.execute(httpPost);\n            HttpEntity httpEntity = httpResponse.getEntity();\n            // 输出请求结果\n            System.out.println(EntityUtils.toString(httpEntity));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // 无论如何必须关闭连接\n        finally {\n            try {\n                if (httpResponse != null) {\n                    httpResponse.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            try {\n                if (httpClient != null) {\n                    httpClient.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n <p>控制台输出结果：</p> \n <pre><code>{\"draw\":1,\"recordsTotal\":1,\"recordsFiltered\":1,\"data\":[{\"id\":33,\"created\":1530542074000,\"updated\":1530542074000,\"title\":\"ad1\",\"subTitle\":\"ad1\",\"titleDesc\":\"ad1\",\"url\":\"https://sale.jd.com/act/XkCzhoisOMSW.html\",\"pic\":\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\",\"pic2\":\"\",\"content\":\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\",\"tbContentCategory\":{\"id\":89,\"created\":null,\"updated\":null,\"parent\":null,\"isParent\":null,\"name\":\"幻灯片\",\"status\":null,\"sortOrder\":null}}],\"error\":null}\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(347,3,'Spring 事务管理简介',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>事务原本是数据库中的概念，用于数据访问层。但一般情况下，需要将事务提升到业务层，即 Service 层。这样做是为了能够使用事务的特性来管理具体的业务。</p> \n <p>在 Spring 中通常可以通过以下三种方式来实现对事务的管理：</p> \n <ul> \n  <li><p>使用 Spring 的事务代理工厂管理事务（已过时）</p> </li> \n  <li><p>使用 Spring 的事务注解管理事务</p> </li> \n  <li><p>使用 AspectJ 的 AOP 配置管理事务</p> </li> \n </ul> \n <h3 id=\"Spring-事务管理-API\"><a href=\"#Spring-事务管理-API\" class=\"headerlink\" title=\"Spring 事务管理 API\"></a>Spring 事务管理 API</h3>\n <p>Spring 的事务管理，主要用到两个事务相关的接口。</p> \n <h4 id=\"事务管理器接口\"><a href=\"#事务管理器接口\" class=\"headerlink\" title=\"事务管理器接口\"></a>事务管理器接口</h4>\n <p>事务管理器是 <code>PlatformTransactionManager</code> 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。 </p> \n <p>该接口定义了 3 个事务方法：</p> \n <ul> \n  <li><p><code>void commit(TransactionStatus status)</code>：事务的提交</p> </li> \n  <li><p><code>TransactionStatus getTransaction(TransactionDefinition definition)</code>：获取事务的状态</p> </li> \n  <li><p><code>void rollback(TranscationStatus status)</code>：事务的回滚</p> </li> \n </ul> \n <h5 id=\"常用的两个实现类\"><a href=\"#常用的两个实现类\" class=\"headerlink\" title=\"常用的两个实现类\"></a>常用的两个实现类</h5>\n <p><code>PlatformTransactionManager</code> 接口有两个常用的实现类：</p> \n <ul> \n  <li><p><code>DataSourceTransactionManager</code>：使用 JDBC 或 MyBatis 进行持久化数据时使用。</p> </li> \n  <li><p><code>HibernateTransactionManager</code>：使用 Hibernate 进行持久化数据时使用。</p> </li> \n </ul> \n <h5 id=\"Spring-的回滚方式\"><a href=\"#Spring-的回滚方式\" class=\"headerlink\" title=\"Spring 的回滚方式\"></a>Spring 的回滚方式</h5>\n <p>Spring 事务的默认回滚方式是：发生运行时异常回滚</p> \n <h4 id=\"事务定义接口\"><a href=\"#事务定义接口\" class=\"headerlink\" title=\"事务定义接口\"></a>事务定义接口</h4>\n <p>事务定义接口 <code>TransactionDefinition</code> 中定义了事务描述相关的三类常量：<strong>事务隔离级别</strong>、<strong>事务传播行为</strong>、<strong>事务默认超时时限</strong>，及对它们的操作。</p> \n <h5 id=\"事务的四种隔离级别\"><a href=\"#事务的四种隔离级别\" class=\"headerlink\" title=\"事务的四种隔离级别\"></a>事务的四种隔离级别</h5>\n <ul> \n  <li><p>DEFAULT：采用 DB 默认的事务隔离级别。MySql 默认为 REPEATABLE_READ；Oracle 默认为：READ_COMMITTED；</p> </li> \n  <li><p>READ_UNCOMMITTED：读未提交。未解决任何并发问题。</p> </li> \n  <li><p>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。</p> </li> \n  <li><p>REPEATABLE_READ：可重复读。解决脏读、不可重复读。存在幻读。</p> </li> \n  <li><p>SERIALIZABLE：串行化。不存在并发问题。</p> </li> \n </ul> \n <h5 id=\"事务的七种传播行为\"><a href=\"#事务的七种传播行为\" class=\"headerlink\" title=\"事务的七种传播行为\"></a>事务的七种传播行为</h5>\n <p>所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法 <code>a()</code> 调用 B 事务中的方法 <code>b()</code>，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法上的。</p> \n <ul> \n  <li><p>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。</p> </li> \n  <li><p>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。</p> </li> \n  <li><p>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</p> </li> \n  <li><p>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</p> </li> \n  <li><p>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</p> </li> \n  <li><p>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</p> </li> \n  <li><p>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(348,3,'使用 Spring 注解管理事务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>通过 <code>@Transactional</code> 注解方式，也可将事务织入到相应方法中。而使用注解方式，只需在配置文件中加入一个 <code>tx</code> 标签，以告诉 Spring 使用注解来完成事务的织入。该标签只需指定一个属性，事务管理器。</p> \n <pre><code>&lt;!-- 开启事务注解驱动 --&gt;\n&lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt;\n</code></pre>\n <h3 id=\"Transactional-注解简介\"><a href=\"#Transactional-注解简介\" class=\"headerlink\" title=\"@Transactional 注解简介\"></a><code>@Transactional</code> 注解简介</h3>\n <p><code>@Transactional</code> 的所有可选属性：</p> \n <ul> \n  <li><p><code>propagation</code>：用于设置事务传播属性。该属性类型为 Propagation 枚举，默认值为 <code>Propagation.REQUIRED</code>。</p> </li> \n  <li><p><code>isolation</code>：用于设置事务的隔离级别。该属性类型为 Isolation 枚举 ，默认值为 <code>Isolation.DEFAULT</code>。</p> </li> \n  <li><p><code>readOnly</code>：用于设置该方法对数据库的操作是否是只读的。该属性为 boolean，默认值为 <code>false</code>。</p> </li> \n  <li><p><code>timeout</code>：用于设置本操作与数据库连接的超时时限。单位为秒，类型为 int，默认值为 -1，即没有时限。</p> </li> \n  <li><p><code>rollbackFor</code>：指定需要回滚的异常类。类型为 <code>Class[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>rollbackForClassName</code>：指定需要回滚的异常类类名。类型为 <code>String[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>noRollbackFor</code>：指定不需要回滚的异常类。类型为 <code>Class[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n  <li><p><code>noRollbackForClassName</code>： 指定不需要回滚的异常类类名。类型为 <code>String[]</code>，默认值为空数组。当然，若只有一个异常类时，可以不使用数组。</p> </li> \n </ul> \n <p>需要注意的是，<code>@Transactional</code> 若用在方法上，只能用于 <code>public</code> 方法上。对于其他非 <code>public</code> 方法，如果加上了注解 <code>@Transactional</code>，虽然 Spring 不会报错，但不会将指定事务织入到该方法中。因为 Spring 会忽略掉所有非 <code>public</code> 方法上的 <code>@Transaction</code> 注解。</p> \n <p>若 <code>@Transaction</code> 注解在类上，则表示该类上所有的方法均将在执行时织入事务。</p> \n <h3 id=\"使用-Transaction-注解\"><a href=\"#使用-Transaction-注解\" class=\"headerlink\" title=\"使用 @Transaction 注解\"></a>使用 <code>@Transaction</code> 注解</h3>\n <p>使用起来很简单，只需要在需要增加事务的业务类上增加 <code>@Transaction</code> 注解即可，案例代码如下：</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Transactional\n@Service(value = \"tbContentCategoryService\")\npublic class TbContentCategoryServiceImpl implements TbContentCategoryService {\n\n    @Autowired\n    private TbContentCategoryDao tbContentCategoryDao;\n\n    @Autowired\n    private TbContentService tbContentService;\n\n    public void save(TbContentCategory tbContentCategory, TbContent tbContent) {\n        tbContentCategoryDao.insert(tbContentCategory);\n        tbContentService.save(tbContent);\n    }\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(349,3,'使用 Jackson 处理 JSON 数据',1,NULL,1,'<div class=\"col-sm-12\"> \n <h3 id=\"Jackson-简介\"><a href=\"#Jackson-简介\" class=\"headerlink\" title=\"Jackson 简介\"></a>Jackson 简介</h3>\n <p>Jackson 是一个简单基于 Java 应用库，Jackson 可以轻松的将 Java 对象转换成 json 对象和 xml 文档，同样也可以将 json、xml 转换成 Java 对象。Jackson 所依赖的 jar 包较少，简单易用并且性能也要相对高些，并且 Jackson 社区相对比较活跃，更新速度也比较快。</p> \n <h3 id=\"Jackson-特点\"><a href=\"#Jackson-特点\" class=\"headerlink\" title=\"Jackson 特点\"></a>Jackson 特点</h3>\n <ul> \n  <li><p>容易使用 - jackson API 提供了一个高层次外观，以简化常用的用例。</p> </li> \n  <li><p>无需创建映射 - API提供了默认的映射大部分对象序列化。</p> </li> \n  <li><p>性能高 - 快速，低内存占用，适合大型对象图表或系统。</p> </li> \n  <li><p>干净的 JSON - jackson 创建一个干净和紧凑的 JSON 结果，这是让人很容易阅读。</p> </li> \n  <li><p>不依赖 - 库不需要任何其他的库，除了 JDK。</p> </li> \n  <li><p>开源代码 - jackson 是开源的，可以免费使用。</p> </li> \n </ul> \n <h3 id=\"Jackson-注解\"><a href=\"#Jackson-注解\" class=\"headerlink\" title=\"Jackson 注解\"></a>Jackson 注解</h3>\n <p>Jackson 类库包含了很多注解，可以让我们快速建立 Java 类与 JSON 之间的关系。</p> \n <h4 id=\"JsonProperty\"><a href=\"#JsonProperty\" class=\"headerlink\" title=\"@JsonProperty\"></a><code>@JsonProperty</code></h4>\n <p><code>@JsonProperty</code> 注解指定一个属性用于 JSON 映射，默认情况下映射的 JSON 属性与注解的属性名称相同，不过可以使用该注解的 <code>value</code> 值修改 JSON 属性名，该注解还有一个 <code>index</code> 属性指定生成 JSON 属性的顺序，如果有必要的话。</p> \n <h4 id=\"JsonIgnore\"><a href=\"#JsonIgnore\" class=\"headerlink\" title=\"@JsonIgnore\"></a><code>@JsonIgnore</code></h4>\n <p><code>@JsonIgnore</code> 注解用于排除某个属性，这样该属性就不会被 Jackson 序列化和反序列化。</p> \n <h4 id=\"JsonIgnoreProperties\"><a href=\"#JsonIgnoreProperties\" class=\"headerlink\" title=\"@JsonIgnoreProperties\"></a><code>@JsonIgnoreProperties</code></h4>\n <p><code>@JsonIgnoreProperties</code> 注解是类注解。在序列化为 JSON 的时候，<code>@JsonIgnoreProperties({\"prop1\", \"prop2\"})</code> 会忽略 <code>pro1</code> 和 <code>pro2</code> 两个属性。在从 JSON 反序列化为 Java 类的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code> 会忽略所有没有 <code>Getter</code> 和 <code>Setter</code> 的属性。该注解在 Java 类和 JSON 不完全匹配的时候很有用。</p> \n <h4 id=\"JsonIgnoreType\"><a href=\"#JsonIgnoreType\" class=\"headerlink\" title=\"@JsonIgnoreType\"></a><code>@JsonIgnoreType</code></h4>\n <p><code>@JsonIgnoreType</code> 也是类注解，会排除所有指定类型的属性。</p> \n <h4 id=\"JsonPropertyOrder\"><a href=\"#JsonPropertyOrder\" class=\"headerlink\" title=\"@JsonPropertyOrder\"></a><code>@JsonPropertyOrder</code></h4>\n <p><code>@JsonPropertyOrder</code> 和 <code>@JsonProperty</code> 的 <code>index</code> 属性类似，指定属性序列化时的顺序。</p> \n <h4 id=\"JsonRootName\"><a href=\"#JsonRootName\" class=\"headerlink\" title=\"@JsonRootName\"></a><code>@JsonRootName</code></h4>\n <p><code>@JsonRootName</code> 注解用于指定 JSON 根属性的名称。</p> \n <h3 id=\"Jackson-使用实例\"><a href=\"#Jackson-使用实例\" class=\"headerlink\" title=\"Jackson 使用实例\"></a>Jackson 使用实例</h3>\n <h4 id=\"对象的序列化与反序列化\"><a href=\"#对象的序列化与反序列化\" class=\"headerlink\" title=\"对象的序列化与反序列化\"></a>对象的序列化与反序列化</h4>\n <pre><code>package com.funtl.hello.httpclient;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\n\npublic class JsonTester {\n    public static void main(String[] args) {\n        // 创建 ObjectMapper 对象\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonString = \"{\\\"name\\\":\\\"Mahesh\\\", \\\"age\\\":21}\";\n\n        try {\n            // 反序列化 JSON 到对象\n            Student student = mapper.readValue(jsonString, Student.class);\n            System.out.println(student);\n\n            // 序列化对象到 JSON\n            String json = mapper.writeValueAsString(student);\n            System.out.println(json);\n        } catch (JsonParseException e) {\n            e.printStackTrace();\n        } catch (JsonMappingException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Student {\n    private String name;\n    private int age;\n\n    public Student() {\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String toString() {\n        return \"Student [ name: \" + name + \", age: \" + age + \" ]\";\n    }\n}\n</code></pre>\n <h4 id=\"集合的序列化与反序列化\"><a href=\"#集合的序列化与反序列化\" class=\"headerlink\" title=\"集合的序列化与反序列化\"></a>集合的序列化与反序列化</h4>\n <pre><code>package com.funtl.hello.httpclient;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class JsonTester {\n    public static void main(String[] args) {\n        // 创建 ObjectMapper 对象\n        ObjectMapper mapper = new ObjectMapper();\n        String jsonString = \"{\\\"draw\\\":1,\\\"recordsTotal\\\":1,\\\"recordsFiltered\\\":1,\\\"data\\\":[{\\\"id\\\":33,\\\"title\\\":\\\"ad1\\\",\\\"subTitle\\\":\\\"ad1\\\",\\\"titleDesc\\\":\\\"ad1\\\",\\\"url\\\":\\\"https://sale.jd.com/act/XkCzhoisOMSW.html\\\",\\\"pic\\\":\\\"https://m.360buyimg.com/babel/jfs/t20164/187/1771326168/92964/b42fade7/5b359ab2N93be3a65.jpg\\\",\\\"pic2\\\":\\\"\\\",\\\"content\\\":\\\"&lt;p&gt;&lt;br&gt;&lt;/p&gt;\\\"}],\\\"error\\\":null}\";\n\n        try {\n            // 反序列化 JSON 到树\n            JsonNode jsonNode = mapper.readTree(jsonString);\n\n            // 从树中读取 data 节点\n            JsonNode jsonData = jsonNode.findPath(\"data\");\n            System.out.println(jsonData);\n\n            // 反序列化 JSON 到集合\n            JavaType javaType = mapper.getTypeFactory().constructParametricType(ArrayList.class, TbContent.class);\n            List&lt;TbContent&gt; tbContents = mapper.readValue(jsonData.toString(), javaType);\n            for (TbContent tbContent : tbContents) {\n                System.out.println(tbContent);\n            }\n\n            // 序列化集合到 JSON\n            String json = mapper.writeValueAsString(tbContents);\n            System.out.println(json);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass TbContent {\n    private Long id;\n    private String title;\n    private String subTitle;\n    private String titleDesc;\n    private String url;\n    private String pic;\n    private String pic2;\n    private String content;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getSubTitle() {\n        return subTitle;\n    }\n\n    public void setSubTitle(String subTitle) {\n        this.subTitle = subTitle;\n    }\n\n    public String getTitleDesc() {\n        return titleDesc;\n    }\n\n    public void setTitleDesc(String titleDesc) {\n        this.titleDesc = titleDesc;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getPic() {\n        return pic;\n    }\n\n    public void setPic(String pic) {\n        this.pic = pic;\n    }\n\n    public String getPic2() {\n        return pic2;\n    }\n\n    public void setPic2(String pic2) {\n        this.pic2 = pic2;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    @Override\n    public String toString() {\n        return \"TbContent{\" +\n                \"id=\" + id +\n                \", title=\'\" + title + \'\\\'\' +\n                \", subTitle=\'\" + subTitle + \'\\\'\' +\n                \", titleDesc=\'\" + titleDesc + \'\\\'\' +\n                \", url=\'\" + url + \'\\\'\' +\n                \", pic=\'\" + pic + \'\\\'\' +\n                \", pic2=\'\" + pic2 + \'\\\'\' +\n                \", content=\'\" + content + \'\\\'\' +\n                \'}\';\n    }\n}\n</code></pre> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(350,3,'你怎么理解 RESTful',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>2000 年，Roy Thomas Fielding 博士在他那篇著名的博士论文《Architectural Styles and the Design of Network-based Software Architectures》中提出了几种软件应用的架构风格，REST 作为其中的一种架构风格在这篇论文的第5章中进行了概括性的介绍。</p> \n <p>REST 是“REpresentational State Transfer”的缩写，可以翻译成“表现状态转换”，但是在绝大多数场合中我们只说 REST 或者 RESTful。Fielding 在论文中将 REST 定位为“分布式超媒体应用（Distributed Hypermedia System）”的架构风格，它在文中提到一个名为“HATEOAS（Hypermedia as the engine of application state）”的概念。</p> \n <p>我们利用一个面向最终用户的 Web 应用来对这个概念进行简单阐述：这里所谓的应用状态（Application State）表示 Web 应用的客户端的状态，简单起见可以理解为会话状态。资源在浏览器中以超媒体的形式呈现，通过点击超媒体中的链接可以获取其它相关的资源或者对当前资源进行相应的处理，获取的资源或者针对资源处理的响应同样以超媒体的形式再次呈现在浏览器上。由此可见，超媒体成为了驱动客户端会话状态的转换的引擎。</p> \n <p>借助于超媒体这种特殊的资源呈现方式，应用状态的转换体现为浏览器中呈现资源的转换。如果将超媒体进一步抽象成一般意义上的资源呈现（Representation ）方式，那么应用状态变成了可被呈现的状态（REpresentational State）。应用状态之间的转换就成了可被呈现的状态装换（REpresentational State Transfer），这就是 REST。</p> \n <h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>\n <p>REST 是一种很笼统的概念，它代表一种架构风格。</p> \n</div>',NULL,NULL,'2018-12-20 22:06:10','2018-12-20 22:06:10'),
(351,3,'使用 AspectJ 的 AOP 配置管理事务',1,NULL,1,'<div class=\"col-sm-12\"> \n <p>注：本案例所使用的数据库为 <code>项目实战</code> 中的数据库，有需要的请加群获取</p> \n <p>AspectJ 主要是使用 XML 配置顾问方式自动为每个符合切入点表达式的类生成事务代理。创建测试操作步骤如下：</p> \n <h4 id=\"创建测试项目\"><a href=\"#创建测试项目\" class=\"headerlink\" title=\"创建测试项目\"></a>创建测试项目</h4>\n <p>创建一个名为 <code>aspectj-aop</code> 项目，<code>pom.xml</code> 文件如下：</p> \n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;hello-spring-transaction&lt;/groupId&gt;\n    &lt;artifactId&gt;aspectj-aop&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;\n    &lt;packaging&gt;jar&lt;/packaging&gt;\n\n    &lt;properties&gt;\n        &lt;!-- 环境配置 --&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n\n        &lt;!-- 统一的依赖管理 --&gt;\n        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;\n        &lt;slf4j.version&gt;1.7.25&lt;/slf4j.version&gt;\n        &lt;spring.version&gt;4.3.17.RELEASE&lt;/spring.version&gt;\n        &lt;alibaba-druid.version&gt;1.1.6&lt;/alibaba-druid.version&gt;\n        &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt;\n        &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt;\n        &lt;mybaits-spring.version&gt;1.3.1&lt;/mybaits-spring.version&gt;\n        &lt;junit.version&gt;4.12&lt;/junit.version&gt;\n        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;!-- Test Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;/groupId&gt;\n            &lt;artifactId&gt;junit&lt;/artifactId&gt;\n            &lt;version&gt;${junit.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Test Begin --&gt;\n\n        &lt;!-- Spring Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Spring End --&gt;\n\n        &lt;!-- Log Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n            &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt;\n            &lt;version&gt;${slf4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n            &lt;version&gt;${log4j.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Log End --&gt;\n\n        &lt;!-- Database Begin --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n            &lt;artifactId&gt;druid&lt;/artifactId&gt;\n            &lt;version&gt;${alibaba-druid.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;${mysql.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;\n            &lt;version&gt;${mybatis.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;\n            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;\n            &lt;version&gt;${mybaits-spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;\n            &lt;version&gt;${spring.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- Database End --&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n            &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n            &lt;version&gt;${lombok.version}&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre>\n <p>相较于 <code>项目实战</code> 中的 POM，主要是增加了 <code>org.springframework:spring-aspects</code> 依赖</p> \n <h4 id=\"创建实体类\"><a href=\"#创建实体类\" class=\"headerlink\" title=\"创建实体类\"></a>创建实体类</h4>\n <h5 id=\"TbContentCategory\"><a href=\"#TbContentCategory\" class=\"headerlink\" title=\"TbContentCategory\"></a>TbContentCategory</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.domain;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n/**\n * 分类管理\n * &lt;p&gt;Title: TbContentCategory&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/25 9:14\n */\n@Data\npublic class TbContentCategory {\n    private Long id;\n    private String name;\n    private Integer status;\n    private Integer sortOrder;\n    private Boolean isParent;\n    private Date created;\n    private Date updated;\n    private TbContentCategory parent;\n}\n</code></pre>\n <h5 id=\"TbContent\"><a href=\"#TbContent\" class=\"headerlink\" title=\"TbContent\"></a>TbContent</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.domain;\n\nimport lombok.Data;\n\nimport java.util.Date;\n\n/**\n * 内容管理\n * &lt;p&gt;Title: TbContent&lt;/p&gt;\n * &lt;p&gt;Description: &lt;/p&gt;\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/25 14:02\n */\n@Data\npublic class TbContent {\n    private Long id;\n    private String title;\n    private String subTitle;\n    private String titleDesc;\n    private String url;\n    private String pic;\n    private String pic2;\n    private String content;\n    private Date created;\n    private Date updated;\n    private TbContentCategory tbContentCategory;\n}\n</code></pre>\n <h4 id=\"创建数据访问层\"><a href=\"#创建数据访问层\" class=\"headerlink\" title=\"创建数据访问层\"></a>创建数据访问层</h4>\n <h5 id=\"TbContentCategoryDao\"><a href=\"#TbContentCategoryDao\" class=\"headerlink\" title=\"TbContentCategoryDao\"></a>TbContentCategoryDao</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.dao;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface TbContentCategoryDao {\n    void insert(TbContentCategory tbContentCategory);\n}\n</code></pre>\n <h5 id=\"TbContentDao\"><a href=\"#TbContentDao\" class=\"headerlink\" title=\"TbContentDao\"></a>TbContentDao</h5>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.dao;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface TbContentDao {\n    void insert(TbContent tbContent);\n}\n</code></pre>\n <h4 id=\"创建业务逻辑层\"><a href=\"#创建业务逻辑层\" class=\"headerlink\" title=\"创建业务逻辑层\"></a>创建业务逻辑层</h4>\n <h5 id=\"TbContentCategoryService\"><a href=\"#TbContentCategoryService\" class=\"headerlink\" title=\"TbContentCategoryService\"></a>TbContentCategoryService</h5>\n <p>接口</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\n\npublic interface TbContentCategoryService {\n    void save(TbContentCategory tbContentCategory, TbContent tbContent);\n}\n</code></pre>\n <p>实现</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TbContentCategoryServiceImpl implements TbContentCategoryService {\n\n    @Autowired\n    private TbContentCategoryDao tbContentCategoryDao;\n\n    @Autowired\n    private TbContentService tbContentService;\n\n    public void save(TbContentCategory tbContentCategory, TbContent tbContent) {\n        tbContentCategoryDao.insert(tbContentCategory);\n        tbContentService.save(tbContent);\n    }\n}\n</code></pre>\n <h5 id=\"TbContentService\"><a href=\"#TbContentService\" class=\"headerlink\" title=\"TbContentService\"></a>TbContentService</h5>\n <p>接口</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\n\npublic interface TbContentService {\n    void save(TbContent tbContent);\n}\n</code></pre>\n <p>实现</p> \n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.impl;\n\nimport com.hello.spring.transaction.aspectsj.aop.dao.TbContentDao;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TbContentServiceImpl implements TbContentService {\n\n    @Autowired\n    private TbContentDao tbContentDao;\n\n    public void save(TbContent tbContent) {\n        tbContentDao.insert(tbContent);\n    }\n}\n</code></pre>\n <h4 id=\"创建-Spring-配置\"><a href=\"#创建-Spring-配置\" class=\"headerlink\" title=\"创建 Spring 配置\"></a>创建 Spring 配置</h4>\n <h5 id=\"spring-context-xml\"><a href=\"#spring-context-xml\" class=\"headerlink\" title=\"spring-context.xml\"></a><code>spring-context.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;\n\n    &lt;context:annotation-config/&gt;\n    &lt;context:component-scan base-package=\"com.hello.spring.transaction.aspectsj.aop\"&gt;\n        &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;\n    &lt;/context:component-scan&gt;\n\n    &lt;!-- 配置事务管理器 --&gt;\n    &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 配置事务通知 --&gt;\n    &lt;tx:advice id=\"myAdvice\" transaction-manager=\"transactionManager\"&gt;\n        &lt;tx:attributes&gt;\n            &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt;\n        &lt;/tx:attributes&gt;\n    &lt;/tx:advice&gt;\n\n    &lt;!-- 配置顾问和切入点 --&gt;\n    &lt;aop:config&gt;\n        &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.hello.spring.transaction.aspectsj.aop.service.*.*(..))\" /&gt;\n        &lt;aop:advisor advice-ref=\"myAdvice\" pointcut-ref=\"myPointcut\" /&gt;\n    &lt;/aop:config&gt;\n&lt;/beans&gt;\n</code></pre>\n <h5 id=\"spring-context-druid-xml\"><a href=\"#spring-context-druid-xml\" class=\"headerlink\" title=\"spring-context-druid.xml\"></a><code>spring-context-druid.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;\n\n    &lt;!-- 加载配置属性文件 --&gt;\n    &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:jdbc.properties\"/&gt;\n\n    &lt;!-- 数据源配置, 使用 Druid 数据库连接池 --&gt;\n    &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt;\n        &lt;!-- 数据源驱动类可不写，Druid默认会自动根据URL识别DriverClass --&gt;\n        &lt;property name=\"driverClassName\" value=\"${jdbc.driverClass}\"/&gt;\n\n        &lt;!-- 基本属性 url、user、password --&gt;\n        &lt;property name=\"url\" value=\"${jdbc.connectionURL}\"/&gt;\n        &lt;property name=\"username\" value=\"${jdbc.username}\"/&gt;\n        &lt;property name=\"password\" value=\"${jdbc.password}\"/&gt;\n\n        &lt;!-- 配置初始化大小、最小、最大 --&gt;\n        &lt;property name=\"initialSize\" value=\"${jdbc.pool.init}\"/&gt;\n        &lt;property name=\"minIdle\" value=\"${jdbc.pool.minIdle}\"/&gt;\n        &lt;property name=\"maxActive\" value=\"${jdbc.pool.maxActive}\"/&gt;\n\n        &lt;!-- 配置获取连接等待超时的时间 --&gt;\n        &lt;property name=\"maxWait\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;\n        &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt;\n\n        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;\n        &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt;\n\n        &lt;property name=\"validationQuery\" value=\"${jdbc.testSql}\"/&gt;\n        &lt;property name=\"testWhileIdle\" value=\"true\"/&gt;\n        &lt;property name=\"testOnBorrow\" value=\"false\"/&gt;\n        &lt;property name=\"testOnReturn\" value=\"false\"/&gt;\n\n        &lt;!-- 配置监控统计拦截的filters --&gt;\n        &lt;property name=\"filters\" value=\"stat\"/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h5 id=\"spring-context-mybatis-xml\"><a href=\"#spring-context-mybatis-xml\" class=\"headerlink\" title=\"spring-context-mybatis.xml\"></a><code>spring-context-mybatis.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;\n\n    &lt;!-- 配置 SqlSession --&gt;\n    &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;\n        &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;\n        &lt;!-- 用于配置对应实体类所在的包，多个 package 之间可以用 \',\' 号分割 --&gt;\n        &lt;property name=\"typeAliasesPackage\" value=\"com.hello.spring.transaction.aspectsj.aop.domain\"/&gt;\n        &lt;!-- 用于配置对象关系映射配置文件所在目录 --&gt;\n        &lt;property name=\"mapperLocations\" value=\"classpath:/mapper/**/*.xml\"/&gt;\n        &lt;property name=\"configLocation\" value=\"classpath:/mybatis-config.xml\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!-- 扫描 Mapper --&gt;\n    &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;\n        &lt;property name=\"basePackage\" value=\"com.hello.spring.transaction.aspectsj.aop.dao\" /&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;\n</code></pre>\n <h4 id=\"创建-MyBatis-配置和映射文件\"><a href=\"#创建-MyBatis-配置和映射文件\" class=\"headerlink\" title=\"创建 MyBatis 配置和映射文件\"></a>创建 MyBatis 配置和映射文件</h4>\n <h5 id=\"mybatis-config-xml\"><a href=\"#mybatis-config-xml\" class=\"headerlink\" title=\"mybatis-config.xml\"></a><code>mybatis-config.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n    &lt;!-- 全局参数 --&gt;\n    &lt;settings&gt;\n        &lt;!-- 打印 SQL 语句 --&gt;\n        &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt;\n\n        &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt;\n        &lt;setting name=\"cacheEnabled\" value=\"false\"/&gt;\n\n        &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt;\n        &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt;\n        &lt;setting name=\"aggressiveLazyLoading\" value=\"true\"/&gt;\n\n        &lt;!-- 是否允许单条 SQL 返回多个数据集 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt;\n\n        &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt;\n        &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt;\n\n        &lt;!-- 允许 JDBC 生成主键。需要驱动器支持。如果设为了 true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false  --&gt;\n        &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt;\n\n        &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不映射 PARTIAL：部分 FULL:全部  --&gt;\n        &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt;\n\n        &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt;\n        &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt;\n\n        &lt;!-- 使用驼峰命名法转换字段。 --&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n\n        &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt;\n        &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt;\n\n        &lt;!-- 设置 JDBC 类型为空时,某些驱动程序 要指定值, default:OTHER，插入空值时不需要指定类型 --&gt;\n        &lt;setting name=\"jdbcTypeForNull\" value=\"NULL\"/&gt;\n    &lt;/settings&gt;\n&lt;/configuration&gt;\n</code></pre>\n <h5 id=\"TbContentCategoryMapper-xml\"><a href=\"#TbContentCategoryMapper-xml\" class=\"headerlink\" title=\"TbContentCategoryMapper.xml\"></a><code>TbContentCategoryMapper.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.hello.spring.transaction.aspectsj.aop.dao.TbContentCategoryDao\"&gt;\n    &lt;insert id=\"insert\"&gt;\n        INSERT INTO tb_content_category (\n          `parent_id`,\n          `name`,\n          `status`,\n          `sort_order`,\n          `is_parent`,\n          `created`,\n          `updated`\n        )\n        VALUES\n          (\n            #{parent.id},\n            #{name},\n            #{status},\n            #{sortOrder},\n            #{isParent},\n            #{created},\n            #{updated}\n          );\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h5 id=\"TbContentMapper-xml\"><a href=\"#TbContentMapper-xml\" class=\"headerlink\" title=\"TbContentMapper.xml\"></a><code>TbContentMapper.xml</code></h5>\n <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n&lt;mapper namespace=\"com.hello.spring.transaction.aspectsj.aop.dao.TbContentDao\"&gt;\n    &lt;insert id=\"insert\"&gt;\n        INSERT INTO tb_content (\n          `category_id`,\n          `title`,\n          `sub_title`,\n          `title_desc`,\n          `url`,\n          `pic`,\n          `pic2`,\n          `content`,\n          `created`,\n          `updated`\n        )\n        VALUES\n          (\n            #{tbContentCategory.id},\n            #{title},\n            #{subTitle},\n            #{titleDesc},\n            #{url},\n            #{pic},\n            #{pic2},\n            #{content},\n            #{created},\n            #{updated}\n          )\n    &lt;/insert&gt;\n&lt;/mapper&gt;\n</code></pre>\n <h4 id=\"创建系统配置文件\"><a href=\"#创建系统配置文件\" class=\"headerlink\" title=\"创建系统配置文件\"></a>创建系统配置文件</h4>\n <h5 id=\"log4j-properties\"><a href=\"#log4j-properties\" class=\"headerlink\" title=\"log4j.properties\"></a><code>log4j.properties</code></h5>\n <pre><code>log4j.rootLogger=INFO, console, file\n\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%n\n\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.File=logs/log.log\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.A3.MaxFileSize=1024KB\nlog4j.appender.A3.MaxBackupIndex=10\nlog4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n\n</code></pre>\n <h5 id=\"jdbc-properties\"><a href=\"#jdbc-properties\" class=\"headerlink\" title=\"jdbc.properties\"></a><code>jdbc.properties</code></h5>\n <pre><code>#============================#\n#==== Database settings ====#\n#============================#\n\n# JDBC\n# MySQL 8.x: com.mysql.cj.jdbc.Driver\njdbc.driverClass=com.mysql.jdbc.Driver\njdbc.connectionURL=jdbc:mysql://192.168.75.134:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false\njdbc.username=root\njdbc.password=123456\n\n# JDBC Pool\njdbc.pool.init=1\njdbc.pool.minIdle=3\njdbc.pool.maxActive=20\n\n# JDBC Test\njdbc.testSql=SELECT \'x\' FROM DUAL\n</code></pre>\n <h4 id=\"创建测试类\"><a href=\"#创建测试类\" class=\"headerlink\" title=\"创建测试类\"></a>创建测试类</h4>\n <pre><code>package com.hello.spring.transaction.aspectsj.aop.service.test;\n\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContent;\nimport com.hello.spring.transaction.aspectsj.aop.domain.TbContentCategory;\nimport com.hello.spring.transaction.aspectsj.aop.service.TbContentCategoryService;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:spring-context.xml\", \"classpath:spring-context-druid.xml\", \"classpath:spring-context-mybatis.xml\"})\npublic class TestSpringTransaction {\n\n    @Autowired\n    private TbContentCategoryService tbContentCategoryService;\n\n    @Test\n    public void test() {\n        TbContentCategory tbContentCategory = new TbContentCategory();\n        tbContentCategory.setId(1L);\n        tbContentCategory.setName(\"测试事务分类\");\n\n        TbContent tbContent = new TbContent();\n        tbContent.setTbContentCategory(tbContentCategory);\n        // 在这里你可以将内容设置为超出数据库字段的存储范围来验证事务是否开启\n        tbContent.setTitle(\"测试事务内容\");\n\n        tbContentCategoryService.save(tbContentCategory, tbContent);\n    }\n}\n</code></pre>\n <p>运行观察事务效果：</p> \n <ul> \n  <li><p>有事务：数据插入成功则两张表都存在数据，只要出现异常则两张表都没有数据</p> </li> \n  <li><p>无事务：如果第一张表数据插入成功，但第二张表报错则第一张表的数据不会回滚</p> </li> \n </ul> \n</div>',NULL,NULL,'2018-12-20 22:06:11','2018-12-20 22:06:11');

/*Table structure for table `type` */

DROP TABLE IF EXISTS `type`;

CREATE TABLE `type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '类目id',
  `parent_id` bigint(20) DEFAULT NULL COMMENT '父类目ID=0时，代表的是一级的类目',
  `name` varchar(255) DEFAULT NULL COMMENT '类目名称',
  `status` int(1) DEFAULT '1' COMMENT '状态。可选值:1(正常),2(删除)',
  `is_parent` tinyint(1) DEFAULT '1' COMMENT '该类目是否为父类目，1为true，0为false',
  `sort_order` int(4) DEFAULT NULL COMMENT '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数',
  `created` datetime DEFAULT NULL COMMENT '创建时间',
  `updated` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

/*Data for the table `type` */

insert  into `type`(`id`,`parent_id`,`name`,`status`,`is_parent`,`sort_order`,`created`,`updated`) values 
(2,0,'编程语言',1,1,2,'2018-12-04 17:50:09','2018-12-17 17:50:21'),
(3,0,'单体应用',1,0,3,'2018-12-17 17:50:59','2018-12-17 17:51:03'),
(4,2,'Java',1,1,2,'2018-12-17 17:51:37','2018-12-17 17:51:40'),
(5,2,'PHP',1,0,1,'2018-12-17 17:52:17','2018-12-17 17:52:20'),
(6,0,'数据库应用',1,0,4,'2018-12-17 17:54:22','2018-12-17 17:54:25'),
(7,0,'微服务架构',1,1,5,'2018-12-17 17:55:08','2018-12-17 17:55:11'),
(8,0,'关于我们',1,0,6,'2018-12-17 17:56:03','2018-12-17 17:56:07'),
(9,0,'使用说明',1,0,7,'2018-12-17 17:56:50','2018-12-17 17:56:53'),
(10,0,'其他',0,0,8,'2018-12-17 17:57:29','2018-12-17 17:57:32'),
(11,7,'Spring Cloud',1,0,1,'2018-12-18 14:53:24','2018-12-18 14:53:30'),
(12,4,'面试宝典',1,1,2,'2018-12-19 15:22:54','2018-12-19 15:22:58');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(10) NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `username` varchar(255) DEFAULT NULL COMMENT '管理员名称',
  `password` varchar(255) DEFAULT NULL COMMENT '密码 MD5加密',
  `pic` varchar(255) DEFAULT NULL COMMENT '头像图片路径',
  `email` varchar(255) DEFAULT NULL COMMENT '邮箱地址',
  `phone` varchar(255) DEFAULT NULL COMMENT '手机号',
  `role` tinyint(1) DEFAULT '0' COMMENT '是否为超级管理员1为是,0为否',
  `status` int(1) DEFAULT '1' COMMENT '状态值0为删除,1为显示',
  `created` datetime DEFAULT NULL COMMENT '创建时间',
  `updated` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`id`,`username`,`password`,`pic`,`email`,`phone`,`role`,`status`,`created`,`updated`) values 
(1,'meizz','4297f44b13955235245b2497399d7a93',NULL,NULL,'13413684661',0,1,'2018-12-15 17:09:05','2018-12-15 17:09:09');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
